{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 6812000,
    "question_id": "3164",
    "elapsed_time": 46,
    "compare_result": "0001100100101011011010000101111100111011011001110110100010001110000000101100001000000101011101101010010001010001010101100101010111100111100001010101100011001101000000101000101100111011110000001100000001001111101111111100010100001100010110100001101010100000011111000000010011000010101000111001001000011010100010001000001010101000101011101010001001010001001100000010001110010000010101110001010001101111001000110110111011100110101001001000000001011001010000010000010000100101001001010000110000010011110001000000100000000100100000000011000000000000100000010000000000100101000000100001000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000010000100",
    "code_output": "[-1]",
    "std_output": "",
    "last_testcase": "[\"1\",\"2\",\"prev\",\"prev\",\"prev\"]",
    "expected_output": "[2,1,-1]",
    "task_finish_time": 1706379343332,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 226,
    "total_testcases": 706,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1158489540",
    "input_formatted": "[\"1\",\"2\",\"prev\",\"prev\",\"prev\"]",
    "input": "[\"1\",\"2\",\"prev\",\"prev\",\"prev\"]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <stdlib.h>\n#include <string.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* lastVisitedIntegers(char** words, int wordsSize, int* returnSize) {\n    int* visitedIntegers = (int*)malloc(sizeof(int) * wordsSize);\n    int* nums = (int*)malloc(sizeof(int) * wordsSize);\n    int numsSize = 0;\n    int returnIndex = 0;\n\n    for (int i = 0; i < wordsSize; ++i) {\n        if (strcmp(words[i], \"prev\") == 0) {\n            int k = 1;\n            // Count consecutive \"prev\"\n            while (i + k < wordsSize && strcmp(words[i + k], \"prev\") == 0) {\n                k++;\n            }\n            // Find the last visited integer\n            if (k <= numsSize) {\n                visitedIntegers[returnIndex++] = nums[numsSize - k];\n            } else {\n                visitedIntegers[returnIndex++] = -1;\n            }\n            i += k - 1; // Skip the counted \"prev\" strings\n        } else {\n            // Convert string to int and store it\n            nums[numsSize++] = atoi(words[i]);\n        }\n    }\n\n    *returnSize = returnIndex;\n    int* result = (int*)malloc(sizeof(int) * (*returnSize));\n    memcpy(result, visitedIntegers, sizeof(int) * (*returnSize));\n    free(visitedIntegers);\n    free(nums);\n    \n    return result;\n}"
}