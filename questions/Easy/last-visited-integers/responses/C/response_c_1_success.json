{
    "status_code": 10,
    "lang": "c",
    "run_success": true,
    "status_runtime": "7 ms",
    "memory": 6968000,
    "question_id": "3164",
    "elapsed_time": 21,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706379386504,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 706,
    "total_testcases": 706,
    "runtime_percentile": 75.0,
    "status_memory": "7 MB",
    "memory_percentile": 100,
    "pretty_lang": "C",
    "submission_id": "1158490174",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* lastVisitedIntegers(char** words, int wordsSize, int* returnSize) {\n    // Dynamic array to store the integers encountered so far.\n    int* nums = (int*)malloc(sizeof(int) * wordsSize);\n    // Dynamic array to store the results for \"prev\".\n    int* results = (int*)malloc(sizeof(int) * wordsSize);\n    int numsCount = 0, resultsCount = 0;\n\n    for (int i = 0; i < wordsSize; ++i) {\n        if (strcmp(words[i], \"prev\") == 0) {\n            int prevCount = 1;\n            // Find out how many \"prev\"s are there in a row, including the current one.\n            while ((i + prevCount < wordsSize) && (strcmp(words[i + prevCount], \"prev\") == 0)) {\n                prevCount++;\n            }\n\n            // Process each \"prev\" individually\n            for (int j = 0; j < prevCount; ++j) {\n                int indexToFetch = numsCount - 1 - j;\n                if (indexToFetch >= 0) {\n                    // If we have an integer to refer to.\n                    results[resultsCount++] = nums[indexToFetch];\n                } else {\n                    // If there are more \"prev\"s than integers.\n                    results[resultsCount++] = -1;\n                }\n            }\n\n            // Skip the \"prev\" strings that have been processed\n            i += prevCount - 1;\n        } else {\n            // Convert string to integer and store it.\n            nums[numsCount++] = atoi(words[i]);\n        }\n    }\n\n    *returnSize = resultsCount;\n    // Trim the results array to the exact number of results\n    int* returnArray = (int*)malloc(sizeof(int) * resultsCount);\n    for (int i = 0; i < resultsCount; ++i) {\n        returnArray[i] = results[i];\n    }\n\n    // Free the unused memory\n    free(nums);\n    free(results);\n\n    return returnArray;\n}"
}