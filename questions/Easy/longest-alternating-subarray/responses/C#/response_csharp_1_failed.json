{
    "status_code": 11,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 49344000,
    "question_id": "2870",
    "elapsed_time": 187,
    "compare_result": "000000100011001000001100010001110011110100101001011010000101001010000000100011011100010000111011010111100110010110110100001001100111000110011000001000011000100000100100010000011100010000110010100100010000011001110011100101001110011100101100010011100011101100001000011101010010010010101101000000001001001011100101001100000011010000110001110111000010000000010000011100000010000110001100100000101011010111100000010100010001011010110100100010010110001100110010100000101000000001101001011001100100100101011010011000101011110000000101010010100000101000010011100000001000011100100001000111000011001110110100100011010110100011000100010000101001110111101011000110001001100001000011000011001000100100101001111000000101011000010101010000100000001000000101100000110011100100101110011010010001000010010000100000000010001000011000110000001111001010011000101000010011001110010000010000011000110111001101011100011001110011100000001100000010100101001000110110100000001100110001110010110011001011001100101000111001000000000010010000110000111011010111000011000010010100110001110110000011001100101001110001000000100100010000010000111000110111100100000000101001011011110101101001010110010101101011100111001111010010011001100111110000101011100100110101111001110100101011001000000001110010100011101010001000101101100010000110100011000010100001111010000110100011011010111101000001010111101010000110101000001010110110000011000110001000110011100000100111010100110000001001100111101111001100001100100000010011100100001100001101000000010101001111011100010100110000010111100100010000110100101010100011101011001110011100101001100101011000011100111000100010100001000100011110010001010001000011001100000100001100110011000000101101000110100101101000110010001011000000111001111001110100101110011001101100001000000100101101001110011101001000100011101111001110110101101010010000001010011010001100010010111100001010011000011100000001100011100110001111100101111000000100101111101010010101011001100010101010011010110001010011010001000000000010100100100010000101100110000110011000110010010100001100011010001001100000010010000100010110101101111000010111001110001010100101000010110011100110000110110001010011010111100111011010100000110000110000100001011010111101001001110010000111001010010101101011110011100111000100011000011000100100100100010100111100110000110011101000001100110000111001000000100101011010101000001000110111101001000110111101001010000010101000011000110001101011100101000111001000100101111001010110001100011010100101000010100000100000000000000001000000000000000001000000000000010000100010000001000000010000010000010000000000011000001101000000110000000000000000010000010000110000001100011100000000000000100100000011000010000100000000010110000010000010100000100000000010000000000000000001011010000000000010000100000000000010000100100000000000000000000000000100000000000000000000000000000000000000000000000100",
    "code_output": "5",
    "std_output": "",
    "last_testcase": "[2,3,4,3,4]",
    "expected_output": "4",
    "task_finish_time": 1706393159291,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 1087,
    "total_testcases": 2880,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C#",
    "submission_id": "1158633452",
    "input_formatted": "[2,3,4,3,4]",
    "input": "[2,3,4,3,4]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public int AlternatingSubarray(int[] nums) {\n        int maxLength = -1;\n        int currentLength = 1;\n\n        // Start iterating from the second element to compare with the previous\n        for (int i = 1; i < nums.Length; i++) {\n            // Check if the current and previous elements form an alternating pattern\n            if (Math.Abs(nums[i] - nums[i - 1]) == 1 && (i == 1 || (nums[i] - nums[i - 2] != nums[i - 1] - nums[i]))) {\n                currentLength++;\n            } else {\n                // Only update maxLength if the currentLength is for a valid alternating subarray\n                if (currentLength > 1) {\n                    maxLength = Math.Max(maxLength, currentLength);\n                }\n                // Reset currentLength since current pair doesn't alternate with previous\n                currentLength = 2; // Start counting again including the current element\n            }\n        }\n\n        // Update maxLength one last time in case the longest alternating subarray ends with the last element\n        if (currentLength > 1) {\n            maxLength = Math.Max(maxLength, currentLength);\n        }\n\n        // If no alternating subarray was found, return -1\n        return maxLength == -1 ? -1 : maxLength;\n    }\n}"
}