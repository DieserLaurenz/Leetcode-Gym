{
    "status_code": 11,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 58176000,
    "question_id": "2870",
    "elapsed_time": 573,
    "compare_result": "000100001000010000100000000010000000000000010000100001000010000100001000010000100001000010000100000000000000100001000010000100001000010000100001000010000100001000010000100000000000000000001000010000100001000010000100001000010000100001000010000100000000010000100000000010000100000000010000100001000010000100001000010000100000000010000100000000010000000001000010000000001000010000000001000010000100001000010000100001000010000100001000010000100001000010000100001000010000100000000010000100000000010000100000000000000000000000010000100001000010000100001000010000000001000010000100001000010000100001000010000100001000000000100001000010000000001000000000100000000010000100000000010000000001000000000100000000010000100001000010000100000000010000100000000010000100001000000000100001000010000000001000000000100001000000000100001000000000000001000010000100001000010000100001000010000000001000010000100001000010000100001000010000000001000010000100000000010000100000000010000100000000010000100001000010000000000000010000000001000010000100001000010000100000000000000100001000010000100001000000000100001000010000100000000010000100001000010000100001000010000100001000010000000000000010000100001000010000100001000010000000001000000000000001000010000100001000010000100000000010000100001000010000100001000010000100001000010000100000000010000000001000010000000001000000000100001000010000000001000010000100001000010000100001000010000100001000010000100000000010000100001000010000100001000010000100000000010000100001000010000100000000010000000001000010000100000000000000100001000010000100001000010000100000000010000100001000000000100001000010000100000000000000100001000000000100001000010000100001000010000000001000000000100001000010000100001000010000100001000010000100000000010000100000000010000100001000000000100000000010000100001000010000000001000010000100001000010000000001000010000100000000010000000001000000000100001000010000100000000010000000001000000000000001000010000100001000010000100001000010000000000000000000100001000010000100001000010000100001000000000100001000010000100001000010000100001000010000100001000010000100001000010000000001000010000000000000010000100001000010000100000000010000100001000010000100000000000000100001000000000000001000000000100001000010000100001000010000100001000010000100001000000000100001000010000100001000000000100000000010000100001000010000100001000010000100001000000000100001000000000100001000010000100001000010000100001000010000000000000010000100001000010000100001000010000100001000000000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000000001000010000100001000010000100001000010000100000000010000100001000010000100001000000000100001000010000100001000010000100001000010000100001000010000100001000010000100001000010000000001000010000100001000011",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "[2,3,4,3,4]",
    "expected_output": "4",
    "task_finish_time": 1706408157957,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 464,
    "total_testcases": 2880,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Scala",
    "submission_id": "1158737241",
    "input_formatted": "[2,3,4,3,4]",
    "input": "[2,3,4,3,4]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "object Solution {\n    def alternatingSubarray(nums: Array[Int]): Int = {\n        if (nums.length < 2) return -1 // Base case, if the array length is less than 2, no subarray exists\n        \n        var maxLength = -1 // To store the maximum length of alternating subarrays\n        var currentLength = 1 // To store the current subarray length, starts with 1 as we count elements\n        \n        // Iterate through the array to find alternating subarrays\n        for(i <- 0 until nums.length - 1) {\n            // Check if the current element and the next element alternate correctly\n            if ((nums(i+1) - nums(i)).abs == 1 && (nums(i+1) - nums(i)) * ((-1) ^ currentLength) > 0) {\n                currentLength += 1 // Increase the length of the current subarray\n                maxLength = maxLength max currentLength // Update the maximum length if current is longer\n            } else {\n                currentLength = 1 // Reset current subarray length for the next potential subarray\n            }\n        }\n        \n        // If no alternating subarray was found, maxLength would be -1\n        // Otherwise, it contains the length of the longest alternating subarray\n        maxLength\n    }\n}"
}