{
    "status_code": 10,
    "lang": "racket",
    "run_success": true,
    "status_runtime": "200 ms",
    "memory": 101024000,
    "question_id": "3044",
    "elapsed_time": 326,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706554122605,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 619,
    "total_testcases": 619,
    "runtime_percentile": 100,
    "status_memory": "101 MB",
    "memory_percentile": 100,
    "pretty_lang": "Racket",
    "submission_id": "1160357767",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "(define/contract (min-operations nums k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  (let loop ((nums nums) ; Use the original list, but we'll access it in reverse\n             (required (set)) ; Set to keep track of numbers 1 through k\n             (ops 0)) ; Counter for operations\n    ;; Initialize the set with numbers 1 through k\n    (let ((init-required (for/fold ([res required]) ([i (in-range 1 (add1 k))])\n                           (set-add res i))))\n      ;; Reverse iterate through nums to simulate operations\n      (let iter ((remaining (reverse nums)) ; Reverse nums for processing\n                 (collected init-required) ; Track collected numbers\n                 (count ops))\n        (if (set-empty? collected) ; Check if we've collected all required numbers\n            count ; All required numbers collected, return count\n            (let ((current (car remaining)))\n              (if (set-member? collected current) ; Check if current number is required\n                  (iter (cdr remaining) (set-remove collected current) (add1 count))\n                  (iter (cdr remaining) collected (add1 count)))))))))"
}