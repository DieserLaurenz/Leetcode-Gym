{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 22016000,
    "question_id": "3044",
    "elapsed_time": 28,
    "compare_result": "0000100000101100000010000100000000000100000000000000010100100100110101100111001010000000010000000000001000000000010011100000000000010000010000000101110000000001000000100000010100100100000000000000000000000000000010000000000000001000000000000000000000010000000000000000001001100000000000000000000000000100000000000000000000001000000000010000000000000101100000000000000000000001000000000000000001000000000000100000000000010000000000000000000000000001000000010000000000000000000000000000000000000000000000000000000010000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "0",
    "std_output": "",
    "last_testcase": "[3,1,5,4,2]\n2",
    "expected_output": "4",
    "task_finish_time": 1706544679323,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 59,
    "total_testcases": 619,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1160205542",
    "input_formatted": "[3,1,5,4,2], 2",
    "input": "[3,1,5,4,2]\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <unordered_set>\n\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums, int k) {\n        int n = nums.size();\n        // Use a set to track unique elements from 1 to k\n        unordered_set<int> needed;\n        for (int i = 1; i <= k; ++i) {\n            needed.insert(i);\n        }\n\n        // Sliding window [left, right] to find the shortest subarray containing 1 to k\n        int left = 0, minOps = n + 1;\n        for (int right = 0; right < n; ++right) {\n            // If the current element is needed, remove it from the set\n            if (needed.find(nums[right]) != needed.end()) {\n                needed.erase(nums[right]);\n            }\n\n            // If we have found all elements from 1 to k, try to shrink the window\n            while (needed.empty() && left <= right) {\n                minOps = min(minOps, n - (right - left + 1)); // Update minimum operations\n                // If the leftmost element is needed (which we previously removed), add it back\n                if (nums[left] <= k && needed.find(nums[left]) == needed.end()) {\n                    needed.insert(nums[left]);\n                }\n                left++;\n            }\n        }\n\n        // If minOps was not updated, it means we need to remove all elements\n        return minOps == n + 1 ? n : minOps;\n    }\n};"
}