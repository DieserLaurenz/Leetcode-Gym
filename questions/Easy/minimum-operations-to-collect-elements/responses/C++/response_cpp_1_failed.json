{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 22788000,
    "question_id": "3044",
    "elapsed_time": 24,
    "compare_result": "0000100100101000000000000001010000000010010000001000110100100100110101100010000001000000000000000000000000000000001000010000000000000000000000000010001000000000000000000000001000000110100100001001001000001010001000010000001000000000100000000010000000000010000000100000000100001010010010000100110100011000010000000001000000000010000100000100000100000010001101000100100011010110001000000010000000010000010000001000100000000000000000000000100000000000000000000000000100000000000000000000000000100000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000010000010000000000000000000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "[3,1,5,4,2]\n2",
    "expected_output": "4",
    "task_finish_time": 1706544726247,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 82,
    "total_testcases": 619,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1160206260",
    "input_formatted": "[3,1,5,4,2], 2",
    "input": "[3,1,5,4,2]\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums, int k) {\n        // Frequency map to keep track of the elements from 1 to k\n        unordered_map<int, int> freq;\n        for (int i = 1; i <= k; ++i) {\n            freq[i] = 0;\n        }\n\n        int count = 0; // To track how many unique numbers from 1 to k we have seen\n        int left = 0, minLen = INT_MAX;\n        for (int right = 0; right < nums.size(); ++right) {\n            if (nums[right] <= k) {\n                if (freq[nums[right]] == 0) count++; // Found a new number from 1 to k\n                freq[nums[right]]++;\n            }\n\n            // Once we have all numbers from 1 to k, try to shrink the window from the left\n            while (count == k && left <= right) {\n                minLen = min(minLen, right - left + 1);\n                if (nums[left] <= k) {\n                    freq[nums[left]]--;\n                    if (freq[nums[left]] == 0) count--; // Lost a unique number from 1 to k\n                }\n                left++;\n            }\n        }\n\n        return minLen == INT_MAX ? nums.size() : nums.size() - minLen;\n    }\n};"
}