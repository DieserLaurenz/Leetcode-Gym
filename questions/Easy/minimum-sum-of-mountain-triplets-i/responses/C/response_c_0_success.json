{
    "status_code": 10,
    "lang": "c",
    "run_success": true,
    "status_runtime": "5 ms",
    "memory": 5460000,
    "question_id": "3176",
    "elapsed_time": 13,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706565148239,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 724,
    "total_testcases": 724,
    "runtime_percentile": 42.85719999999999,
    "status_memory": "5.5 MB",
    "memory_percentile": 100,
    "pretty_lang": "C",
    "submission_id": "1160476011",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "int minimumSum(int* nums, int numsSize) {\n    int minSum = __INT_MAX__; // Step 1: Initialize minSum with the maximum possible integer value.\n    \n    // Step 2: Iterate through each element to consider it as the 'peak' of the mountain.\n    for (int j = 1; j < numsSize - 1; j++) {\n        int leftMin = __INT_MAX__;\n        int rightMin = __INT_MAX__;\n        \n        // Find the minimum value to the left of 'j' that is less than nums[j].\n        for (int i = 0; i < j; i++) {\n            if (nums[i] < nums[j]) {\n                leftMin = nums[i] < leftMin ? nums[i] : leftMin;\n            }\n        }\n        \n        // Find the minimum value to the right of 'j' that is less than nums[j].\n        for (int k = j + 1; k < numsSize; k++) {\n            if (nums[k] < nums[j]) {\n                rightMin = nums[k] < rightMin ? nums[k] : rightMin;\n            }\n        }\n        \n        // Step 3: If both leftMin and rightMin are found, update minSum if a lower sum is found.\n        if (leftMin != __INT_MAX__ && rightMin != __INT_MAX__) {\n            int currentSum = leftMin + nums[j] + rightMin;\n            minSum = currentSum < minSum ? currentSum : minSum;\n        }\n    }\n    \n    // Step 4: Check if minSum was updated, return it or -1 if not.\n    return minSum == __INT_MAX__ ? -1 : minSum;\n}"
}