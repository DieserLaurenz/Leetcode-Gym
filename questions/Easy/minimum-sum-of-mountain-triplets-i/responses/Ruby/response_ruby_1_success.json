{
    "status_code": 10,
    "lang": "ruby",
    "run_success": true,
    "status_runtime": "66 ms",
    "memory": 212244000,
    "question_id": "3176",
    "elapsed_time": 237,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706596779761,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 724,
    "total_testcases": 724,
    "runtime_percentile": 66.66669999999999,
    "status_memory": "212.2 MB",
    "memory_percentile": 33.33339999999999,
    "pretty_lang": "Ruby",
    "submission_id": "1160782220",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef minimum_sum(nums)\n    min_sum = Float::INFINITY\n    n = nums.length\n\n    # Precompute the minimum value to the left of each element that is less than it\n    left_min = Array.new(n, Float::INFINITY)\n    (1...n).each do |i|\n        left_min[i] = [left_min[i-1], nums[i-1]].min\n    end\n\n    # Precompute the minimum value to the right of each element that is less than it\n    right_min = Array.new(n, Float::INFINITY)\n    (n-2).downto(0) do |i|\n        right_min[i] = [right_min[i+1], nums[i+1]].min\n    end\n\n    # Iterate through each potential peak of the mountain\n    (1...n-1).each do |j|\n        if nums[j] > left_min[j] && nums[j] > right_min[j]\n            current_sum = nums[j] + left_min[j] + right_min[j]\n            min_sum = [min_sum, current_sum].min\n        end\n    end\n\n    # If no mountain triplet was found, return -1\n    min_sum == Float::INFINITY ? -1 : min_sum\nend"
}