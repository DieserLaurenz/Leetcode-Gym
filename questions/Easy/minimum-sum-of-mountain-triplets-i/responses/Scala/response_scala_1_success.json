{
    "status_code": 10,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "566 ms",
    "memory": 55540000,
    "question_id": "3176",
    "elapsed_time": 958,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706596871763,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 724,
    "total_testcases": 724,
    "runtime_percentile": 100,
    "status_memory": "55.5 MB",
    "memory_percentile": 100,
    "pretty_lang": "Scala",
    "submission_id": "1160783388",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "object Solution {\n    def minimumSum(nums: Array[Int]): Int = {\n        var minSum = Int.MaxValue // Use MaxValue as the initial placeholder for the minimum sum\n\n        for (j <- 1 until nums.length - 1) {\n            var leftMin = Int.MaxValue\n            var rightMin = Int.MaxValue\n\n            // Look for the smallest value on the left side of j that is less than nums[j]\n            for (i <- 0 until j) {\n                if (nums(i) < nums(j)) leftMin = Math.min(leftMin, nums(i))\n            }\n\n            // Look for the smallest value on the right side of j that is less than nums[j]\n            for (k <- j + 1 until nums.length) {\n                if (nums(k) < nums(j)) rightMin = Math.min(rightMin, nums(k))\n            }\n\n            // If both leftMin and rightMin were updated (meaning a mountain was found)\n            // Update minSum if the sum of this mountain is less than the current minSum\n            if (leftMin != Int.MaxValue && rightMin != Int.MaxValue) {\n                minSum = Math.min(minSum, leftMin + nums(j) + rightMin)\n            }\n        }\n\n        // Return the minimum sum found, or -1 if no mountain exists\n        if (minSum == Int.MaxValue) -1 else minSum\n    }\n}"
}