{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 2056000,
    "question_id": "3176",
    "elapsed_time": 85,
    "compare_result": "1011111111111111111111111111111111111111111111111111111110111011111111111111100111111111111111111111111111111111111111111111111111111011111110011111101111111111111111111111111111111111111111111111111111111111111110111001111111111111111111111111111111111111111111111111111111111111111111111111011110000111001111011111011110000111001111011111011111011110100110110111011111011111110110100111011111011111110111111111100101111010111011101011101011110101101000111101011011100111100101011110101010111011110111001001101101101011011100100111111100010110011011010000010000011100000010000000000010000110000001000001000010010000000011011010001001100010000000011000000001000000000000000000110000100000000000100001000100011001000111111111",
    "code_output": "14",
    "std_output": "",
    "last_testcase": "[5,4,8,7,10,2]",
    "expected_output": "13",
    "task_finish_time": 1706596911912,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 498,
    "total_testcases": 724,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1160783934",
    "input_formatted": "[5,4,8,7,10,2]",
    "input": "[5,4,8,7,10,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn minimum_sum(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut min_left = vec![0; n];\n        let mut min_sum = i32::MAX;\n        \n        // Pre-compute minimum values to the left of each index\n        min_left[0] = i32::MAX; // No valid mountain to the left of the first element\n        for i in 1..n {\n            min_left[i] = min_left[i - 1].min(nums[i - 1]);\n        }\n        \n        // Pre-compute minimum values to the right of each index\n        let mut min_right = i32::MAX;\n        \n        // Iterate through each element as the peak of the mountain\n        for i in (1..n - 1).rev() {\n            if nums[i] > min_left[i] && nums[i] > nums[i + 1] {\n                // Check if current element can be a peak\n                min_right = min_right.min(nums[i + 1]);\n                let sum = nums[i] + min_left[i] + min_right;\n                min_sum = min_sum.min(sum);\n            }\n        }\n        \n        if min_sum == i32::MAX {\n            -1 // No valid mountain triplet found\n        } else {\n            min_sum\n        }\n    }\n}"
}