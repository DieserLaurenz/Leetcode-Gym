{
    "status_code": 11,
    "lang": "erlang",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 59852000,
    "question_id": "3045",
    "elapsed_time": 1661,
    "compare_result": "011000000100101010110000010000011100100000111001000110111000001100100100100000001100011101110000010010000011101000110000000001000000000101000010011011101010110011110000001011011010010000000010101100011100010000000100000101001101011001000101101000001111011011001100111001100000100100001010101000100010000010100110000101010001100010000001000110101000001000101100100001101101111000010000000101000001000100000101100000110010111110001010001001010011011101101001110010000001001000010111000010000101100110000110001100000100000001100000011000010010101111101000000001110001000000011100010000000000000000010100000100010011000000001100000010000100000010000000000000000001000000100000000000100000000000100000101000110000000000000010000010000000001000001110001000101000100000000000001000011000001010010010000000101100000000111",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "[3,4,5,1,2]",
    "expected_output": "2",
    "task_finish_time": 1706563805148,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 252,
    "total_testcases": 813,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Erlang",
    "submission_id": "1160464377",
    "input_formatted": "[3,4,5,1,2]",
    "input": "[3,4,5,1,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "-spec minimum_right_shifts(Nums :: [integer()]) -> integer().\nminimum_right_shifts(Nums) ->\n    Sorted = lists:sort(Nums),\n    case Nums == Sorted of\n        true -> 0;\n        false -> calculate_shifts(Nums, Sorted, 0, false, length(Nums), -1)\n    end.\n\ncalculate_shifts(_, _, N, _, Len, _) when N == Len -> \n    -1; % Circled through all elements without finding a starting point\ncalculate_shifts(Original, Sorted, N, FoundBreak, Len, StartIndex) ->\n    {OFirst, OLast} = {lists:nth(1, Original), lists:last(Original)},\n    {SFirst, _} = {lists:nth(1, Sorted), lists:last(Sorted)},\n    case {OFirst == SFirst, FoundBreak} of\n        {true, false} -> \n            calculate_shifts(lists:droplast(Original) ++ [OFirst], Sorted, N + 1, FoundBreak, Len, if StartIndex < 0 -> N; true -> StartIndex end);\n        {false, false} ->\n            if OLast < OFirst ->\n                calculate_shifts(lists:droplast(Original) ++ [OFirst], Sorted, N + 1, true, Len, N);\n            true ->\n                -1 % Found an element out of order that cannot be fixed by shifting\n            end;\n        {_, true} -> \n            -1 % Already found a break, cannot sort\n    end."
}