{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 25624000,
    "question_id": "3045",
    "elapsed_time": 23,
    "compare_result": "010000000100101010110000010000011100100000111001000110111000001100100100100000001100011101110000010010000011101000110000000001000000000101000010011011101010110011110000001011011010010000000010101100011100010000000100000101001101011001000101101000001111011011001100111001100000100100001010101000100010000010100110000101010001100010000001000110101000001000101100100001101101111000010000000101000001000100000101100000110010111110001010001001010011011101101001110010000001001000010111000010000101100110000110001100000100000001100000011000010010101111101000000001110001000000011100010000000000000000010100000100010011000000001100000010000100000010000000000000000001000000100000000000100000000000100000101000110000000000000010000010000000001000001110001000101000100000000000001000011000001010010010000000101100000000011",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "[3,4,5,1,2]",
    "expected_output": "2",
    "task_finish_time": 1706554547169,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 250,
    "total_testcases": 813,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1160363743",
    "input_formatted": "[3,4,5,1,2]",
    "input": "[3,4,5,1,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumRightShifts(vector<int>& nums) {\n        int n = nums.size();\n        // Variable to track if there's been a decrease in the array sequence.\n        bool foundDecrease = false;\n        // Variable to store the index of the minimum element.\n        int minIndex = 0;\n        for (int i = 0; i < n; i++) {\n            // Find the index of the minimum element.\n            if (nums[i] < nums[minIndex]) {\n                minIndex = i;\n            }\n            // Check if there is a decrease in the sequence.\n            if (i > 0 && nums[i] < nums[i - 1]) {\n                if (foundDecrease) {\n                    // If we've already found a decrease before, it means sorting is not possible.\n                    return -1;\n                }\n                foundDecrease = true;\n            }\n        }\n        \n        // If there's no decrease in the sequence, it's already sorted.\n        if (!foundDecrease) return 0;\n        \n        // If the minimum element is right after the decrease, sorting is possible.\n        // The number of shifts needed is the distance from the start of the array to the minimum element.\n        if (minIndex == 0 || nums[minIndex - 1] <= nums[n - 1]) {\n            return n - minIndex;\n        }\n        \n        // If conditions for a valid shift sort are not met, return -1.\n        return -1;\n    }\n};"
}