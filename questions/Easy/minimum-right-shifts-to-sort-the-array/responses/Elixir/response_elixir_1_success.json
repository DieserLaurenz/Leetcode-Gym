{
    "status_code": 10,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "329 ms",
    "memory": 72692000,
    "question_id": "3045",
    "elapsed_time": 390,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706564030399,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 813,
    "total_testcases": 813,
    "runtime_percentile": 100,
    "status_memory": "72.7 MB",
    "memory_percentile": 100,
    "pretty_lang": "Elixir",
    "submission_id": "1160466416",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec minimum_right_shifts(nums :: [integer]) :: integer\n  def minimum_right_shifts(nums) do\n    nums_length = length(nums)\n    # Check if the array is already sorted\n    if nums == Enum.sort(nums) do\n      0\n    else\n      # Find the index where the array should be rotated to be sorted\n      indices_where_descending = for {num, next_num} <- Enum.zip(nums, Enum.concat(tl(nums), [hd(nums)])),\n                                     num > next_num,\n                                     into: [],\n                                    do: next_num\n\n      # It's possible to sort the array with right shifts only if there is exactly one descending point\n      if length(indices_where_descending) == 1 do\n        # Find the index of the element that starts the sorted sequence after rotation\n        rotation_start_index = Enum.find_index(nums, &(&1 == hd(indices_where_descending)))\n        # The number of shifts needed is the distance of this index from the start of the array\n        nums_length - rotation_start_index\n      else\n        -1\n      end\n    end\n  end\nend"
}