{
    "status_code": 10,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "0 ms",
    "memory": 2168000,
    "question_id": "3045",
    "elapsed_time": 13,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706563470990,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 813,
    "total_testcases": 813,
    "runtime_percentile": 100,
    "status_memory": "2.2 MB",
    "memory_percentile": 14.285699999999991,
    "pretty_lang": "Rust",
    "submission_id": "1160461470",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn minimum_right_shifts(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut descents = 0; // Counts the number of descents\n        let mut last_descent_index = 0; // Keeps track of the last descent index\n\n        // Find descents\n        for i in 0..n {\n            if nums[i] > nums[(i + 1) % n] {\n                descents += 1;\n                last_descent_index = i + 1;\n            }\n        }\n\n        // More than one descent means it's impossible to sort with right shifts\n        if descents > 1 {\n            return -1;\n        }\n\n        // No descents mean the array is already sorted\n        if descents == 0 {\n            return 0;\n        }\n\n        // For exactly one descent, the number of shifts is the distance to bring\n        // the smallest element (immediately after the last descent) to the start of the array.\n        (n - last_descent_index) as i32 % n as i32\n    }\n}"
}