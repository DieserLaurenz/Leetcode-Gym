{
    "status_code": 10,
    "lang": "typescript",
    "run_success": true,
    "status_runtime": "70 ms",
    "memory": 51896000,
    "question_id": "3045",
    "elapsed_time": 100,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706555092068,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 813,
    "total_testcases": 813,
    "runtime_percentile": 55.0,
    "status_memory": "51.9 MB",
    "memory_percentile": 10.0,
    "pretty_lang": "TypeScript",
    "submission_id": "1160370991",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "function minimumRightShifts(nums: number[]): number {\n  // Find the index of the smallest element.\n  const minIndex = nums.indexOf(Math.min(...nums));\n\n  // Check if the array is already sorted or can be sorted with right shifts.\n  // Count the number of discontinuities in the sort order.\n  let discontinuities = 0;\n  for (let i = 0; i < nums.length; i++) {\n    // Compare current element with the next one, considering the circular nature.\n    if (nums[i] > nums[(i + 1) % nums.length]) {\n      discontinuities += 1;\n    }\n  }\n\n  // If there's more than one discontinuity, sorting is impossible.\n  if (discontinuities > 1) {\n    return -1;\n  }\n\n  // The minimum number of right shifts required is determined by the position\n  // of the smallest element in the array.\n  // This is equivalent to moving the start of the sorted array to its correct position.\n  return (nums.length - minIndex) % nums.length;\n}"
}