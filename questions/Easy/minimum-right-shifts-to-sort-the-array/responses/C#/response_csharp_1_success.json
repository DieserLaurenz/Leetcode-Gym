{
    "status_code": 10,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "75 ms",
    "memory": 42892000,
    "question_id": "3045",
    "elapsed_time": 136,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706554872087,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 813,
    "total_testcases": 813,
    "runtime_percentile": 76.0,
    "status_memory": "42.9 MB",
    "memory_percentile": 44.0,
    "pretty_lang": "C#",
    "submission_id": "1160368213",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public int MinimumRightShifts(IList<int> nums) {\n        int n = nums.Count;\n        int shifts = 0;\n        bool foundDecrease = false;\n\n        // Find the number of times the array \"decreases\" or wraps.\n        // Since nums contains distinct positive integers, we can track where the sequence breaks.\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > nums[(i + 1) % n]) {\n                if (foundDecrease) {\n                    // If we find more than one decrease, it's impossible to sort the array with right shifts.\n                    return -1;\n                }\n                foundDecrease = true;\n                // The number of shifts needed is determined by the position of the break + 1\n                // This effectively moves the smallest element (immediately after the break) to the start of the array.\n                shifts = n - (i + 1);\n            }\n        }\n\n        // If the array does not decrease (is already sorted) or only decreases once, return the calculated shifts.\n        return shifts;\n    }\n}"
}