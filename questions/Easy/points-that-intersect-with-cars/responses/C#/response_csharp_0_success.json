{
    "status_code": 10,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "92 ms",
    "memory": 46032000,
    "question_id": "3034",
    "elapsed_time": 183,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706617678456,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 807,
    "total_testcases": 807,
    "runtime_percentile": 61.5384,
    "status_memory": "46 MB",
    "memory_percentile": 36.537899999999986,
    "pretty_lang": "C#",
    "submission_id": "1161005675",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Solution {\n    public int NumberOfPoints(IList<IList<int>> nums) {\n        // Sort the list based on the start of each range\n        var sortedNums = nums.OrderBy(car => car[0]).ToList();\n        var merged = new List<IList<int>>();\n        \n        // Merge overlapping or adjacent ranges\n        foreach (var car in sortedNums) {\n            if (merged.Count == 0 || merged.Last()[1] < car[0] - 1) {\n                // If there's no overlap, add the car range as a new range\n                merged.Add(car);\n            } else {\n                // If there's an overlap, merge the current range with the last added range\n                merged.Last()[1] = Math.Max(merged.Last()[1], car[1]);\n            }\n        }\n        \n        // Count the total number of points covered by all cars\n        int count = 0;\n        foreach (var range in merged) {\n            count += range[1] - range[0] + 1;\n        }\n        \n        return count;\n    }\n}"
}