{
    "status_code": 10,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "3 ms",
    "memory": 2108000,
    "question_id": "3034",
    "elapsed_time": 12,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706627412948,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 807,
    "total_testcases": 807,
    "runtime_percentile": 71.4285,
    "status_memory": "2.1 MB",
    "memory_percentile": 57.1428,
    "pretty_lang": "Rust",
    "submission_id": "1161128287",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn number_of_points(nums: Vec<Vec<i32>>) -> i32 {\n        let mut cars = nums;\n        cars.sort_by(|a, b| a[0].cmp(&b[0])); // Sort by starting point\n\n        let mut merged: Vec<Vec<i32>> = Vec::new(); // Specify type annotation\n        \n        for car in cars {\n            if merged.is_empty() || car[0] > merged.last().unwrap()[1] {\n                // No overlap, add the car as a new interval\n                merged.push(car);\n            } else {\n                // Overlap, merge the current car with the last one in `merged`\n                let last = merged.last_mut().unwrap();\n                last[1] = last[1].max(car[1]);\n            }\n        }\n        \n        // Count the points covered by the merged intervals\n        merged.into_iter().fold(0, |acc, interval| acc + interval[1] - interval[0] + 1)\n    }\n}"
}