{
    "status_code": 10,
    "lang": "golang",
    "run_success": true,
    "status_runtime": "6 ms",
    "memory": 3696000,
    "question_id": "3034",
    "elapsed_time": 18,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706627224216,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 807,
    "total_testcases": 807,
    "runtime_percentile": 74.6477,
    "status_memory": "3.7 MB",
    "memory_percentile": 73.23939999999999,
    "pretty_lang": "Go",
    "submission_id": "1161125666",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "func numberOfPoints(nums [][]int) int {\n    // Sort the intervals based on the starting point.\n    sort.Slice(nums, func(i, j int) bool {\n        return nums[i][0] < nums[j][0]\n    })\n\n    merged := [][]int{}\n    for _, interval := range nums {\n        // If the merged list is empty or if the current interval does not overlap with the previous one,\n        // append it to the merged list.\n        if len(merged) == 0 || merged[len(merged)-1][1] < interval[0] {\n            merged = append(merged, interval)\n        } else {\n            // Else, there is an overlap, so we merge the current interval with the previous one.\n            merged[len(merged)-1][1] = max(merged[len(merged)-1][1], interval[1])\n        }\n    }\n\n    // Count the number of points covered by the merged intervals.\n    count := 0\n    for _, interval := range merged {\n        count += interval[1] - interval[0] + 1\n    }\n\n    return count\n}\n\n// Helper function to find the maximum of two integers.\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}"
}