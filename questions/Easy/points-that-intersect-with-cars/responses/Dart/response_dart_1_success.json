{
    "status_code": 10,
    "lang": "dart",
    "run_success": true,
    "status_runtime": "414 ms",
    "memory": 155840000,
    "question_id": "3034",
    "elapsed_time": 531,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706627087022,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 807,
    "total_testcases": 807,
    "runtime_percentile": 42.85719999999999,
    "status_memory": "155.8 MB",
    "memory_percentile": 14.28579999999999,
    "pretty_lang": "Dart",
    "submission_id": "1161123778",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "class Solution {\n  int numberOfPoints(List<List<int>> nums) {\n    // Sort the intervals based on their start points.\n    nums.sort((a, b) => a[0].compareTo(b[0]));\n    \n    List<List<int>> merged = [];\n    for (List<int> interval in nums) {\n      // If the list of merged intervals is empty or if the current interval does not overlap with the last one added,\n      // append it to the list of merged intervals.\n      if (merged.isEmpty || merged.last[1] < interval[0]) {\n        merged.add(interval);\n      } else {\n        // If there is an overlap, merge the current interval with the last one added by updating the end point.\n        // Use a simple comparison to find the maximum without Math.max.\n        merged.last[1] = merged.last[1] > interval[1] ? merged.last[1] : interval[1];\n      }\n    }\n    \n    int count = 0;\n    // Count the number of integer points covered by each interval in the merged list.\n    for (List<int> interval in merged) {\n      count += interval[1] - interval[0] + 1; // +1 because both endpoints are included.\n    }\n    \n    return count;\n  }\n}"
}