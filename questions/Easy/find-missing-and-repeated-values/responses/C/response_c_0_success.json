{
    "status_code": 10,
    "lang": "c",
    "run_success": true,
    "status_runtime": "20 ms",
    "memory": 7044000,
    "question_id": "3227",
    "elapsed_time": 33,
    "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706266526584,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 584,
    "total_testcases": 584,
    "runtime_percentile": 56.47070000000002,
    "status_memory": "7 MB",
    "memory_percentile": 96.47059999999999,
    "pretty_lang": "C",
    "submission_id": "1157313956",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <stdlib.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findMissingAndRepeatedValues(int** grid, int gridSize, int* gridColSize, int* returnSize) {\n    // gridSize is n, and the range of numbers is 1 to n*n\n    int range = gridSize * gridSize;\n    int* counts = (int*)calloc(range + 1, sizeof(int)); // +1 because we're using 1-based indexing\n    int* result = (int*)malloc(2 * sizeof(int));\n    *returnSize = 2; // The result will always have 2 elements\n\n    // Count the occurrences of each number in the grid\n    for (int i = 0; i < gridSize; ++i) {\n        for (int j = 0; j < gridColSize[i]; ++j) {\n            counts[grid[i][j]]++;\n        }\n    }\n\n    // Find the repeated and missing numbers\n    for (int i = 1; i <= range; ++i) {\n        if (counts[i] == 2) {\n            result[0] = i; // Repeated number\n        } else if (counts[i] == 0) {\n            result[1] = i; // Missing number\n        }\n    }\n\n    // Clean up and return the result\n    free(counts);\n    return result;\n}"
}