{
    "acRate": 85.17776285287172,
    "difficulty": "Easy",
    "freqBar": null,
    "frontendQuestionId": "2629",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Function Composition",
    "titleSlug": "function-composition",
    "topicTags": [],
    "hasSolution": true,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * @param {Function[]} functions  * @return {Function}  */ var compose = function(functions) {          return function(x) {              } };  /**  * const fn = compose([x => x + 1, x => 2 * x])  * fn(4) // 9  */"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "type F = (x: number) => number;  function compose(functions: F[]): F {          return function(x) {              } };  /**  * const fn = compose([x => x + 1, x => 2 * x])  * fn(4) // 9  */"
        }
    ],
    "content": "Given an array of functions[f1, f2, f3,..., fn], returna new functionfnthat is the functioncomposition of the array of functions. Thefunctioncompositionof[f(x), g(x), h(x)]isfn(x) = f(g(h(x))). Thefunctioncompositionof an empty list of functions is theidentity functionf(x) = x. You may assume eachfunctionin the array accepts one integer as inputand returns one integer as output.  Example 1:  Input: functions = [x => x + 1, x => x * x, x => 2 * x], x = 4 Output: 65 Explanation: Evaluating from right to left ... Starting with x = 4. 2 * (4) = 8 (8) * (8) = 64 (64) + 1 = 65  Example 2:  Input: functions = [x => 10 * x, x => 10 * x, x => 10 * x], x = 1 Output: 1000 Explanation: Evaluating from right to left ... 10 * (1) = 10 10 * (10) = 100 10 * (100) = 1000  Example 3:  Input: functions = [], x = 42 Output: 42 Explanation: The composition of zero functions is the identity function  Constraints:  -1000 <= x <= 1000 0 <= functions.length <= 1000 all functions accept and return a single integer  "
}