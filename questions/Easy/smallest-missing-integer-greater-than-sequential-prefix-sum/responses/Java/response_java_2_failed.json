{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 41708000,
    "display_runtime": "2",
    "question_id": "3236",
    "elapsed_time": 148,
    "compare_result": "0000001100000001100001000000010011000000000000000000010000000100000100000000001000000001001100000001000000000000001100000110001100000100100110000001000000000001100000001010000000000000000000001100000100000000000000100010000001100000000100000000001000010000000100000100100000010000000010010101000000000001010000000010110000010000000010000000000100000000000001100100110010010101010000000000000010000010000000010000000000000000000000000000000100001000110010010100000010000000000000000000000010001000000001000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "7",
    "std_output": "",
    "last_testcase": "[1,2,3,2,5]",
    "expected_output": "6",
    "task_finish_time": 1706657878097,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 82,
    "total_testcases": 616,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1161503273",
    "input_formatted": "[1,2,3,2,5]",
    "input": "[1,2,3,2,5]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    public int missingInteger(int[] nums) {\n        // Sort the nums array to easily find sequential numbers.\n        java.util.Arrays.sort(nums);\n\n        // Variables to track the longest sequential prefix.\n        int currentSum = 0, maxSum = 0;\n        // Track the previous number to identify sequential numbers.\n        int prevNum = -1;\n\n        for (int num : nums) {\n            // Check if the current number continues from the previous to form a sequence.\n            if (num == prevNum + 1) {\n                // Add to the current sum if it's a continuation of the sequence.\n                currentSum += num;\n            } else if (num != prevNum) {\n                // If it's not a continuation or a duplicate, reset the current sum.\n                // Only reset if the number is not a duplicate to handle multiple same numbers in sequence.\n                currentSum = num;\n            }\n            // Update the maxSum if the current sequence sum is larger.\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n            }\n            prevNum = num;\n        }\n\n        // The smallest missing integer greater than or equal to the sum of the longest sequential prefix.\n        // Start checking from maxSum + 1, because the problem asks for greater than or equal to sum.\n        int target = maxSum + 1;\n        while (java.util.Arrays.binarySearch(nums, target) >= 0) {\n            target++;\n        }\n\n        return target;\n    }\n}"
}