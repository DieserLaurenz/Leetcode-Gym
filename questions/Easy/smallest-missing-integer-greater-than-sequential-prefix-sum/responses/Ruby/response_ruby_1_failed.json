{
    "status_code": 11,
    "lang": "ruby",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 211564000,
    "question_id": "3236",
    "elapsed_time": 189,
    "compare_result": "0000001100000000000000000000010011000000000000000000010000000100000100000000001000000000000100000001000000000000000100000110001100000100000110000000000000000001100000000010000000000000000000000000000000000000000000100010000001100000000100000000000000010000000000000000000000000000000010010101000000000001010000000010110000000000000010000000000100000000000001100100110010010101000000000000000010000010000000010000000000000000000000000000000100001000100000010000000010000000000000000000000010001000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "7",
    "std_output": "",
    "last_testcase": "[1,2,3,2,5]",
    "expected_output": "6",
    "task_finish_time": 1706658875550,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 59,
    "total_testcases": 616,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Ruby",
    "submission_id": "1161510657",
    "input_formatted": "[1,2,3,2,5]",
    "input": "[1,2,3,2,5]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef missing_integer(nums)\n  nums.sort!\n  max_length = 0\n  current_sum = 0\n  longest_sum = 0\n\n  # Start from each element in nums as a potential beginning of a sequential prefix\n  nums.each_with_index do |num, index|\n    # Reset current sequence length and sum for each starting point\n    length = 1\n    sum = num\n    last_num = num\n\n    # Look ahead to see if a sequential chain can be formed\n    (index+1...nums.length).each do |j|\n      if nums[j] == last_num + 1\n        length += 1\n        sum += nums[j]\n        last_num = nums[j]\n      elsif nums[j] > last_num + 1\n        break # End of potential sequential chain\n      end\n    end\n\n    # Update longest sequence details if current is longer\n    if length > max_length\n      max_length = length\n      longest_sum = sum\n    elsif length == max_length\n      # In case of equal lengths, choose the one with the larger sum\n      longest_sum = [longest_sum, sum].max\n    end\n  end\n\n  # Starting from the sum of the longest sequential prefix, find the missing integer\n  missing = longest_sum + 1\n  missing += 1 while nums.include?(missing)\n  missing\nend"
}