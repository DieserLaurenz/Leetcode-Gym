{
    "status_code": 15,
    "lang": "erlang",
    "run_success": false,
    "runtime_error": "Line 4: exception error: {badmatch,6}",
    "full_runtime_error": "Line 4: exception error: {badmatch,6}\n[{solution,missing_integer,1,[{file,\"solution.erl\"},{line,4}]},\n {solution,driver,0,[{file,\"solution.erl\"},{line,30}]},\n {solution,start,0,[{file,\"solution.erl\"},{line,59}]},\n {init,start_em,1,[]},\n {init,do_boot,3,[]}]",
    "status_runtime": "N/A",
    "memory": 59360000,
    "question_id": "3236",
    "elapsed_time": 1305,
    "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[1,2,3,2,5]",
    "expected_output": "6",
    "task_finish_time": 1706668339632,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 616,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Erlang",
    "submission_id": "1161588531",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "-spec missing_integer(Nums :: [integer()]) -> integer().\nmissing_integer(Nums) ->\n    SortedUniqueNums = lists:usort(Nums), % Sort and remove duplicates for efficient processing\n    {LongestSeqSum, _} = longest_sequential_prefix(SortedUniqueNums, 0, 0, hd(SortedUniqueNums), 0),\n    find_smallest_missing(SortedUniqueNums, LongestSeqSum + 1).\n\nlongest_sequential_prefix([], LongestSeqSum, CurrentSeqSum, _LastNum, CurrentSeqLen) ->\n    max(LongestSeqSum, CurrentSeqSum + CurrentSeqLen); % Return the max of LongestSeqSum and CurrentSeqSum + CurrentSeqLen\nlongest_sequential_prefix([H|T], LongestSeqSum, CurrentSeqSum, LastNum, CurrentSeqLen) ->\n    if\n        H == LastNum + 1 ->\n            longest_sequential_prefix(T, LongestSeqSum, CurrentSeqSum + LastNum, H, CurrentSeqLen + 1);\n        true ->\n            NewLongestSeqSum = max(LongestSeqSum, CurrentSeqSum + CurrentSeqLen),\n            longest_sequential_prefix(T, NewLongestSeqSum, 0, H, 1)\n    end.\n\nfind_smallest_missing([], X) ->\n    X;\nfind_smallest_missing([H|T], X) ->\n    if\n        X < H ->\n            X;\n        true ->\n            find_smallest_missing(T, X + 1)\n    end."
}