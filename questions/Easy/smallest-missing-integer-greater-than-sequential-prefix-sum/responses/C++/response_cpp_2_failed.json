{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 21476000,
    "question_id": "3236",
    "elapsed_time": 20,
    "compare_result": "0111101111100100011010001011111111001111111011111011110110011111100011101011100101011110010111111101111011111111110111111000001000000111011101110110111011011100010011110110111111110111110101100011011001111111010111001001110010001110011000111111110111011111101011111011011111101111101111011010101111010001000000100000110101000000000010000000001000000000100101111001010000010001000000100000001000000100000000010000000000000000100000000000000001000000000001000001000100000000000001100000000000011000010100000100011000101001001110100111001111011101010110111111001101111101101101111011000111000100000111110100100010000010",
    "code_output": "9",
    "std_output": "",
    "last_testcase": "[1,2,3,2,5]",
    "expected_output": "6",
    "task_finish_time": 1706657743792,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 297,
    "total_testcases": 616,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1161502293",
    "input_formatted": "[1,2,3,2,5]",
    "input": "[1,2,3,2,5]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int missingInteger(vector<int>& nums) {\n        // First, sort the vector to easily find sequences\n        sort(nums.begin(), nums.end());\n        \n        // Variable to keep track of the current sequence's starting number and its length\n        int start = nums[0], maxLength = 1, currentLength = 1;\n        \n        for (int i = 1; i < nums.size(); ++i) {\n            // If the current number continues the sequence from the previous one\n            if (nums[i] == nums[i - 1] + 1) {\n                currentLength++;\n            } else if (nums[i] != nums[i - 1]) {\n                // If the sequence is broken and it's not a duplicate, reset\n                if (currentLength > maxLength) {\n                    maxLength = currentLength;\n                    start = nums[i - currentLength];\n                }\n                currentLength = 1; // Reset for a new sequence\n            }\n            // For duplicates, do nothing and continue\n        }\n        \n        // After the loop, check if the last sequence was the longest\n        if (currentLength > maxLength) {\n            maxLength = currentLength;\n            start = nums[nums.size() - currentLength];\n        }\n        \n        // Calculate the sum of the longest sequential prefix\n        int sum = (start * 2 + maxLength - 1) * maxLength / 2;\n        \n        // The smallest missing integer greater than or equal to the sum of the longest sequential prefix\n        for (int x = sum; ; ++x) {\n            if (find(nums.begin(), nums.end(), x) == nums.end()) {\n                return x;\n            }\n        }\n    }\n};"
}