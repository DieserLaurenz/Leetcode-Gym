{
    "status_code": 11,
    "lang": "kotlin",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 35328000,
    "question_id": "3236",
    "elapsed_time": 126,
    "compare_result": "1000001110000011100001000000111011000000000000000000010000010100000100000000001000100001001100000001000000100000111110000110101101100110100110000101101100100001101000001111100000000000000000101100000100000001001000100010000001100000100100000000001000010000011100010100100000010000000010110101010000000011010000100010110100010010000010000010000100000000000001100100110010010101010000000000000010000010000000010000000000000000000000010000000100001001110010010100000010000000000000000000000010001000000001000000000000000000000000000000000000000000001000000000000000000000000010000000000000000000000000000000000000000001",
    "code_output": "39",
    "std_output": "",
    "last_testcase": "[3,4,5,1,12,14,13]",
    "expected_output": "15",
    "task_finish_time": 1706658551842,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 124,
    "total_testcases": 616,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Kotlin",
    "submission_id": "1161508175",
    "input_formatted": "[3,4,5,1,12,14,13]",
    "input": "[3,4,5,1,12,14,13]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    fun missingInteger(nums: IntArray): Int {\n        // The array can have values up to 50, initialize a Boolean array to track seen numbers.\n        val seen = BooleanArray(51) { false }\n        // Mark the numbers present in the input array.\n        nums.forEach { if (it in 1..50) seen[it] = true }\n\n        var longestSeqSum = 0\n        var currentSeqSum = 0\n        var lastNum = 0\n\n        // The loop is to check each number from 1 to 50, the potential range of nums.\n        for (i in 1..50) {\n            if (seen[i]) {\n                if (lastNum + 1 == i) { // Sequential\n                    currentSeqSum += i\n                } else { // Not sequential, reset\n                    currentSeqSum = i\n                }\n                // Update longest sequential sum if current sequence sum is greater.\n                if (currentSeqSum > longestSeqSum) {\n                    longestSeqSum = currentSeqSum\n                }\n                lastNum = i\n            }\n        }\n\n        // Find the smallest missing integer greater than or equal to the longest sequential prefix sum.\n        for (i in longestSeqSum..50) {\n            if (!seen[i]) {\n                return i\n            }\n        }\n\n        // If all numbers up to 50 are present, the next missing number would be 51.\n        return 51\n    }\n}"
}