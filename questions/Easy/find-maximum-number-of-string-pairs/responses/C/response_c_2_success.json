{
    "status_code": 10,
    "lang": "c",
    "run_success": true,
    "status_runtime": "5 ms",
    "memory": 6812000,
    "question_id": "2847",
    "elapsed_time": 18,
    "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706254608302,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 659,
    "total_testcases": 659,
    "runtime_percentile": 42.5925,
    "status_memory": "6.8 MB",
    "memory_percentile": 87.0369,
    "pretty_lang": "C",
    "submission_id": "1157188765",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define TABLE_SIZE 101\n\ntypedef struct HashNode {\n    char *key;\n    struct HashNode *next;\n} HashNode;\n\nHashNode* hashTable[TABLE_SIZE];\n\nunsigned int hash(char *str) {\n    unsigned int hash = 5381;\n    int c;\n    while ((c = *str++))\n        hash = ((hash << 5) + hash) + c;\n    return hash % TABLE_SIZE;\n}\n\nHashNode* createNode(char *key) {\n    HashNode *node = (HashNode*) malloc(sizeof(HashNode));\n    node->key = strdup(key);  // Copy the string\n    node->next = NULL;\n    return node;\n}\n\nvoid insert(char *key) {\n    unsigned int index = hash(key);\n    HashNode *node = createNode(key);\n    node->next = hashTable[index];\n    hashTable[index] = node;\n}\n\nbool find(char *key) {\n    unsigned int index = hash(key);\n    HashNode *node = hashTable[index];\n    while (node) {\n        if (strcmp(node->key, key) == 0)\n            return true;\n        node = node->next;\n    }\n    return false;\n}\n\nvoid delete(char *key) {\n    unsigned int index = hash(key);\n    HashNode *node = hashTable[index];\n    HashNode *prev = NULL;\n    while (node) {\n        if (strcmp(node->key, key) == 0) {\n            if (prev) prev->next = node->next;\n            else hashTable[index] = node->next;\n            free(node->key);\n            free(node);\n            return;\n        }\n        prev = node;\n        node = node->next;\n    }\n}\n\nchar* reverseStr(char *str) {\n    int n = strlen(str);\n    char *rev = (char*) malloc(sizeof(char) * (n + 1));\n    for (int i = 0; i < n; i++)\n        rev[i] = str[n - 1 - i];\n    rev[n] = '\\0';\n    return rev;\n}\n\nint maximumNumberOfStringPairs(char **words, int wordsSize) {\n    // Initialize hash table\n    for (int i = 0; i < TABLE_SIZE; i++)\n        hashTable[i] = NULL;\n\n    int pairs = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        char *rev = reverseStr(words[i]);\n        if (find(rev)) {\n            pairs++;\n            delete(rev);\n        } else {\n            insert(words[i]);\n        }\n        free(rev);\n    }\n    return pairs;\n}\n\n// This function is just for cleaning up the hash table\nvoid freeHashTable() {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        HashNode *node = hashTable[i];\n        while (node) {\n            HashNode *temp = node;\n            node = node->next;\n            free(temp->key);\n            free(temp);\n        }\n    }\n}"
}