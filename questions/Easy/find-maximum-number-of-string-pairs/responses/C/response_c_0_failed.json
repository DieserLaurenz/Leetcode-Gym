{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 6316000,
    "question_id": "2847",
    "elapsed_time": 24,
    "compare_result": "00001001000000010010101100000100100001001000001110001010000010100010000001111100010100001110000000100001100001000011110100010001000000101010000010010001101000000100101001010000000000100001000001001001000001000110000100010001110000101101110010010101000000001100000000101000000000000001111011100101110100001111000000100000000000010000001000001001010001010100111000101110110001001000100001000101110010010001000100100000000001000100101000100001111000000000010101010000000000000000011000011110110001000100100000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "5",
    "std_output": "",
    "last_testcase": "[\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]",
    "expected_output": "2",
    "task_finish_time": 1706253288778,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 152,
    "total_testcases": 659,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1157172978",
    "input_formatted": "[\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]",
    "input": "[\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define HASH_TABLE_SIZE 101  // A prime number for hash table size\n\ntypedef struct HashTableEntry {\n    char *key;\n    bool exists;\n} HashTableEntry;\n\nunsigned int hash(char *str) {\n    unsigned long hash = 5381;\n    int c;\n    while ((c = *str++)) {\n        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n    }\n    return hash % HASH_TABLE_SIZE;\n}\n\nvoid insertHashTable(HashTableEntry *table, char *key) {\n    unsigned int index = hash(key);\n    while (table[index].exists) {\n        index = (index + 1) % HASH_TABLE_SIZE;\n    }\n    table[index].key = key;\n    table[index].exists = true;\n}\n\nbool findAndRemove(HashTableEntry *table, char *key) {\n    unsigned int index = hash(key);\n    while (table[index].exists) {\n        if (strcmp(table[index].key, key) == 0) {\n            table[index].exists = false;  // Mark as removed\n            return true;\n        }\n        index = (index + 1) % HASH_TABLE_SIZE;\n    }\n    return false;\n}\n\nchar *reverseString(char *s) {\n    int length = strlen(s);\n    char *rev = (char *)malloc(length + 1);\n    for (int i = 0; i < length; i++) {\n        rev[i] = s[length - 1 - i];\n    }\n    rev[length] = '\\0';\n    return rev;\n}\n\nint maximumNumberOfStringPairs(char **words, int wordsSize) {\n    HashTableEntry hashTable[HASH_TABLE_SIZE] = {0};\n    int pairsCount = 0;\n\n    // Insert all strings into the hash table\n    for (int i = 0; i < wordsSize; i++) {\n        insertHashTable(hashTable, words[i]);\n    }\n\n    // Check for each string if its reverse exists in the table\n    for (int i = 0; i < wordsSize; i++) {\n        char *reversed = reverseString(words[i]);\n        if (findAndRemove(hashTable, reversed)) {\n            pairsCount++;\n        }\n        free(reversed);\n    }\n\n    return pairsCount;\n}"
}