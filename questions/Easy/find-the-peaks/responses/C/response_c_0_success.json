{
    "status_code": 10,
    "lang": "c",
    "run_success": true,
    "status_runtime": "4 ms",
    "memory": 6368000,
    "question_id": "3221",
    "elapsed_time": 16,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706332681926,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 648,
    "total_testcases": 648,
    "runtime_percentile": 77.8761,
    "status_memory": "6.4 MB",
    "memory_percentile": 97.93499999999999,
    "pretty_lang": "C",
    "submission_id": "1157966729",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <stdlib.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findPeaks(int* mountain, int mountainSize, int* returnSize) {\n    // Initially, we don't know how many peaks there are, so we cannot allocate the exact size.\n    // Hence, we allocate the maximum possible size, which is mountainSize.\n    int* peaks = (int*)malloc(mountainSize * sizeof(int));\n    int peaksCount = 0;\n\n    // Start from 1 because the first element cannot be a peak.\n    // End at mountainSize - 2 because the last element cannot be a peak.\n    for (int i = 1; i < mountainSize - 1; i++) {\n        // Check if the current element is greater than both its neighbors.\n        if (mountain[i] > mountain[i - 1] && mountain[i] > mountain[i + 1]) {\n            peaks[peaksCount++] = i; // Add the index to the peaks array.\n        }\n    }\n\n    // Resize the array to the exact number of peaks found.\n    // This step is necessary because we initially allocated space for mountainSize elements.\n    peaks = (int*)realloc(peaks, peaksCount * sizeof(int));\n    \n    // Set the returnSize to the number of peaks found.\n    *returnSize = peaksCount;\n\n    return peaks;\n}"
}