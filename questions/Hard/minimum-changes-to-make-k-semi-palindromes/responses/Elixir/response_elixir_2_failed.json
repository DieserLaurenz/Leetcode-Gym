{
    "status_code": 15,
    "lang": "elixir",
    "run_success": false,
    "runtime_error": "Line 6: ** (Protocol.UndefinedError) protocol Enumerable not implemented for \"a\" of type BitString",
    "full_runtime_error": "Line 6: ** (Protocol.UndefinedError) protocol Enumerable not implemented for \"a\" of type BitString\n    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1\n    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3\n    (elixir 1.15.7) lib/enum.ex:4387: Enum.reduce/3\n    solution.ex:6: anonymous fn/4 in Solution.minimum_changes/2\n    solution.ex:22: anonymous fn/9 in Solution.minimum_changes/2\n    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3\n    solution.ex:35: Solution.minimum_changes/2\n    nofile:1: (file)",
    "status_runtime": "N/A",
    "memory": 72364000,
    "question_id": "2879",
    "elapsed_time": 491,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"abcac\"\n2",
    "expected_output": "1",
    "task_finish_time": 1708661344260,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 558,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1183637954",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec minimum_changes(s :: String.t, k :: integer) :: integer\n  def minimum_changes(s, k) do\n    memo = :ets.new(:memo, [:protected, :named_table, read_concurrency: true])\n    changes = fn changes, i, j -> \n      s |> String.slice(i, j - i + 1) |> Enum.reduce(0, fn x, acc -> if x === Enum.at(s, j - acc), do: acc, else: acc + 1 end) |> div(2)\n    end\n    semi_palindrome_changes = fn semi_palindrome_changes, i, j, s ->\n      Enum.reduce(1..div(j - i, 2), 0, fn d, acc ->\n        if rem(j - i + 1, d) == 0 do\n          acc + changes.(s, i, i + d - 1) + semi_palindrome_changes.(i + d, j, s)\n        else\n          acc\n        end\n      end)\n    end\n    dp = fn dp, i, j, s, k ->\n      if k == 1 do\n        semi_palindrome_changes.(0, String.length(s) - 1, s)\n      else\n        Enum.reduce(i..j-1, :infinity, fn idx, acc ->\n          change = changes.(s, i, idx) + (case :ets.lookup(memo, {idx + 1, k - 1}) do\n            [] -> dp.(dp, idx + 1, j, s, k - 1)\n            [{_, val}] -> val\n          end)\n          if change < acc do\n            :ets.insert(memo, {{i, k}, change})\n            change\n          else\n            acc\n          end\n        end)\n      end\n    end\n    result = dp.(dp, 0, String.length(s) - 1, s, k)\n    :ets.delete(memo)\n    result\n  end\nend"
}