{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 45260000,
    "question_id": "2879",
    "elapsed_time": 4010,
    "compare_result": "101110100001111100000110000010000000010000001011011111000100001001100000000000001000000110000000100000101101001001111100110001001011000000001000000100100010000000110000100110000000000000000000000000000110000101111101110110000110001000011100001000001100000000011101100110110101011000000000000001000000100011000110010000001000000010100010000001001101000000110101010000010000101000000010101000000000010000000000000001101001100001001000000100000010000100001010011000100000000010010000010000000000000000010000000000000000000000000000000000000000000000000000000000",
    "code_output": "3",
    "std_output": "",
    "last_testcase": "\"abcdef\"\n2",
    "expected_output": "2",
    "task_finish_time": 1708650173823,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 136,
    "total_testcases": 558,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1183541759",
    "input_formatted": "\"abcdef\", 2",
    "input": "\"abcdef\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    private int[][] memo;\n    private int[][] changes;\n    private String s;\n    private int n;\n\n    public int minimumChanges(String s, int k) {\n        this.s = s;\n        this.n = s.length();\n        this.memo = new int[k + 1][n];\n        this.changes = new int[n][n];\n        for (int i = 0; i <= k; i++) {\n            for (int j = 0; j < n; j++) {\n                memo[i][j] = -1;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                changes[i][j] = calculateChanges(i, j);\n            }\n        }\n\n        return findMinChanges(0, k);\n    }\n\n    private int findMinChanges(int start, int k) {\n        if (start == n) return 0;\n        if (k == 0) return Integer.MAX_VALUE / 2;\n        if (memo[k][start] != -1) return memo[k][start];\n\n        int ans = Integer.MAX_VALUE / 2;\n        for (int end = start; end < n; end++) {\n            int cost = changes[start][end];\n            int next = findMinChanges(end + 1, k - 1);\n            if (next != Integer.MAX_VALUE / 2) {\n                ans = Math.min(ans, cost + next);\n            }\n        }\n\n        memo[k][start] = ans;\n        return ans;\n    }\n\n    private int calculateChanges(int start, int end) {\n        int[][] dp = new int[end - start + 1][end - start + 1];\n        for (int len = 2; len <= end - start + 1; len++) {\n            for (int i = start; i <= end - len + 1; i++) {\n                int j = i + len - 1 - start;\n                dp[i - start][j] = len % 2 == 0 ? dp[i + 1 - start][j - 1] + (s.charAt(i) != s.charAt(i + len - 1) ? 1 : 0) : Integer.MAX_VALUE / 2;\n                for (int d = 2; d < len; d++) {\n                    if (len % d == 0) {\n                        int changes = 0;\n                        for (int k = 0; k < d; k++) {\n                            for (int l = i + k; l + d <= j + start; l += d) {\n                                if (s.charAt(l) != s.charAt(l + d)) {\n                                    changes++;\n                                }\n                            }\n                        }\n                        dp[i - start][j] = Math.min(dp[i - start][j], changes);\n                    }\n                }\n            }\n        }\n        return dp[0][end - start];\n    }\n}"
}