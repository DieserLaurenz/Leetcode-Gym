{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 44748000,
    "display_runtime": "45",
    "question_id": "2879",
    "elapsed_time": 190,
    "compare_result": "111111000100000101000000001010000000000000000100100000000000000100101000000000100001010000000000000000000110000000000100000000000000000000000000000000000000000000000001000100000000000000000000000000000000001000000010000000000000000000001000000000100000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000111110001000000000000000000001000000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "\"abcc\"\n1",
    "expected_output": "2",
    "task_finish_time": 1708650129931,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 38,
    "total_testcases": 558,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1183541471",
    "input_formatted": "\"abcc\", 1",
    "input": "\"abcc\"\n1",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    public int minimumChanges(String s, int k) {\n        final int n = s.length();\n        int[][] dp = new int[k + 1][n + 1];\n        int[][] change = new int[n][n];\n\n        // Precompute the minimum changes needed to make a substring semi-palindrome\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i + len <= n; i++) {\n                int j = i + len - 1;\n                change[i][j] = (s.charAt(i) != s.charAt(j) ? 1 : 0) + change[i + 1][j - 1];\n                // For strings with length > 2, check for all possible d values\n                for (int d = 2; d < len; d++) {\n                    if (len % d == 0) {\n                        int tempChange = 0;\n                        for (int x = i; x + d <= j; x += d) {\n                            tempChange += change[x][x + d - 1];\n                        }\n                        change[i][j] = Math.min(change[i][j], tempChange);\n                    }\n                }\n            }\n        }\n\n        // Initialize DP table\n        for (int i = 0; i <= k; i++) {\n            for (int j = 0; j <= n; j++) {\n                dp[i][j] = Integer.MAX_VALUE / 2; // Use a large number to indicate uncomputed/invalid state\n            }\n        }\n        dp[0][0] = 0;\n\n        // DP to find minimum changes\n        for (int i = 1; i <= k; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int m = 0; m < j; m++) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][m] + change[m][j - 1]);\n                }\n            }\n        }\n\n        return dp[k][n];\n    }\n}"
}