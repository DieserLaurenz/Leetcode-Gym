{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 66428000,
    "display_runtime": "656",
    "question_id": "3181",
    "elapsed_time": 1136,
    "compare_result": "0011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000001000000000000000000000100101000000000000000000000000000000000000000000000000000000100000000100000000010000000000000000000000000000010000000000000000010000000000000000000010000000000000000010000000000000000000100000000000100000000000000001000000000000000000000000001100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "[0,2,-1,3,2]",
    "std_output": "",
    "last_testcase": "[6,4,8,5,2,7]\n[[0,1],[0,3],[2,4],[3,4],[2,2]]",
    "expected_output": "[2,5,-1,5,2]",
    "task_finish_time": 1708474232099,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 20,
    "total_testcases": 949,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1181449991",
    "input_formatted": "[6,4,8,5,2,7], [[0,1],[0,3],[2,4],[3,4],[2,2]]",
    "input": "[6,4,8,5,2,7]\n[[0,1],[0,3],[2,4],[3,4],[2,2]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    public int[] leftmostBuildingQueries(int[] heights, int[][] queries) {\n        int n = heights.length;\n        int[] ans = new int[queries.length];\n        // Create a segment tree to store the maximum height from i to j\n        SegmentTree tree = new SegmentTree(heights);\n\n        for (int i = 0; i < queries.length; i++) {\n            int a = queries[i][0];\n            int b = queries[i][1];\n            int left = a, right = b;\n            boolean found = false;\n\n            // Binary search for the leftmost building where Alice and Bob can meet\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                int leftMax = tree.query(a, mid);\n                int rightMax = tree.query(mid, b);\n\n                if (leftMax <= heights[mid] && rightMax <= heights[mid]) {\n                    ans[i] = mid;\n                    right = mid - 1;\n                    found = true;\n                } else {\n                    left = mid + 1;\n                }\n            }\n\n            if (!found) {\n                ans[i] = -1;\n            }\n        }\n        return ans;\n    }\n\n    class SegmentTree {\n        int[] tree;\n        int n;\n\n        public SegmentTree(int[] heights) {\n            this.n = heights.length;\n            this.tree = new int[n * 4];\n            buildTree(heights, 0, n - 1, 0);\n        }\n\n        private void buildTree(int[] heights, int start, int end, int node) {\n            if (start == end) {\n                tree[node] = heights[start];\n            } else {\n                int mid = start + (end - start) / 2;\n                buildTree(heights, start, mid, 2 * node + 1);\n                buildTree(heights, mid + 1, end, 2 * node + 2);\n                tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n\n        public int query(int start, int end) {\n            return queryRecursive(0, n - 1, start, end, 0);\n        }\n\n        private int queryRecursive(int start, int end, int qstart, int qend, int node) {\n            if (qstart > end || qend < start) {\n                return Integer.MIN_VALUE;\n            }\n            if (qstart <= start && qend >= end) {\n                return tree[node];\n            }\n            int mid = start + (end - start) / 2;\n            return Math.max(queryRecursive(start, mid, qstart, qend, 2 * node + 1),\n                            queryRecursive(mid + 1, end, qstart, qend, 2 * node + 2));\n        }\n    }\n}"
}