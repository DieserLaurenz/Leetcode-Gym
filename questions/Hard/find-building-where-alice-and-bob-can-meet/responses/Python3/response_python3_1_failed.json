{
    "status_code": 11,
    "lang": "python3",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 40276000,
    "question_id": "3181",
    "elapsed_time": 1850,
    "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "[0,0,2,3,-1]",
    "std_output": "",
    "last_testcase": "[6,4,8,5,2,7]\n[[0,1],[0,3],[2,4],[3,4],[2,2]]",
    "expected_output": "[2,5,-1,5,2]",
    "task_finish_time": 1708882246159,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 949,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Python3",
    "submission_id": "1185981998",
    "input_formatted": "[6,4,8,5,2,7], [[0,1],[0,3],[2,4],[3,4],[2,2]]",
    "input": "[6,4,8,5,2,7]\n[[0,1],[0,3],[2,4],[3,4],[2,2]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "from typing import List\nfrom bisect import bisect_left\n\nclass Solution:\n    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(heights)\n        next_higher = [n] * n  # Initialize with n (out of bounds), assuming no higher building to the right\n        stack = []  # Monotonically decreasing stack (store indices)\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] < h:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        \n        # Precompute the leftmost reach for each building\n        leftmost_reach = [0] * n\n        for i in range(n):\n            if next_higher[i] == n:\n                leftmost_reach[i] = i  # No higher building, can only stay\n            else:\n                leftmost_reach[i] = leftmost_reach[next_higher[i]]\n\n        ans = []\n        for a, b in queries:\n            if leftmost_reach[a] >= b:\n                ans.append(-1)  # Alice cannot meet Bob\n            else:\n                # Binary search to find the leftmost common building they can meet\n                low, high = a, b\n                while low < high:\n                    mid = (low + high) // 2\n                    if leftmost_reach[mid] < b:\n                        high = mid\n                    else:\n                        low = mid + 1\n                ans.append(low if low < n and leftmost_reach[low] < b else -1)\n        return ans"
}