{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 88760000,
    "question_id": "3057",
    "elapsed_time": 117,
    "compare_result": "10000000000000000000000000000000000000000000000000000000000000000001100000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000100000000000000000000000000000000000000000000100000100000000000000000000011000000000000000000001000000000000010000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111110000000000000000000000000000000",
    "code_output": "3",
    "std_output": "",
    "last_testcase": "\"abbcd\"\n4",
    "expected_output": "2",
    "task_finish_time": 1708308714692,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 40,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1179362547",
    "input_formatted": "\"abbcd\", 4",
    "input": "\"abbcd\"\n4",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countKSubsequencesWithMaxBeauty(string s, int k) {\n        const int MOD = 1e9 + 7;\n        unordered_map<char, int> charCount;\n        for (char c : s) {\n            charCount[c]++;\n        }\n\n        // Pair: first = frequency, second = count of characters with this frequency\n        vector<pair<int, int>> frequencies;\n        for (const auto& p : charCount) {\n            frequencies.emplace_back(p.second, 0);\n        }\n\n        sort(frequencies.begin(), frequencies.end(), greater<pair<int, int>>());\n\n        // Count frequencies\n        for (auto& freq : frequencies) {\n            freq.second = count_if(frequencies.begin(), frequencies.end(), [&](const pair<int, int>& elem) { return elem.first == freq.first; });\n        }\n\n        // Remove duplicates\n        frequencies.erase(unique(frequencies.begin(), frequencies.end()), frequencies.end());\n\n        // Compute combinations\n        vector<vector<long long>> comb(101, vector<long long>(101, 0));\n        for (int i = 0; i <= 100; ++i) {\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; ++j) {\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n            }\n        }\n\n        long long result = 1;\n        int sum = 0, last = -1;\n        for (int i = 0; i < frequencies.size() && sum < k; ++i) {\n            int take = min(k - sum, frequencies[i].second);\n            sum += take;\n            result = (result * comb[frequencies[i].second][take]) % MOD;\n            last = frequencies[i].first;\n        }\n\n        // Count how many characters have the same frequency as the last chosen frequency\n        int sameLastFreq = count_if(charCount.begin(), charCount.end(), [last](const pair<char, int>& p) { return p.second == last; });\n        if (sameLastFreq > 1 && sum == k) {\n            result = (result * sameLastFreq) % MOD;\n        }\n\n        return result;\n    }\n};"
}