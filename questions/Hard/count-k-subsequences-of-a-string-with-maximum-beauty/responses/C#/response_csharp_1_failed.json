{
    "status_code": 11,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 42848000,
    "question_id": "3057",
    "elapsed_time": 360,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "\"bcca\"\n2",
    "expected_output": "4",
    "task_finish_time": 1708309109724,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 1,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C#",
    "submission_id": "1179366465",
    "input_formatted": "\"bcca\", 2",
    "input": "\"bcca\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public int CountKSubsequencesWithMaxBeauty(string s, int k) {\n        const int MOD = 1000000007;\n        int[] freq = new int[26];\n        foreach (char c in s) {\n            freq[c - 'a']++;\n        }\n\n        // Sort frequencies in descending order\n        Array.Sort(freq, (a, b) => b.CompareTo(a));\n\n        // Calculate the maximum beauty\n        int maxBeauty = 0;\n        for (int i = 0; i < k; i++) {\n            maxBeauty += freq[i];\n        }\n\n        // Calculate combinations for characters with the same frequency\n        long result = 1;\n        for (int i = 0; i < k; ) {\n            int count = 1;\n            while (i + count < 26 && freq[i] == freq[i + count] && freq[i] != 0) {\n                count++;\n            }\n            if (i + count <= k) { // Only consider if this batch can fully contribute to the maxBeauty\n                for (int j = 1; j <= count; j++) {\n                    result = result * j % MOD;\n                }\n            }\n            i += count;\n        }\n\n        return (int)result;\n    }\n}"
}