{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 2508000,
    "question_id": "3057",
    "elapsed_time": 2040,
    "compare_result": "00111111111111111111111111111111111111111111111111111111111111111110011111111000011100111111011111001111010101111111100111101000111001100001011010011111010100000101010111001001010000000000111000000001110000000101000000000000110000001000011001000001000100000000000000000100110010000001100000000000010000100001000000000100101111101010010000011110000000000000000000101000001110010001111000000000000000000101000001000100100110011011100001100011001100110100000000100000000000101100000000010001110111000000001000100011011100000110101001001110100011001000100000111111111111111111111111111100000000001000000100000000000",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "\"bcca\"\n2",
    "expected_output": "4",
    "task_finish_time": 1708319100142,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 262,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1179487648",
    "input_formatted": "\"bcca\", 2",
    "input": "\"bcca\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn count_k_subsequences_with_max_beauty(s: String, k: i32) -> i32 {\n        let modulo = 1_000_000_007;\n        let mut count = [0; 26];\n        s.bytes().for_each(|b| count[(b - b'a') as usize] += 1);\n        let mut freq: Vec<_> = count.iter().filter(|&&c| c > 0).collect();\n        freq.sort_unstable();\n        let mut max_beauty = 0;\n        let mut max_beauty_count = 0;\n        Self::dfs(0, k, 0, &mut max_beauty, &mut max_beauty_count, &freq, modulo);\n        max_beauty_count\n    }\n\n    fn dfs(\n        start: usize,\n        k: i32,\n        current_beauty: i32,\n        max_beauty: &mut i32,\n        max_beauty_count: &mut i32,\n        freq: &Vec<&i32>,\n        modulo: i32,\n    ) {\n        if k == 0 {\n            if current_beauty > *max_beauty {\n                *max_beauty = current_beauty;\n                *max_beauty_count = 1;\n            } else if current_beauty == *max_beauty {\n                *max_beauty_count = (*max_beauty_count + 1) % modulo;\n            }\n            return;\n        }\n        if start == freq.len() {\n            return;\n        }\n        for i in start..freq.len() {\n            Self::dfs(\n                i + 1,\n                k - 1,\n                current_beauty + freq[i],\n                max_beauty,\n                max_beauty_count,\n                freq,\n                modulo,\n            );\n        }\n    }\n}"
}