{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 2088000,
    "question_id": "3057",
    "elapsed_time": 12,
    "compare_result": "01110011010001001111000110100011101000011000001001100000011000111010100011000111000010000000000000110000010000001000000000011001000010001000000000000010000000001000001000000000000111100000000001100000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000110000000000010000000100010000000000000000000001000000000000000000000000001000000000001100000000001000100010100100010001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "\"bcca\"\n2",
    "expected_output": "4",
    "task_finish_time": 1708319033501,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 72,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1179486652",
    "input_formatted": "\"bcca\", 2",
    "input": "\"bcca\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn count_k_subsequences_with_max_beauty(s: String, k: i32) -> i32 {\n        let mut freq = vec![0; 26];\n        let modulo = 1_000_000_007;\n        for byte in s.bytes() {\n            freq[(byte - b'a') as usize] += 1;\n        }\n        freq.sort_unstable();\n        freq.reverse();\n        let mut max_beauty = 0;\n        let mut ways = 1;\n        for &f in freq.iter().take(k as usize) {\n            max_beauty += f;\n        }\n        for i in 0..k as usize {\n            ways = ways * Solution::n_choose_k(freq[i] as i64, freq[k as usize - 1] as i64, modulo) % modulo;\n        }\n        ways as i32\n    }\n\n    fn n_choose_k(n: i64, k: i64, modulo: i64) -> i64 {\n        let mut result = 1;\n        let mut k = k;\n        if k > n - k {\n            k = n - k;\n        }\n        for i in 0..k {\n            result = result * (n - i) % modulo;\n            result = result * Solution::mod_inv(i + 1, modulo) % modulo;\n        }\n        result\n    }\n\n    fn mod_inv(a: i64, module: i64) -> i64 {\n        let mut mn = (module, a);\n        let mut xy = (0, 1);\n        while mn.1 != 0 {\n            xy = (xy.1, xy.0 - (mn.0 / mn.1) * xy.1);\n            mn = (mn.1, mn.0 % mn.1);\n        }\n        while xy.0 < 0 {\n            xy.0 += module;\n        }\n        xy.0\n    }\n}"
}