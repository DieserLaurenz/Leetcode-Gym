{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 5752000,
    "question_id": "3057",
    "elapsed_time": 29,
    "compare_result": "01111011111101111111111111111111111101111111111111111101111111111110111111111010001010111111011101111111010001111011100011111001011011101001001010010011010100001001010001000001010001100000110000000000010000000100000000000000110000001000001000000001000100000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111100000100000000000000000000000",
    "code_output": "3",
    "std_output": "",
    "last_testcase": "\"bcca\"\n2",
    "expected_output": "4",
    "task_finish_time": 1708309016771,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 167,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1179365541",
    "input_formatted": "\"bcca\", 2",
    "input": "\"bcca\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long modPow(long long x, int y, int p) {\n    long long res = 1;\n    x = x % p;\n    while (y > 0) {\n        if (y & 1)\n            res = (res * x) % p;\n        y = y >> 1;\n        x = (x * x) % p;\n    }\n    return res;\n}\n\nlong long modInverse(long long n, int p) {\n    return modPow(n, p - 2, p);\n}\n\nlong long nCrModPFermat(int n, int r, int p) {\n    if (r == 0)\n        return 1;\n    long long fac[n + 1];\n    fac[0] = 1;\n    for (int i = 1; i <= n; i++)\n        fac[i] = fac[i - 1] * i % p;\n    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\n}\n\nint countKSubsequencesWithMaxBeauty(char* s, int k) {\n    int freq[26] = {0};\n    for (int i = 0; s[i]; i++)\n        freq[s[i] - 'a']++;\n\n    int count[101] = {0}, maxFreq = 0;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0) {\n            count[freq[i]]++;\n            if (freq[i] > maxFreq)\n                maxFreq = freq[i];\n        }\n    }\n\n    long long ans = 0;\n    for (int i = maxFreq; i > 0 && k > 0; i--) {\n        if (count[i] == 0) continue;\n        int take = count[i] < k ? count[i] : k;\n        ans = (ans + nCrModPFermat(count[i], take, MOD)) % MOD;\n        k -= take;\n    }\n\n    return ans;\n}"
}