{
    "status_code": 11,
    "lang": "kotlin",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 41132000,
    "question_id": "3057",
    "elapsed_time": 593,
    "compare_result": "00111011111101111111111111111111111101111111111111111101111111111110011111111000001000111111011101001111010001111011100011101000011001100001001010010011010100000001010001000001010000000000110000000000010000000100000000000000110000001000001000000001000100000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111100000000000000000000000000000",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "\"bcca\"\n2",
    "expected_output": "4",
    "task_finish_time": 1708318403587,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 153,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Kotlin",
    "submission_id": "1179477001",
    "input_formatted": "\"bcca\", 2",
    "input": "\"bcca\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    fun countKSubsequencesWithMaxBeauty(s: String, k: Int): Int {\n        val mod = 1_000_000_007\n        val freq = IntArray(26)\n        s.forEach { freq[it - 'a']++ }\n\n        // Calculate frequency of frequencies\n        val freqOfFreq = IntArray(s.length + 1)\n        freq.forEach { if (it > 0) freqOfFreq[it]++ }\n\n        // Find maximum beauty\n        var maxBeauty = 0\n        var kLeft = k\n        var totalWays = 1L\n        for (i in freqOfFreq.indices.reversed()) {\n            if (freqOfFreq[i] == 0) continue\n            val take = minOf(kLeft, freqOfFreq[i])\n            maxBeauty += i * take\n            kLeft -= take\n            // Calculate combinations for this frequency\n            totalWays = (totalWays * nCk(freqOfFreq[i], take, mod)) % mod\n            if (kLeft == 0) break\n        }\n\n        return totalWays.toInt()\n    }\n\n    private fun nCk(n: Int, k: Int, mod: Int): Long {\n        if (k == 0) return 1\n        var result = 1L\n        for (i in 0 until k) {\n            result = result * (n - i) % mod\n            result = result * modInverse(i + 1, mod) % mod\n        }\n        return result\n    }\n\n    private fun modInverse(a: Int, mod: Int): Long {\n        return power(a.toLong(), mod - 2, mod)\n    }\n\n    private fun power(x: Long, y: Int, mod: Int): Long {\n        var x = x\n        var y = y\n        var res = 1L\n        x = x % mod\n        while (y > 0) {\n            if (y and 1 == 1) res = (res * x) % mod\n            y = y shr 1\n            x = (x * x) % mod\n        }\n        return res\n    }\n}"
}