{
    "status_code": 11,
    "lang": "kotlin",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 48156000,
    "question_id": "3057",
    "elapsed_time": 534,
    "compare_result": "00111111111111111111111111111111111111111111111111111111111111111110011111111000011100111111011111001111010101111111100111101000111001100001011010011111010100000101010111001001010000000000111000000001110000000101000000000000110000001000011001000001000100000000000000000100110010000001100000000000010000100001000000000100101111101010010000011110000000000000000000101000001110010001111000000000000000000101000001000100100110011011100001100011001100110100000000100000000000101100000000010001110111000000001000100011011100000110101001001110100011001000100000111111111111111111111111111100000000001000000100000011000",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "\"bcca\"\n2",
    "expected_output": "4",
    "task_finish_time": 1708318351957,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 264,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Kotlin",
    "submission_id": "1179476242",
    "input_formatted": "\"bcca\", 2",
    "input": "\"bcca\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    fun countKSubsequencesWithMaxBeauty(s: String, k: Int): Int {\n        val mod = 1_000_000_007\n        val charCounts = IntArray(26)\n        s.forEach { charCounts[it - 'a']++ }\n\n        val freq = charCounts.filter { it > 0 }.sortedDescending()\n        if (k > freq.size) return 0\n\n        val fact = LongArray(s.length + 1)\n        val invFact = LongArray(s.length + 1)\n        fact[0] = 1\n        for (i in 1..s.length) fact[i] = fact[i - 1] * i % mod\n        invFact[s.length] = fact[s.length].modInverse(mod)\n        for (i in s.length - 1 downTo 0) invFact[i] = invFact[i + 1] * (i + 1) % mod\n\n        fun nCr(n: Int, r: Int): Long {\n            if (r > n) return 0\n            return fact[n] * invFact[r] % mod * invFact[n - r] % mod\n        }\n\n        var maxBeauty = freq.take(k).sum()\n        val maxFreq = freq.take(k).groupBy { it }.mapValues { it.value.size }\n\n        var count = 1L\n        for ((value, occurrences) in maxFreq) {\n            count = count * nCr(charCounts.count { it == value }, occurrences) % mod\n        }\n\n        return count.toInt()\n    }\n\n    private fun Long.modInverse(mod: Int): Long {\n        // Fermat's Little Theorem for mod inverse\n        return this.modPow(mod - 2, mod.toLong())\n    }\n\n    private fun Long.modPow(exponent: Int, mod: Long): Long {\n        var base = this\n        var exp = exponent.toLong()\n        var result = 1L\n        while (exp > 0) {\n            if (exp and 1L == 1L) result = (result * base) % mod\n            base = (base * base) % mod\n            exp = exp shr 1\n        }\n        return result\n    }\n}"
}