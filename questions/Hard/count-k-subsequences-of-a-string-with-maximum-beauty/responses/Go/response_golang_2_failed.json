{
    "status_code": 11,
    "lang": "golang",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 6700000,
    "question_id": "3057",
    "elapsed_time": 65,
    "compare_result": "01111111111111111111111111111111111111111111111111111111111111111110111111111111011110111111011111111111010101111111100111111001111011101001011010011111010100001101011111001001010111100000111001100001110000000101000000000000110000001000011001000001000100000000000000000100110010000001100110000000010010100001100010000100101111101010011000011110000000000000000001101000001111110001111001000100010100100111001001000100100110011011100001100011001100110100000000100000000000101100000000010001110111000000001000100011011100100110101001001110100011001000100000111111111111111111111111111100000111111011001100000111000",
    "code_output": "5",
    "std_output": "",
    "last_testcase": "\"bcca\"\n2",
    "expected_output": "4",
    "task_finish_time": 1708318693031,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 310,
    "total_testcases": 611,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Go",
    "submission_id": "1179481422",
    "input_formatted": "\"bcca\", 2",
    "input": "\"bcca\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "func countKSubsequencesWithMaxBeauty(s string, k int) int {\n const MOD int = 1e9 + 7\n freq := make(map[rune]int)\n for _, c := range s {\n  freq[c]++\n }\n\n beauties := make([]int, 0, len(freq))\n for _, f := range freq {\n  beauties = append(beauties, f)\n }\n\n // Sort the beauties in descending order\n sort.Slice(beauties, func(i, j int) bool {\n  return beauties[i] > beauties[j]\n })\n\n // Calculate the maximum beauty\n maxBeauty := 0\n if len(beauties) >= k {\n  for i := 0; i < k; i++ {\n   maxBeauty += beauties[i]\n  }\n }\n\n // Calculate combinations using dynamic programming\n dp := make([][]int, len(beauties)+1)\n for i := range dp {\n  dp[i] = make([]int, k+1)\n  dp[i][0] = 1\n }\n for i := 1; i <= len(beauties); i++ {\n  for j := 1; j <= k; j++ {\n   dp[i][j] = dp[i-1][j] + dp[i-1][j-1]*beauties[i-1]\n   dp[i][j] %= MOD\n  }\n }\n\n return dp[len(beauties)][k]\n}"
}