{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 217220000,
    "question_id": "2894",
    "elapsed_time": 538,
    "compare_result": "1101101011100111111011111001111111110111111111101111111110001111110111111111111101111111111111111111111100101111011111111111111011111111111111111011110000111110111111011111111111111111111111111111010110111111111011111111111111001101100101111110111101111010110110110111110010111011011101111111110110111111111101100100110101111101111110100111111111111111010110010111010111011011111111110011011001110000000011100001111010110111111110110110011111101110101100110111001000110110110110111111011011111111111011111111011110101111011010001100011111111111111111011111101111111110011111111011110011110010100111111110111111101010101001100001011100111111010110111110110101101000000111101101110111101111110011110110101111110111011100110101110111111111100001110100101110101011100101111111101111110111111101111110110011111100101111000111111110001111001101101110011111101011110111101101000110101010111001111100111111111100111011101000010001110101110111111110111111001111101011011100110111011101010010111000111111101011110111011111110111001111011110100111010100010110011101111010101011001011111101011110101111111011010101111111111011110110111110011011101101111111011100001110110001011011111111100100111100111110010110111111011011110101100101111111101101110111100110101111100001111111101111111110111111101110111101111011110110001100001101001101001110111101111101100011111111011101001111001011110011010100100011111001111001110001111111101101010110001011011001100011101011011001111011111111000100010100111111110011111001110101011101110110111010010000011111111011010110111111110101011110110101011110011101101101100101011110101111110011111100100101011110001111010100000011100101100000000000011011100000101111101010010111010110111111011100100101010111101111011010011110011010010111111111010001111001111001101111010101011010110000101101011111111000100110111111001011001101111111111110110101111101110110100011111110111101001001101111001001111101010110100111101000110101110100110000111101111001101100100111111111001111111011111100110110111101100010000111011111111110111010001111101100111011111111001010000111110111000011100010111110110101010101110100101011101111111110111100001011011111111001101111100110100010011011010100010110101101011101010110111011100100011011010011101111011111010000001110010001111010001101011011010101101101111011111010111011110100010111111101100000010010001010101010100100000000100000000110000100001110101000110011110111111110110110001010110011111001111011011110111110001000010111101101110010001101011110111000110100011100100111010100111011001011100011000110011101110110111001111011000101000001011110100001111111111110110000000011001111110111101111101111110110101100111110001101010011010111101011101110110001001111111111100110110001",
    "code_output": "9",
    "std_output": "",
    "last_testcase": "[[1,1],[2,1],[3,1]]\n3",
    "expected_output": "7",
    "task_finish_time": 1708567125833,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 1811,
    "total_testcases": 2728,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1182536265",
    "input_formatted": "[[1,1],[2,1],[3,1]], 3",
    "input": "[[1,1],[2,1],[3,1]]\n3",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long findMaximumElegance(vector<vector<int>>& items, int k) {\n        unordered_map<int, vector<int>> categoryProfits;\n        for (auto& item : items) {\n            categoryProfits[item[1]].push_back(item[0]);\n        }\n\n        vector<int> bestProfits;\n        for (auto& [category, profits] : categoryProfits) {\n            sort(profits.rbegin(), profits.rend()); // Sort in descending order to get the best profit first\n            bestProfits.push_back(profits[0]); // Always take the best profit from each category\n        }\n\n        sort(bestProfits.rbegin(), bestProfits.rend()); // Sort the best profits in descending order\n\n        long long totalProfit = 0;\n        int distinctCategories = min((int)bestProfits.size(), k);\n        for (int i = 0; i < min(k, (int)bestProfits.size()); ++i) {\n            totalProfit += bestProfits[i];\n        }\n\n        // If we haven't reached k items, fill the remaining with the next best profits\n        for (int i = distinctCategories; i < k && i < items.size(); ++i) {\n            totalProfit += items[i][0]; // This assumes items are sorted by profit, which they are not\n                                          // So this approach is flawed in that sense\n        }\n\n        return totalProfit + (long long)distinctCategories * distinctCategories;\n    }\n};"
}