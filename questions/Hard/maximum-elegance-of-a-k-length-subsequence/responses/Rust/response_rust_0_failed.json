{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 15924000,
    "question_id": "2894",
    "elapsed_time": 103,
    "compare_result": "0011010110111101111111101111111001111100111000111010101111110111011011011011010111011111011101111100111111111011111111111110101011101111111111011111111111111101111111111111111111011111111111111111011111111111111011111111111111001111111111111111111111101111101111111111111111101111111111111111011001010111011011001111101101011101001011111101101100111111100110111111111110111000111011111111111110110111111111111100111101111110100101111111111111011111001111111111011111011011001101010100110111111111010110100111011110110000111101111001101111110111011001111111001011010001111111101101010011110111011011111001000010111110011111001111111010110001101011101111111110101111111111010011001010001111000101101001011000101111101011011110001101010100111100101111010110110000110111110110101011111111100111101001111101100011010100110111001110110111111101111111101111011001001010111111110011001100101010011111111110100111010111110100111001010010100111101011001110101000101111001011100110000010101001100100010100011101010000001011101110000110001011100111001010110111101001110010000110110000001101011011100100011100110011001100010101101000011100000110100001111111010011100101010111110100001010010000101001010101011100001101101000001101011110011111100101011000000010010000110001110111111010010110000011000011101000100011110100101001101001100110110011111001111000110010110100110101110010111000011110001101101100000011001010111011100101001110101011100101100100000000100111110010110000011100001100011110111010000100111000100100100100100011001001101011111011100110111110010010001101001010110010110001001011110011000001101100010110110111011110001001001000001101000100000010010101100000000000111100100110100010011100010000100100100100010110000001100011001010001000010010100001000001010001010001010010100010010100000001001000010101000100000000000000011000100000001000000001000101001101001000101000000010100000001100000000000000000000101001100000010000001000000000100000100000001000000001011010000000000010101000010010100000000000100001000101010011000000101100110010010000000000010000001000101010000000001100000001000001000001000000000001000000010000000000011000010001000000000000000000000100000000100000000010000000000100000000000000010101000000000011000100000110000000000000000000100000000000000000000000001000010000000000000100000001001011100101010000010010101100100000010010000000000010100101000000000000000000000000001000000000000000000000001000000000000010000000000000001000000100010000000000000000000000000001000000000000000000000000001000010100000000001000000000100000000100000000000000000000000000000000000000000010000000011111101101010000000011110000101100101110111111000101111001011111010001111111111110100001111010111011101001010100010110110001",
    "code_output": "19",
    "std_output": "",
    "last_testcase": "[[3,2],[5,1],[10,1]]\n2",
    "expected_output": "17",
    "task_finish_time": 1708577789581,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 1269,
    "total_testcases": 2728,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1182660403",
    "input_formatted": "[[3,2],[5,1],[10,1]], 2",
    "input": "[[3,2],[5,1],[10,1]]\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn find_maximum_elegance(items: Vec<Vec<i32>>, k: i32) -> i64 {\n        use std::collections::HashMap;\n\n        let k = k as usize;\n        let mut category_map: HashMap<i32, Vec<i32>> = HashMap::new();\n\n        // Group items by categories and sort each category by profit in descending order\n        for item in items {\n            category_map.entry(item[1]).or_default().push(item[0]);\n        }\n        for (_, profits) in category_map.iter_mut() {\n            profits.sort_unstable_by(|a, b| b.cmp(a));\n        }\n\n        // Collect first k items from each category\n        let mut all_items: Vec<i32> = Vec::new();\n        let mut categories_with_excess_items: Vec<(i32, usize)> = Vec::new();\n        for (category, profits) in &category_map {\n            let mut profit_sum = 0;\n            for i in 0..k.min(profits.len()) {\n                profit_sum += profits[i];\n            }\n            if profits.len() > k {\n                categories_with_excess_items.push((profit_sum, profits.len()));\n            } else {\n                all_items.extend_from_slice(&profits[0..k.min(profits.len())]);\n            }\n        }\n\n        // Sort all items and categories with excess items\n        all_items.sort_unstable_by(|a, b| b.cmp(a));\n        categories_with_excess_items.sort_unstable_by(|a, b| b.0.cmp(&a.0));\n\n        // Calculate initial profit and categories\n        let mut total_profit: i64 = all_items.iter().take(k).map(|&x| x as i64).sum();\n        let mut distinct_categories = category_map.len().min(k);\n        let mut max_elegance = total_profit + (distinct_categories as i64).pow(2);\n\n        // Try to replace items with those from categories_with_excess_items if beneficial\n        for (i, (extra_profit, _)) in categories_with_excess_items.iter().enumerate() {\n            if i >= k || i >= all_items.len() {\n                break;\n            }\n            if all_items[i] as i64 > *extra_profit as i64 {\n                break;\n            }\n            total_profit = total_profit - all_items[i] as i64 + *extra_profit as i64;\n            max_elegance = max_elegance.max(total_profit + (distinct_categories as i64).pow(2));\n        }\n\n        max_elegance\n    }\n}"
}