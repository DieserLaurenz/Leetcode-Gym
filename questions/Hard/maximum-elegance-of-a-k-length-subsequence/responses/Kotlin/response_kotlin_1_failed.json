{
    "status_code": 11,
    "lang": "kotlin",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 125328000,
    "question_id": "2894",
    "elapsed_time": 1312,
    "compare_result": "1111111111011011111101011111011111101011011111111101011011111011111100101110101111111000111110011111000111011111101110011111110010010100000001111110111111110111010000101000001111100100001100000010011001100001010000001111100110110110011011001001100110110101111011001000001101000110101011100001001001001110011111111011101100011111111011011011010011111100110001101011101101100010000100011100110111001111111110011101000111011110011111001011101000010001101011111101010111001001011011010011111100000010100101001100100000111010100101111011110010100000100100100011000000101101100100010110001100011101111000000111000100010101110110111110111111001100101101111001111110011111111000010011001100000000001111011111110100001000100011101011101110100001011110001011110011010110011010000000001100001110001010100011001110011011011000111000100011111011110011010101100000110110101000010010111001011101010110100011000100000011100100010100101000101010001100000001010101100000010100110011001000110110101011011111000000010100101000110000011000111000110001011000001111100001110110000101010100111001001010100001010001000110101110000000100100011001000001100100010010000000000011110001001110100100000100011001000011000001101001000010110100001000011010000000010010001100011011010000010000001000010001000001000000011001000010011101001001110111110110110010110001000010000010011100001010100010111011110100001100101011011100000110000110001110010000010010101001110110111110011110010100101010001111000000111011101011000100001100000110011011100010011001000101101111100000001101101011000000001010110001001111100001111110010010011010110001110000011100000010001000000001000000100000110000011010010001010000100100011111000000010111001000101001000000100011011010100000010100100101000001100101101000000000101110000110000111010000101010000101001111010010100000000111011101000000110000110010000000000001001010000010001101000100000001000110000110010000110110000010100001011000010110001010001011001011000010000110010011011000010000110000000100000011001001010010011101101010100000000000100101110011010111100100000000110101111000001000111100111101000001001010101010001011010100010000100001000010110100101000000110010000010001111101100100101011100001010011100010101001000100001011100100101100010000100000101111110001001110000101110010000100101010010010000100000101000100001011101000000010000100001001010000010000010011000001011000000000110010010000010111001100001000000001001001110101001100000110000101100001000001110111101000010010001101110010100001000111001011100011011000101011000100110100011100111001100010001001000110000100111010111110100001011110011110100011010000000000111100001100010100010011000001111111100001110110101100111100010100011001101110110010000010011001010101",
    "code_output": "15",
    "std_output": "",
    "last_testcase": "[[1,2],[10,1]]\n1",
    "expected_output": "11",
    "task_finish_time": 1708577156881,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 1203,
    "total_testcases": 2728,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Kotlin",
    "submission_id": "1182650742",
    "input_formatted": "[[1,2],[10,1]], 1",
    "input": "[[1,2],[10,1]]\n1",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    fun findMaximumElegance(items: Array<IntArray>, k: Int): Long {\n        // Group by category and sort each group by profit in descending order\n        val groupedItems = items.groupBy { it[1] }.mapValues { (_, v) -> \n            v.map { it[0] }.sortedDescending()\n        }\n\n        // Priority queue for the highest profits, lambda specifies max heap\n        val maxProfits = PriorityQueue<Int>(compareByDescending { it })\n\n        // Total profit and categories counter\n        var totalProfit = 0L\n        var categories = 0\n\n        // Process each group\n        for ((_, profits) in groupedItems) {\n            // Add the highest profit of each category\n            if (profits.isNotEmpty()) {\n                totalProfit += profits[0]\n                categories++\n                // Add remaining profits to the priority queue\n                profits.drop(1).forEach { maxProfits.add(it) }\n            }\n        }\n\n        // Calculate initial elegance\n        var maxElegance = totalProfit + categories.toLong() * categories.toLong()\n\n        // Adjust for k items, adding profits from the queue if needed\n        for (i in categories until k) {\n            if (maxProfits.isNotEmpty()) {\n                totalProfit += maxProfits.poll()\n                maxElegance = maxOf(maxElegance, totalProfit + categories.toLong() * categories.toLong())\n            }\n        }\n\n        return maxElegance\n    }\n}"
}