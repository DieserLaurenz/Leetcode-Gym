{
    "status_code": 11,
    "lang": "golang",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 36548000,
    "question_id": "2894",
    "elapsed_time": 365,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111011111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111110111111111111111111011111111111111111111111111111111111101111111111111111111111111111111111111101111111111011111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111001111111111111111111111111101111111111111111111111111111111011111111111111111111111111111111111111111111111111111111011111110111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111101111111111111111111111111111111111101111111111111111111111111111111111111110001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101101011111001111110100110011111111110001010000111111111111101111111111011111111111111111111111111111110111111111111111011111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111011111111111111111111111111111111111111100111111111111111001111111111111111111111110111111111111110111111111111111011111111111111111111111111111111111111111111111111111111111111111111101111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111110111111111111111111111110111111111111111111111111111101111111111111111111111111111111111111111011111111111111111011111111111111111111111111111111111111111111111111111100100011011011010111010110111000001111000000110110110011110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000011111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111110101",
    "code_output": "14",
    "std_output": "",
    "last_testcase": "[[2,2],[8,3],[8,3]]\n2",
    "expected_output": "17",
    "task_finish_time": 1708577415631,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 2620,
    "total_testcases": 2728,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Go",
    "submission_id": "1182654678",
    "input_formatted": "[[2,2],[8,3],[8,3]], 2",
    "input": "[[2,2],[8,3],[8,3]]\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "import (\n    \"sort\"\n)\n\nfunc findMaximumElegance(items [][]int, k int) int64 {\n    // Group items by category\n    categoryItems := make(map[int][]int)\n    for _, item := range items {\n        categoryItems[item[1]] = append(categoryItems[item[1]], item[0])\n    }\n\n    // Sort profits in each category in descending order\n    for _, profits := range categoryItems {\n        sort.Sort(sort.Reverse(sort.IntSlice(profits)))\n    }\n\n    // Prepare a slice for top k items and extra items\n    topItems := make([]int, 0, k)\n    extraItems := make([]int, 0)\n\n    for _, profits := range categoryItems {\n        topItems = append(topItems, profits[0]) // Take the most profitable item from each category\n        for _, profit := range profits[1:] {    // The rest goes to extra items\n            extraItems = append(extraItems, profit)\n        }\n    }\n\n    // Sort top items and extra items in descending order\n    sort.Sort(sort.Reverse(sort.IntSlice(topItems)))\n    sort.Sort(sort.Reverse(sort.IntSlice(extraItems)))\n\n    totalProfit := 0\n    for i := 0; i < k && i < len(topItems); i++ {\n        totalProfit += topItems[i]\n    }\n\n    distinctCategories := min(k, len(topItems))\n    if distinctCategories < k { // If we still need more items, take them from extra items\n        for i := 0; i < k-distinctCategories; i++ {\n            totalProfit += extraItems[i]\n        }\n    }\n\n    elegance := int64(totalProfit) + int64(distinctCategories*distinctCategories)\n    return elegance\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}"
}