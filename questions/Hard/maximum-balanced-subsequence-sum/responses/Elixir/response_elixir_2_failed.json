{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 261224000,
    "question_id": "3184",
    "elapsed_time": 1126,
    "compare_result": "0001000000000001111111111111100010000101101110110000000000010001100111000000010010000000000001000000001110100001000000100000000000000000000000000000000000000000001010000000000000100000000000000000000100100010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101001111000000000000000000000000000000",
    "code_output": "23",
    "std_output": "",
    "last_testcase": "[3,3,5,6]",
    "expected_output": "14",
    "task_finish_time": 1708567067822,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 51,
    "total_testcases": 346,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1182535746",
    "input_formatted": "[3,3,5,6]",
    "input": "[3,3,5,6]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec max_balanced_subsequence_sum(nums :: [integer]) :: integer\n  def max_balanced_subsequence_sum(nums) do\n    nums\n    |> Enum.reduce({[], 0}, fn num, {stack, max_sum} ->\n      cond do\n        stack == [] -> \n          {[num], max(num, max_sum)}\n        true -> \n          {new_stack, new_max_sum} = Enum.reduce_while(stack, {[], max_sum}, fn x, ({acc, acc_max_sum}) ->\n            if num - x >= Enum.count(acc) + 1 do\n              {:cont, {acc ++ [x], acc_max_sum + x}}\n            else\n              {:halt, {acc, acc_max_sum}}\n            end\n          end)\n          {new_stack ++ [num], max(new_max_sum + num, max_sum)}\n      end\n    end)\n    |> elem(1)\n  end\nend"
}