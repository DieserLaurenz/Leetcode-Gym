{
    "status_code": 11,
    "lang": "racket",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 946556000,
    "question_id": "3091",
    "elapsed_time": 5039,
    "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "4",
    "std_output": "",
    "last_testcase": "[1,2,2,3]\n6\n6",
    "expected_output": "1",
    "task_finish_time": 1708361394001,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 3,
    "total_testcases": 643,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1180066569",
    "input_formatted": "[1,2,2,3], 6, 6",
    "input": "[1,2,2,3]\n6\n6",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "(define/contract (count-sub-multisets nums l r)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  (letrec ([mod (lambda (x) (modulo x 1000000007))]\n           [count-sums (lambda (lst acc)\n                         (if (null? lst)\n                             acc\n                             (let* ([curr (car lst)]\n                                    [rest (cdr lst)]\n                                    [new-acc (map (lambda (x) (mod (+ x curr))) acc)])\n                               (count-sums rest (append acc new-acc (list curr))))))]\n           [count-range (lambda (lst l r)\n                          (foldl (lambda (x acc)\n                                   (if (and (>= x l) (<= x r)) (mod (+ acc 1)) acc))\n                                 0\n                                 lst))])\n    (count-range (count-sums nums (list 0)) l r)))"
}