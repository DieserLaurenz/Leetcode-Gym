{
    "status_code": 10,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "632 ms",
    "memory": 107732000,
    "question_id": "2827",
    "elapsed_time": 754,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1708495882366,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 925,
    "total_testcases": 925,
    "runtime_percentile": 57.715900000000204,
    "status_memory": "107.7 MB",
    "memory_percentile": 68.57220000000014,
    "pretty_lang": "C++",
    "submission_id": "1181691179",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int find(vector<int>& parent, int x) {\n        if (parent[x] != x) parent[x] = find(parent, parent[x]);\n        return parent[x];\n    }\n\n    void unite(vector<int>& parent, int x, int y) {\n        x = find(parent, x);\n        y = find(parent, y);\n        if (x != y) {\n            parent[x] = y;\n        }\n    }\n\n    bool canTraverseAllPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> parent(n);\n        for (int i = 0; i < n; ++i) parent[i] = i;\n\n        unordered_map<int, vector<int>> factors;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 2; j * j <= nums[i]; ++j) {\n                if (nums[i] % j == 0) {\n                    factors[j].push_back(i);\n                    while (nums[i] % j == 0) nums[i] /= j;\n                }\n            }\n            if (nums[i] > 1) factors[nums[i]].push_back(i);\n        }\n\n        for (auto& [factor, indices] : factors) {\n            for (int i = 1; i < indices.size(); ++i) {\n                unite(parent, indices[i], indices[i - 1]);\n            }\n        }\n\n        int representative = find(parent, 0);\n        for (int i = 1; i < n; ++i) {\n            if (find(parent, i) != representative) return false;\n        }\n        return true;\n    }\n};"
}