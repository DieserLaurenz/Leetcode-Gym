{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 888896000,
    "question_id": "2827",
    "elapsed_time": 5911,
    "compare_result": "0101111111111010001000100001010000000000000001000000010000000000000100000001100000000000000000100000110101000000000000000000000000000000000010000000000001000000000000101000001100000100000010000000000100000000000000100100000010010000011000000000000100000100100100000010011001100000000000100000000000000000000000000001000100000000000000110010100000000101000000010000000000000000000000000000100100000000000000000000100110000000000000000100000000000000000000000000000110000010000000100100000000001000000001010000000100000000000000001010001000000001100010000000000000010000000100000000000001000000000000010000000000001001010000001000000000000100000001000100010000000010000000100000000000000100000000000000000000000100000010100000001000011000100000001000000001010100011000010011101001011010001111100000000010011001000000000011001100000001000111000011110110101100000001011110010000111111011110011101001011111111110111000000000000000",
    "code_output": "false",
    "std_output": "",
    "last_testcase": "[2,3,6]",
    "expected_output": "true",
    "task_finish_time": 1708514754747,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 178,
    "total_testcases": 925,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1181921631",
    "input_formatted": "[2,3,6]",
    "input": "[2,3,6]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec can_traverse_all_pairs(nums :: [integer]) :: boolean\n  def can_traverse_all_pairs(nums) do\n    edges = for i <- Enum.with_index(nums), j <- Enum.with_index(nums), i < j && gcd(elem(i, 1), elem(j, 1)) > 1, do: {elem(i, 0), elem(j, 0)}\n    graph = build_graph(edges, %{})\n    all_nodes = Enum.map(0..length(nums)-1, &(&1))\n    can_visit_all?(all_nodes, graph)\n  end\n\n  defp gcd(a, 0), do: a\n  defp gcd(a, b), do: gcd(b, rem(a, b))\n\n  defp build_graph([], graph), do: graph\n  defp build_graph([{u, v} | edges], graph) do\n    graph = Map.update(graph, u, [v], &[v | &1])\n    graph = Map.update(graph, v, [u], &[u | &1])\n    build_graph(edges, graph)\n  end\n\n  defp can_visit_all?([], _graph), do: true\n  defp can_visit_all?([node | _] = nodes, graph) do\n    visited = traverse(graph, node, MapSet.new())\n    Enum.all?(nodes, &MapSet.member?(visited, &1))\n  end\n\n  defp traverse(graph, node, visited) do\n    if MapSet.member?(visited, node) do\n      visited\n    else\n      neighbors = Map.get(graph, node, [])\n      Enum.reduce(neighbors, MapSet.put(visited, node), fn x, acc -> traverse(graph, x, acc) end)\n    end\n  end\nend"
}