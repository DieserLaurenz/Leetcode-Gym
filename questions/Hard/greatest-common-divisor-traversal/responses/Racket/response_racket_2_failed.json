{
    "status_code": 11,
    "lang": "racket",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 127608000,
    "question_id": "2827",
    "elapsed_time": 5049,
    "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "false",
    "std_output": "",
    "last_testcase": "[2,3,6]",
    "expected_output": "true",
    "task_finish_time": 1708506771398,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 925,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1181831652",
    "input_formatted": "[2,3,6]",
    "input": "[2,3,6]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "(define/contract (can-traverse-all-pairs nums)\n  (-> (listof exact-integer?) boolean?)\n\n  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  \n  (define (connected? i j)\n    (> (gcd (list-ref nums i) (list-ref nums j)) 1))\n  \n  (define (build-graph n)\n    (let ((g (make-vector n '())))\n      (for ([i (in-range n)])\n        (for ([j (in-range n)])\n          (when (and (not (= i j)) (connected? i j))\n            (vector-set! g i (cons j (vector-ref g i)))\n            (vector-set! g j (cons i (vector-ref g j))))))\n      g))\n  \n  (define (dfs graph visited node)\n    (when (not (vector-ref visited node))\n      (vector-set! visited node #t)\n      (for-each (lambda (n) (dfs graph visited n)) (vector-ref graph node))))\n  \n  (let* ((n (length nums))\n         (graph (build-graph n))\n         (visited (make-vector n #f)))\n    (dfs graph visited 0)\n    (for/or ([i (in-range n)]) (not (vector-ref visited i)))))"
}