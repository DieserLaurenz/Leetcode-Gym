{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "andmap: contract violation",
    "full_runtime_error": "andmap: contract violation\n  expected: list?\n  given: '#(#t #t #t)\n  context...:\n   /usr/share/racket/collects/racket/private/map.rkt:275:2: gen-andmap\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:35:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 100004000,
    "question_id": "2827",
    "elapsed_time": 386,
    "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[2,3,6]",
    "expected_output": "true",
    "task_finish_time": 1708506724594,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 925,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1181831104",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (can-traverse-all-pairs nums)\n  (-> (listof exact-integer?) boolean?)\n  \n  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  \n  (define (connected? i j)\n    (> (gcd (list-ref nums i) (list-ref nums j)) 1))\n  \n  (define (build-graph n)\n    (let ((g (make-vector n '())))\n      (for ([i (in-range n)])\n        (for ([j (in-range n)])\n          (when (and (not (= i j)) (connected? i j))\n            (vector-set! g i (cons j (vector-ref g i)))\n            (vector-set! g j (cons i (vector-ref g j))))))\n      g))\n  \n  (define (dfs graph visited node)\n    (when (not (vector-ref visited node))\n      (vector-set! visited node #t)\n      (for-each (lambda (n) (dfs graph visited n)) (vector-ref graph node))))\n  \n  (let* ((n (length nums))\n         (graph (build-graph n))\n         (visited (make-vector n #f)))\n    (dfs graph visited 0)\n    (andmap vector-ref visited (range n))))"
}