{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 3220000,
    "question_id": "2827",
    "elapsed_time": 2165,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101011111111000000000",
    "code_output": "true",
    "std_output": "",
    "last_testcase": "[1,1]",
    "expected_output": "false",
    "task_finish_time": 1708506520934,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 914,
    "total_testcases": 925,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1181828504",
    "input_formatted": "[1,1]",
    "input": "[1,1]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "use std::collections::{HashMap, HashSet};\n\nimpl Solution {\n    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {\n        let mut graph = HashMap::new();\n        let mut primes = HashMap::new();\n\n        for &num in &nums {\n            let factors = Self::prime_factors(num);\n            for &factor in &factors {\n                primes.entry(factor).or_insert_with(Vec::new).push(num);\n            }\n        }\n\n        for factors in primes.values() {\n            for &num in factors {\n                for &connected_num in factors {\n                    if num != connected_num {\n                        graph.entry(num).or_insert_with(HashSet::new).insert(connected_num);\n                    }\n                }\n            }\n        }\n\n        let mut visited = HashSet::new();\n        Self::dfs(nums[0], &graph, &mut visited);\n\n        nums.into_iter().all(|num| visited.contains(&num))\n    }\n\n    fn prime_factors(mut n: i32) -> Vec<i32> {\n        let mut factors = Vec::new();\n        while n % 2 == 0 {\n            factors.push(2);\n            n /= 2;\n        }\n        let mut i = 3;\n        while i * i <= n {\n            while n % i == 0 {\n                factors.push(i);\n                n /= i;\n            }\n            i += 2;\n        }\n        if n > 2 {\n            factors.push(n);\n        }\n        factors\n    }\n\n    fn dfs(node: i32, graph: &HashMap<i32, HashSet<i32>>, visited: &mut HashSet<i32>) {\n        if visited.insert(node) {\n            if let Some(neighbors) = graph.get(&node) {\n                for &neighbor in neighbors {\n                    Self::dfs(neighbor, graph, visited);\n                }\n            }\n        }\n    }\n}"
}