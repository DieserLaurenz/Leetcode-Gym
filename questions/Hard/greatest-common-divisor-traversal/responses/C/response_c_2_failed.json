{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 12512000,
    "question_id": "2827",
    "elapsed_time": 789,
    "compare_result": "0101111111111010101100101001010000100000000011000000010000000000000100000001100000000000000000100000110101000000000000000000000000000000000010000000000001000000000000101000001100000100000010000000000100000000000000100100000010010000011000000000000100000100100100000010011001100000000000100000000000000000000000000001000100000000000000110010100000000101000000010000000000000000000000000000100100000000000000000000100110000000000000000100000000000000000000000000000110000010000000100100000000001000000001010000000100000000000000001010001000000001100010000000000000010000000100000000000001000000000000010000000000001001010000001000000000000100000001000100010000000010000000100000000000000100000000000000000000000100000010100000001000011000100000001000000001010100011000010011101001011010001111100000000010011001000000000011001100000001000111000011110110101100000001011110010000111111011110011101001011111111101011111111111111000",
    "code_output": "false",
    "std_output": "",
    "last_testcase": "[2,3,6]",
    "expected_output": "true",
    "task_finish_time": 1708504885080,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 194,
    "total_testcases": 925,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1181808913",
    "input_formatted": "[2,3,6]",
    "input": "[2,3,6]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <stdbool.h>\n#include <string.h>\n\nint parent[100001]; // Using a global array to improve performance\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x), py = find(y);\n    if (px != py) parent[px] = py;\n}\n\nbool canTraverseAllPairs(int* nums, int numsSize) {\n    for (int i = 1; i <= 100000; i++) parent[i] = i; // Initialize parents\n    \n    bool prime[100001]; // Sieve of Eratosthenes\n    memset(prime, true, sizeof(prime));\n\n    for (int p = 2; p * p <= 100000; p++) {\n        if (prime[p]) {\n            for (int i = p * 2; i <= 100000; i += p) prime[i] = false;\n        }\n    }\n\n    for (int i = 0; i < numsSize; i++) {\n        for (int j = 2; j * j <= nums[i]; j++) {\n            if (nums[i] % j == 0) {\n                unionSet(j, nums[i]);\n                while (nums[i] % j == 0) nums[i] /= j; // Reduce to prime factorization\n            }\n        }\n        if (nums[i] > 1) unionSet(nums[i], nums[i]); // Handle prime number itself\n    }\n\n    int root = find(nums[0]);\n    for (int i = 1; i < numsSize; i++) {\n        if (find(nums[i]) != root) return false;\n    }\n\n    return true;\n}"
}