{
    "status_code": 20,
    "lang": "swift",
    "run_success": false,
    "compile_error": "Line 25: Char 88: error: no exact matches in call to instance method 'distance' in solution.swift",
    "full_compile_error": "Line 25: Char 88: error: no exact matches in call to instance method 'distance' in solution.swift\n                       source.distance(from: source.startIndex, offsetBy: i) <= source.distance(from: range.lowerBound, offsetBy: 0),\n                                                                                       ^\nLine 25: Char 39: error: incorrect argument label in call (have 'from:offsetBy:', expected 'from:to:') in solution.swift\n                       source.distance(from: source.startIndex, offsetBy: i) <= source.distance(from: range.lowerBound, offsetBy: 0),\n                                      ^                         ~~~~~~~~\nLine 25: Char 75: error: cannot convert value of type 'Int' to expected argument type 'String.Index' in solution.swift\n                       source.distance(from: source.startIndex, offsetBy: i) <= source.distance(from: range.lowerBound, offsetBy: 0),\n                                                                          ^\nLine 26: Char 108: error: cannot convert value of type 'String.Index' to expected argument type 'Int' in solution.swift\n                       let targetRange = target.range(of: changed[original.index(of: original, offsetBy: 0)!], options: [], range: j < n ? (target.index(target.startIndex, offsetBy: j)..<target.endIndex) : nil),\n                                                                                                           ^\nLine 26: Char 81: error: extraneous argument label 'of:' in call in solution.swift\n                       let targetRange = target.range(of: changed[original.index(of: original, offsetBy: 0)!], options: [], range: j < n ? (target.index(target.startIndex, offsetBy: j)..<target.endIndex) : nil),\n                                                                                ^~~~~\nLine 26: Char 86: error: cannot convert value of type 'String' to expected argument type 'String.Index' in solution.swift\n                       let targetRange = target.range(of: changed[original.index(of: original, offsetBy: 0)!], options: [], range: j < n ? (target.index(target.startIndex, offsetBy: j)..<target.endIndex) : nil),\n                                                                                     ^\nLine 26: Char 108: error: cannot force unwrap value of non-optional type 'String.Index' in solution.swift\n                       let targetRange = target.range(of: changed[original.index(of: original, offsetBy: 0)!], options: [], range: j < n ? (target.index(target.startIndex, offsetBy: j)..<target.endIndex) : nil),\n                                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\nLine 27: Char 88: error: no exact matches in call to instance method 'distance' in solution.swift\n                       target.distance(from: target.startIndex, offsetBy: j) <= target.distance(from: targetRange.lowerBound, offsetBy: 0) {\n                                                                                       ^\nLine 27: Char 39: error: incorrect argument label in call (have 'from:offsetBy:', expected 'from:to:') in solution.swift\n                       target.distance(from: target.startIndex, offsetBy: j) <= target.distance(from: targetRange.lowerBound, offsetBy: 0) {\n                                      ^                         ~~~~~~~~\nLine 27: Char 75: error: cannot convert value of type 'Int' to expected argument type 'String.Index' in solution.swift\n                       target.distance(from: target.startIndex, offsetBy: j) <= target.distance(from: targetRange.lowerBound, offsetBy: 0) {\n                                                                          ^",
    "status_runtime": "N/A",
    "memory": 0,
    "question_id": "3238",
    "task_finish_time": 1708671477636,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": null,
    "total_testcases": null,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Swift",
    "submission_id": "1183758814",
    "status_msg": "Compile Error",
    "state": "SUCCESS",
    "code": "class Solution {\n    func minimumCost(_ source: String, _ target: String, _ original: [String], _ changed: [String], _ cost: [Int]) -> Int {\n        let n = source.count\n        var dp = Array(repeating: Array(repeating: Int.max / 2, count: n + 1), count: n + 1)\n        dp[0][0] = 0\n\n        let sChars = Array(source)\n        let tChars = Array(target)\n\n        var replacements = [String: Int]()\n        for i in 0..<original.count {\n            replacements[original[i], default: Int.max] = min(replacements[original[i], default: Int.max], cost[i])\n        }\n\n        for i in 0...n {\n            for j in 0...n {\n                if i > 0 {\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + (j > 0 && sChars[i - 1] == tChars[j - 1] ? 0 : Int.max / 3))\n                }\n                if j > 0 {\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + Int.max / 3)\n                }\n                for (original, changeCost) in replacements {\n                    if let range = source.range(of: original, options: [], range: i < n ? (source.index(source.startIndex, offsetBy: i)..<source.endIndex) : nil),\n                       source.distance(from: source.startIndex, offsetBy: i) <= source.distance(from: range.lowerBound, offsetBy: 0),\n                       let targetRange = target.range(of: changed[original.index(of: original, offsetBy: 0)!], options: [], range: j < n ? (target.index(target.startIndex, offsetBy: j)..<target.endIndex) : nil),\n                       target.distance(from: target.startIndex, offsetBy: j) <= target.distance(from: targetRange.lowerBound, offsetBy: 0) {\n                        let nextSourceIndex = source.distance(from: source.startIndex, to: range.upperBound)\n                        let nextTargetIndex = target.distance(from: target.startIndex, to: targetRange.upperBound)\n                        dp[nextSourceIndex][nextTargetIndex] = min(dp[nextSourceIndex][nextTargetIndex], dp[i][j] + changeCost)\n                    }\n                }\n            }\n        }\n\n        return dp[n][n] < Int.max / 2 ? dp[n][n] : -1\n    }\n}"
}