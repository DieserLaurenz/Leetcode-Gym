{
    "status_code": 15,
    "lang": "elixir",
    "run_success": false,
    "runtime_error": "Line 6: ** (UndefinedFunctionError) function Array.new/2 is undefined (module Array is not available)",
    "full_runtime_error": "Line 6: ** (UndefinedFunctionError) function Array.new/2 is undefined (module Array is not available)\n    Array.new(5, #Function<1.93164744/0 in Solution.minimum_cost/5>)\n    solution.ex:6: Solution.minimum_cost/5\n    solution.ex:59: Driver.consume_test_cases/2\n    solution.ex:39: Driver.start/0\n    nofile:1: (file)\n    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",
    "status_runtime": "N/A",
    "memory": 76232000,
    "question_id": "3238",
    "elapsed_time": 480,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "expected_output": "28",
    "task_finish_time": 1708673025323,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 647,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1183777109",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec minimum_cost(source :: String.t, target :: String.t, original :: [String.t], changed :: [String.t], cost :: [integer]) :: integer\n  def minimum_cost(source, target, original, changed, cost) do\n    # Create a map of transformations for quick lookup\n    transformations = for {o, c, co} <- Enum.zip(original, Enum.zip(changed, cost)), into: %{}, do: {{o, c}, co}\n    dp = Array.new(String.length(source) + 1, fn -> Map.new() end)\n    dp = Array.set(dp, 0, %{\"\" => 0})\n\n    for i <- 0..String.length(source) do\n      Enum.each(dp |> Array.get(i), fn {s, cs} ->\n        Enum.with_index(target, i-1)\n        |> Enum.each(fn {t, j} ->\n          if i <= j + 1 do\n            to_check = String.slice(target, i-1, j-i+2)\n            if Map.has_key?(transformations, {s, to_check}) do\n              cost = transformations[{s, to_check}]\n              updated_cost = cs + cost\n              existing_cost = Map.get(Array.get(dp, j+1), to_check, :infinity)\n              if updated_cost < existing_cost do\n                new_costs = Map.put(Array.get(dp, j+1), to_check, updated_cost)\n                dp = Array.set(dp, j+1, new_costs)\n              end\n            end\n          end\n        end)\n      end)\n    end\n\n    final_costs = Array.get(dp, String.length(target))\n    case Map.get(final_costs, target) do\n      nil -> -1\n      cost -> cost\n    end\n  end\nend"
}