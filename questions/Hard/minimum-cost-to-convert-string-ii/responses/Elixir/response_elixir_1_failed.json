{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 73340000,
    "question_id": "3238",
    "elapsed_time": 6014,
    "compare_result": "00100100000000000000001001110000000000100100001111111111111111111100001000100011000011110000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "expected_output": "28",
    "task_finish_time": 1708672985981,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 37,
    "total_testcases": 647,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1183776593",
    "input_formatted": "\"abcd\", \"acbe\", [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], [2,5,5,1,2,20]",
    "input": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec minimum_cost(source :: String.t, target :: String.t, original :: [String.t], changed :: [String.t], cost :: [integer]) :: integer\n  def minimum_cost(source, target, original, changed, cost) do\n    transformations = Enum.zip(original, Enum.zip(changed, cost))\n    |> Enum.group_by(fn {from, _} -> from end, fn {_, {to, cost}} -> {to, cost} end)\n\n    dp = :maps.from_list(Enum.map(0..String.length(source), &{&1, -1}))\n    dp = Map.put(dp, 0, 0)\n\n    for i <- 0..String.length(source)-1, reduce: dp do\n      dp ->\n        Enum.reduce(0..String.length(source)-1, dp, fn j, dp ->\n          if i <= j do\n            substring = String.slice(source, i, j-i+1)\n            if Map.has_key?(transformations, substring) do\n              Enum.reduce(Map.get(transformations, substring), dp, fn {changed_str, cost}, dp ->\n                if changed_str == String.slice(target, i, j-i+1) do\n                  prev_cost = Map.get(dp, i, 0)\n                  new_cost = if prev_cost != -1, do: prev_cost + cost, else: -1\n                  current_cost = Map.get(dp, j+1, -1)\n                  if new_cost < current_cost or current_cost == -1 and new_cost != -1 do\n                    Map.put(dp, j+1, new_cost)\n                  else\n                    dp\n                  end\n                else\n                  dp\n                end\n              end)\n            else\n              dp\n            end\n          else\n            dp\n          end\n        end)\n    end\n\n    Map.get(dp, String.length(source))\n  end\nend"
}