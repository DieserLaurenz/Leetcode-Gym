{
    "status_code": 11,
    "lang": "ruby",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 216472000,
    "question_id": "3238",
    "elapsed_time": 3031,
    "compare_result": "00100100000000000000001001110000000000100100001111111111111111111100001000100011000011110000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "expected_output": "28",
    "task_finish_time": 1708672135819,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 37,
    "total_testcases": 647,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Ruby",
    "submission_id": "1183766759",
    "input_formatted": "\"abcd\", \"acbe\", [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], [2,5,5,1,2,20]",
    "input": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "# @param {String} source\n# @param {String} target\n# @param {String[]} original\n# @param {String[]} changed\n# @param {Integer[]} cost\n# @return {Integer}\ndef minimum_cost(source, target, original, changed, cost)\n  # Dynamic programming with memoization for minimum cost calculation\n  memo = {}\n  convert_cost = lambda do |start, last|\n    return 0 if start > last\n    return Float::INFINITY if start == last && source[start] != target[start]\n    return memo[[start, last]] if memo.key?([start, last])\n\n    min_cost = if source[start] == target[start]\n                 convert_cost.call(start + 1, last)\n               else\n                 Float::INFINITY\n               end\n\n    original.each_with_index do |o, idx|\n      c = changed[idx]\n      o_len = o.length\n      next unless start + o_len - 1 <= last && source[start, o_len] == o && target[start, o_len] == c\n\n      cost_before = start > 0 ? convert_cost.call(0, start - 1) : 0\n      cost_after = convert_cost.call(start + o_len, last)\n      total_cost = cost_before + cost[idx] + cost_after\n\n      min_cost = [min_cost, total_cost].min\n    end\n\n    memo[[start, last]] = min_cost\n  end\n\n  # Calculate the minimum cost to convert the entire string\n  final_cost = convert_cost.call(0, source.length - 1)\n  final_cost == Float::INFINITY ? -1 : final_cost\nend"
}