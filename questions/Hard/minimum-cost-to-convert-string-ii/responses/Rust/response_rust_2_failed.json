{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 10068000,
    "question_id": "3238",
    "elapsed_time": 814,
    "compare_result": "00111100000000001001101001110001100000100100001111111111111111111100001000100011000011110000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100000000000000000000100000110010110000011000011111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111110111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "30",
    "std_output": "",
    "last_testcase": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "expected_output": "28",
    "task_finish_time": 1708672522706,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 257,
    "total_testcases": 647,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1183771293",
    "input_formatted": "\"abcd\", \"acbe\", [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], [2,5,5,1,2,20]",
    "input": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn minimum_cost(source: String, target: String, original: Vec<String>, changed: Vec<String>, cost: Vec<i32>) -> i64 {\n        let mut map = std::collections::HashMap::new();\n        for i in 0..original.len() {\n            map.entry((original[i].clone(), changed[i].clone()))\n                .and_modify(|e: &mut i32| *e = std::cmp::min(*e, cost[i]))\n                .or_insert(cost[i]);\n        }\n\n        let mut dp = vec![vec![None; target.len() + 1]; source.len() + 1];\n        dp[0][0] = Some(0);\n\n        for i in 0..=source.len() {\n            for j in 0..=target.len() {\n                if let Some(&cur_cost) = dp[i][j].as_ref() {\n                    if i < source.len() && j < target.len() && source[i..=i] == target[j..=j] {\n                        dp[i + 1][j + 1] = Some(dp[i + 1][j + 1].unwrap_or(i32::MAX).min(cur_cost));\n                    }\n                    for (&(ref o, ref c), &cost) in map.iter() {\n                        if i + o.len() <= source.len() && j + c.len() <= target.len() && &source[i..i + o.len()] == o && &target[j..j + c.len()] == c {\n                            dp[i + o.len()][j + c.len()] = Some(dp[i + o.len()][j + c.len()].unwrap_or(i32::MAX).min(cur_cost + cost));\n                        }\n                    }\n                }\n            }\n        }\n\n        dp[source.len()][target.len()].map(|x| x as i64).unwrap_or(-1)\n    }\n}"
}