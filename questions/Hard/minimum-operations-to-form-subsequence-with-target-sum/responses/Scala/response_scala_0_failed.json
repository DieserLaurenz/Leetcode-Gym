{
    "status_code": 11,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 58540000,
    "question_id": "3025",
    "elapsed_time": 716,
    "compare_result": "1101000110010000101010010000100000010000000010100000000000001000100010001000000011100000101000101010000000000000000000101000000110010101000001000001010000010001000100000000000101010001000100010001000100010001010000010100010100000100000101010001000100010001000101000000000001010101000001010100000000010000000101000100000101000001000100010101000101000000000000000100010100010100000101010001010000010100010100000100010100000100010100000101000001000101000001000101000100010001000001000000010100010000000101010000000000000101000101000000010000000001000101000001010100000100010100000100100100000000011000101011110011010100110100010100000000010010100000000001000101000000101000101010101100000000110011111110111110000001011010100101000000101010010000001000100000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "[1,32,1]\n35",
    "expected_output": "-1",
    "task_finish_time": 1708683468275,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 197,
    "total_testcases": 754,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Scala",
    "submission_id": "1183885002",
    "input_formatted": "[1,32,1], 35",
    "input": "[1,32,1]\n35",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "object Solution {\n    def minOperations(nums: List[Int], target: Int): Int = {\n        val countMap = nums.groupBy(identity).view.mapValues(_.size).toMap\n        var operations = 0\n        var remainingTarget = target\n\n        // Check from the highest power of 2 down to 1\n        for (i <- 30 to 0 by -1) {\n            val powerOfTwo = 1 << i\n            val needed = remainingTarget / powerOfTwo\n            if (countMap.contains(powerOfTwo)) {\n                val available = countMap(powerOfTwo)\n                if (needed <= available) {\n                    remainingTarget -= needed * powerOfTwo\n                } else {\n                    remainingTarget -= available * powerOfTwo\n                    operations += available // Splitting the available ones\n                }\n            }\n            if (remainingTarget > 0 && i > 0) {\n                val toSplit = Math.min((needed - (if (countMap.contains(powerOfTwo)) countMap(powerOfTwo) else 0)) * 2, remainingTarget / (powerOfTwo / 2))\n                if (toSplit > 0) {\n                    operations += toSplit / 2\n                    remainingTarget -= (toSplit / 2) * powerOfTwo\n                }\n            }\n            if (remainingTarget <= 0) return operations\n        }\n        if (remainingTarget > 0) -1 else operations\n    }\n}"
}