{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 5764000,
    "question_id": "3025",
    "elapsed_time": 18,
    "compare_result": "1011010101010101010101110111010111110101010101010101010101011101110111010101110101110111110101110101110111010101010101011101111110101010101110101110101110101110101010101110111010101110111010101010101011101110101010101010101010111011101010101110101010101010111010101110101010101010111010101011101110101110111010111011111010111010101010101010101010101010101111101011101011101010101010101010101110101010101010111011101010111010101010101010111110101010111110101010111011101110111010101110101010101010111010101011111111111010101010111110101111111110101010101110101010101010101011111011110000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101101000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "[1,32,1,2]\n12",
    "expected_output": "2",
    "task_finish_time": 1708682189595,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 372,
    "total_testcases": 754,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1183872085",
    "input_formatted": "[1,32,1,2], 12",
    "input": "[1,32,1,2]\n12",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <limits.h>\n\nint minOperations(int* nums, int numsSize, int target) {\n    long long sum = 0;\n    int maxBit = 0;\n    int ops = 0;\n    for (int i = 0; i < numsSize; ++i) {\n        sum += nums[i];\n        for (int j = 0; j < 31; ++j) {\n            if (nums[i] & (1 << j)) {\n                maxBit = j > maxBit ? j : maxBit;\n                break;\n            }\n        }\n    }\n    if (sum < target) return -1; // Impossible to reach the target\n    for (int i = maxBit; i >= 0 && sum > target; --i) {\n        long long bitVal = 1LL << i;\n        long long excess = sum - target;\n        long long numOfBitsToHalve = (excess + bitVal - 1) / bitVal; // Ceiling of division\n        if (numOfBitsToHalve <= 0) continue;\n        long long opsNeeded = numOfBitsToHalve;\n        sum -= numOfBitsToHalve * bitVal;\n        ops += opsNeeded;\n    }\n    return ops;\n}"
}