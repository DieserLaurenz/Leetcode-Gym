{
    "status_code": 15,
    "lang": "c",
    "run_success": false,
    "runtime_error": "AddressSanitizer: stack-buffer-underflow on address 0x7ffd45a7be1c at pc 0x56448363d767 bp 0x7ffd45a7bda0 sp 0x7ffd45a7bd90",
    "full_runtime_error": "=================================================================\n==22==ERROR: AddressSanitizer: stack-buffer-underflow on address 0x7ffd45a7be1c at pc 0x56448363d767 bp 0x7ffd45a7bda0 sp 0x7ffd45a7bd90\nREAD of size 4 at 0x7ffd45a7be1c thread T0\n    #2 0x7f09aac13d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #3 0x7f09aac13e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\nAddress 0x7ffd45a7be1c is located in stack of thread T0 at offset 28 in frame\n  This frame has 1 object(s):\n    [32, 156) 'count' (line 6) <== Memory access at offset 28 underflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nShadow bytes around the buggy address:\n  0x100028b47770: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100028b47780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100028b47790: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100028b477a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100028b477b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x100028b477c0: f1 f1 f1[f1]00 00 00 00 00 00 00 00 00 00 00 00\n  0x100028b477d0: 00 00 00 04 f3 f3 f3 f3 00 00 00 00 00 00 00 00\n  0x100028b477e0: 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 f1 f1\n  0x100028b477f0: 04 f2 00 f2 f2 f2 00 f2 f2 f2 04 f3 f3 f3 00 00\n  0x100028b47800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100028b47810: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==22==ABORTING",
    "status_runtime": "N/A",
    "memory": 12876000,
    "question_id": "3025",
    "elapsed_time": 47,
    "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[1,2,8]\n7",
    "expected_output": "1",
    "task_finish_time": 1708682255515,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 754,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1183872774",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "int minOperations(int* nums, int numsSize, int target) {\n    long long sum = 0;\n    int count[31] = {0};\n    for (int i = 0; i < numsSize; ++i) {\n        sum += nums[i];\n        int bit = 0;\n        while ((1 << bit) < nums[i]) ++bit;\n        ++count[bit];\n    }\n    if (sum < target) return -1; // If total sum is less than target, impossible to achieve target\n\n    int ops = 0;\n    for (int bit = 30; bit >= 0; --bit) {\n        long long bitValue = 1LL << bit;\n        while (target >= bitValue && count[bit] > 0) {\n            if (target & bitValue) { // If the current bit is set in target\n                target -= bitValue; // Reduce target by the value of the current bit\n            }\n            --count[bit]; // Use one instance of the current power of 2\n            count[bit - 1] += 2; // Split current power of 2 into two instances of the next lower power of 2\n            if (bit > 0) ++ops; // Increment operations if bit > 0, as splitting 1 into 0.5 + 0.5 is not counted as an operation\n        }\n    }\n    return target == 0 ? ops : -1; // Check if the target has been met\n}"
}