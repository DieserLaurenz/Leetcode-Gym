{
    "status_code": 11,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 43588000,
    "question_id": "3025",
    "elapsed_time": 190,
    "compare_result": "0010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "[1,2,8]\n7",
    "expected_output": "1",
    "task_finish_time": 1708682317872,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 3,
    "total_testcases": 754,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C#",
    "submission_id": "1183873415",
    "input_formatted": "[1,2,8], 7",
    "input": "[1,2,8]\n7",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public int MinOperations(IList<int> nums, int target) {\n        Dictionary<int, int> powerCount = new Dictionary<int, int>();\n        foreach (int num in nums) {\n            int power = (int)Math.Log2(num);\n            if (powerCount.ContainsKey(power)) powerCount[power]++;\n            else powerCount[power] = 1;\n        }\n\n        int operations = 0;\n        for (int power = 30; power >= 0 && target > 0; power--) {\n            int valueAtPower = 1 << power;\n            if (powerCount.ContainsKey(power) && powerCount[power] > 0) {\n                int needed = Math.Min(target / valueAtPower, powerCount[power]);\n                target -= needed * valueAtPower;\n                powerCount[power] -= needed;\n            }\n            if (target > 0 && power > 0) {\n                int neededDoubles = (int)Math.Ceiling(target / (double)valueAtPower);\n                int availableDoubles = powerCount.ContainsKey(power - 1) ? powerCount[power - 1] : 0;\n                if (neededDoubles <= availableDoubles * 2) {\n                    int ops = (int)Math.Ceiling(neededDoubles / 2.0);\n                    operations += ops;\n                    target -= ops * valueAtPower * 2;\n                    powerCount[power - 1] -= ops;\n                }\n            }\n        }\n\n        return target == 0 ? operations : -1;\n    }\n}"
}