{
    "status_code": 11,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 57444000,
    "question_id": "3224",
    "elapsed_time": 1032,
    "compare_result": "1010011000010010000000010010001101000110000000000000000001100000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000010000000000000000000000000000001000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "4\n[1]",
    "expected_output": "3",
    "task_finish_time": 1708413836455,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 23,
    "total_testcases": 1000,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Scala",
    "submission_id": "1180710190",
    "input_formatted": "4, [1]",
    "input": "4\n[1]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "object Solution {\n    val mod = 1000000007\n\n    def numberOfSequence(n: Int, sick: Array[Int]): Int = {\n        def factorial(x: Int): Long = (1 to x).foldLeft(1L)((acc, i) => acc * i % mod)\n\n        def combinations(n: Int, r: Int): Long = {\n            if (r == 0 || n == r) 1\n            else factorial(n) * modInverse(factorial(r) * factorial(n - r) % mod) % mod\n        }\n\n        def modInverse(a: Long, m: Long = mod): Long = {\n            var m0 = m\n            var y = 0L\n            var x = 1L\n            if (m == 1) return 0\n            var a0 = a\n            while (a0 > 1) {\n                val q = a0 / m0\n                var t = m0\n                m0 = a0 % m0\n                a0 = t\n                t = y\n                y = x - q * y\n                x = t\n            }\n            if (x < 0) x += m\n            x\n        }\n\n        def countWays(gap: Int): Long = {\n            if (gap <= 0) return 1\n            (2 to gap).foldLeft(1L)((acc, _) => acc * 2 % mod)\n        }\n\n        (sick :+ n).zip(0 +: sick).map { case (curr, prev) => countWays(curr - prev - 1) }.foldLeft(1L)((acc, ways) => acc * ways % mod).toInt\n    }\n}"
}