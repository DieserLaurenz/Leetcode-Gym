{
    "status_code": 11,
    "lang": "swift",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 15464000,
    "question_id": "3224",
    "elapsed_time": 86,
    "compare_result": "1000010000010010000000111011000001000110000000000000000001100000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000010000000000000000000000000000001000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "4",
    "std_output": "",
    "last_testcase": "4\n[1]",
    "expected_output": "3",
    "task_finish_time": 1708413125267,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 21,
    "total_testcases": 1000,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Swift",
    "submission_id": "1180700546",
    "input_formatted": "4, [1]",
    "input": "4\n[1]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    func numberOfSequence(_ n: Int, _ sick: [Int]) -> Int {\n        let mod = 1000000007\n        func factorial(_ n: Int) -> Int {\n            return (1...n).reduce(1) { ($0 * $1) % mod }\n        }\n        \n        func combinations(_ n: Int, _ k: Int) -> Int {\n            return factorial(n) * modInverse(factorial(k) * factorial(n - k) % mod) % mod\n        }\n        \n        func modInverse(_ a: Int) -> Int {\n            var (a, m, m0, x0, x1) = (a, mod, mod, 0, 1)\n            if m == 1 { return 0 }\n            while a > 1 {\n                let q = a / m\n                (m, a) = (a % m, m)\n                (x0, x1) = (x1 - q * x0, x0)\n            }\n            if x1 < 0 { x1 += m0 }\n            return x1\n        }\n        \n        func powMod(_ base: Int, _ exponent: Int) -> Int {\n            var (base, exponent, result) = (base % mod, exponent, 1)\n            while exponent > 0 {\n                if exponent % 2 == 1 {\n                    result = result * base % mod\n                }\n                base = base * base % mod\n                exponent /= 2\n            }\n            return result\n        }\n        \n        var total = 1\n        if sick.first! > 0 {\n            total = total * powMod(2, sick.first! - 1) % mod\n        }\n        if sick.last! < n - 1 {\n            total = total * powMod(2, n - 1 - sick.last!) % mod\n        }\n        for i in 1..<sick.count {\n            let gap = sick[i] - sick[i - 1] - 1\n            if gap > 0 {\n                total = total * powMod(2, gap - 1) % mod\n            }\n        }\n        return total\n    }\n}"
}