{
    "status_code": 11,
    "lang": "racket",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 124824000,
    "question_id": "3224",
    "elapsed_time": 724,
    "compare_result": "0100010001000101000010000001111000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "24",
    "std_output": "",
    "last_testcase": "5\n[0,4]",
    "expected_output": "4",
    "task_finish_time": 1708414145183,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 13,
    "total_testcases": 1000,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1180714378",
    "input_formatted": "5, [0,4]",
    "input": "5\n[0,4]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "(define/contract (number-of-sequence n sick)\n  (-> exact-integer? (listof exact-integer?) exact-integer?)\n\n  (define mod 1000000007)\n\n  (define (factorial n)\n    (let loop ((i n) (res 1))\n      (if (= i 0)\n          res\n          (loop (- i 1) (modulo (* res i) mod)))))\n\n  (define (mod-inverse a m)\n    (let loop ((b a) (m m) (x 0) (y 1))\n      (if (= b 0)\n          x\n          (loop (modulo m b) b y (modulo (- x (* y (quotient m b))) m)))))\n\n  (define (nCr n k)\n    (if (> k n)\n        0\n        (let* ((num (factorial n))\n               (denom (modulo (* (factorial k) (factorial (- n k))) mod))\n               (inv-denom (mod-inverse denom mod)))\n          (modulo (* num inv-denom) mod))))\n\n  (define (calc-ways gaps)\n    (foldl (lambda (gap acc)\n             (modulo (* acc (nCr (+ gap 1) 1)) mod))\n           1\n           gaps))\n\n  (define (sick-gaps sick n)\n    (let loop ((sick sick) (prev (car sick)) (acc '()))\n      (if (null? (cdr sick))\n          (reverse (cons (- n 1 (car sick)) acc))\n          (let ((next (cadr sick)))\n            (loop (cdr sick) next (cons (- next prev 1) acc))))))\n\n  (calc-ways (sick-gaps sick n)))"
}