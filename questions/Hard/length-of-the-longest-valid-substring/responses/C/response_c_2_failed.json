{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 5984000,
    "question_id": "2884",
    "elapsed_time": 3010,
    "compare_result": "1011111111111111111111111111111111111111111111111111111111111111111111111111111111111101010111011110111111111111111101111111111011111111111111101111010111011111011111111110101111110111111101010011110110011100110110110010100110100110101110111011100110111111001101001010000111000000101100110110000000110100111110010001100100011011000100110100110011100011000000110100101101011000101011010111100011011101111000111111101010111001111111111101111000110000011111100101010000101011110110111011110011011110001111100111110110000110111111000101110111001000111111011101110111111111010001111100000000010100000000000010011100110000001001010000010000100000100010000001000000100001000001100000011000000000000000010000110000000000000000000000000000000000000000000000000000000000000",
    "code_output": "3",
    "std_output": "",
    "last_testcase": "\"leetcode\"\n[\"de\",\"le\",\"e\"]",
    "expected_output": "4",
    "task_finish_time": 1708515184747,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 422,
    "total_testcases": 763,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1181926234",
    "input_formatted": "\"leetcode\", [\"de\",\"le\",\"e\"]",
    "input": "\"leetcode\"\n[\"de\",\"le\",\"e\"]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <string.h>\n#include <stdbool.h>\n\nint longestValidSubstring(char *word, char **forbidden, int forbiddenSize) {\n    int maxLen = 0;\n    int wordLen = strlen(word);\n\n    for (int start = 0; start < wordLen; ++start) {\n        for (int end = start; end < wordLen; ++end) {\n            bool isValid = true;\n            for (int f = 0; f < forbiddenSize; ++f) {\n                const char *found = strstr(word + start, forbidden[f]);\n                if (found != NULL && found - word < end + 1) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid) {\n                int currentLen = end - start + 1;\n                if (currentLen > maxLen) {\n                    maxLen = currentLen;\n                }\n            } else {\n                // Once an invalid substring is found, no need to check longer substrings starting from the same position\n                break;\n            }\n        }\n    }\n\n    return maxLen;\n}"
}