{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 50424000,
    "question_id": "2884",
    "elapsed_time": 4012,
    "compare_result": "0000100100100100100100100100100100100100100100100100100100100100101110100100100111111100010101011110011111111101110001101111110001001110000101001011010111011111011100111110001000010000000000000000000000000000000000010000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100001010000100000000010000010100001110000000000001000000000001000100001000000000010000100000000100000000100000011100001010100000100000010000000000000000000100001000000010000000000010000011100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000110111111110101111110000000000111111111111111110000000000000000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "\"cbaaaabc\"\n[\"aaa\",\"cb\"]",
    "expected_output": "4",
    "task_finish_time": 1708514826238,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 159,
    "total_testcases": 763,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1181922409",
    "input_formatted": "\"cbaaaabc\", [\"aaa\",\"cb\"]",
    "input": "\"cbaaaabc\"\n[\"aaa\",\"cb\"]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestValidSubstring(string word, vector<string>& forbidden) {\n        int n = word.length();\n        vector<int> dp(n + 1, 0); // dp[i] represents the length of the longest valid substring ending at position i - 1\n        int maxLen = 0;\n\n        for (int i = 1; i <= n; ++i) {\n            dp[i] = dp[i - 1] + 1; // Assume the current character extends the previous valid substring\n            for (const string& f : forbidden) {\n                if (i >= f.length() && word.substr(i - f.length(), f.length()) == f) {\n                    dp[i] = 0; // If the current substring ends with a forbidden string, reset it\n                    break;\n                }\n                if (i >= f.length()) {\n                    dp[i] = min(dp[i], dp[i - f.length()]); // Adjust the length to exclude the forbidden substring\n                }\n            }\n            maxLen = max(maxLen, dp[i]); // Update the maximum length found so far\n        }\n\n        return maxLen;\n    }\n};"
}