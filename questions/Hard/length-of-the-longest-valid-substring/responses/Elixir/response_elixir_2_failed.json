{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 82632000,
    "question_id": "2884",
    "elapsed_time": 6017,
    "compare_result": "0100100100100100100100100100100100100100100100100100100100100100101110100100100111111111111111111111011111111101110111101111110111101110111111011011111111111111111101111111011011011011001110101101011011100111101001011111011011111011010001010101111001011010110011110111111100111111110011001111111111101111001001111110011011110110111111011011001110111100111111001111110010101111010101111101111101110010101111100010011111100111111011001010101111101111111001111011111111110100101111101100111110101111111111111101011111111101100110111011011100110111111001110110111010010010111110011111111111101011111111111101101011001111110110111111101111011111011111111110111111011110111111011111110100000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "3",
    "std_output": "",
    "last_testcase": "\"cbaaaabc\"\n[\"aaa\",\"cb\"]",
    "expected_output": "4",
    "task_finish_time": 1708525359925,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 480,
    "total_testcases": 763,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1182048883",
    "input_formatted": "\"cbaaaabc\", [\"aaa\",\"cb\"]",
    "input": "\"cbaaaabc\"\n[\"aaa\",\"cb\"]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec longest_valid_substring(word :: String.t, forbidden :: [String.t]) :: integer\n  def longest_valid_substring(word, forbidden) do\n    check_forbidden = fn substring ->\n      Enum.any?(forbidden, &String.contains?(substring, &1))\n    end\n\n    max_length = Enum.reduce(0..String.length(word) - 1, {0, 0}, fn _, {max_len, start} ->\n      valid = Enum.reduce_while(start..String.length(word) - 1, true, fn end_pos, _acc ->\n        if check_forbidden.(String.slice(word, start, end_pos - start + 1)) do\n          {:halt, false}\n        else\n          {:cont, true}\n        end\n      end)\n\n      if valid do\n        {max_len, start + 1}\n      else\n        new_max = Enum.reduce(start..String.length(word) - 1, 0, fn end_pos, acc ->\n          if not check_forbidden.(String.slice(word, start, end_pos - start + 1)) do\n            max(acc, end_pos - start + 1)\n          else\n            acc\n          end\n        end)\n\n        {max(max_len, new_max), start + 1}\n      end\n    end)\n    |> elem(0)\n\n    max_length\n  end\nend"
}