{
    "status_code": 11,
    "lang": "swift",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 20144000,
    "question_id": "3107",
    "elapsed_time": 857,
    "compare_result": "00110010100000011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010",
    "code_output": "165",
    "std_output": "",
    "last_testcase": "[[8,5,2],[6,4,1],[9,7,3]]",
    "expected_output": "285",
    "task_finish_time": 1708618110642,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 9,
    "total_testcases": 779,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Swift",
    "submission_id": "1183176787",
    "input_formatted": "[[8,5,2],[6,4,1],[9,7,3]]",
    "input": "[[8,5,2],[6,4,1],[9,7,3]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    func maxSpending(_ values: [[Int]]) -> Int {\n        var maxHeap = Heap<(Int, Int)>(sort: { $0.0 > $1.0 })\n        var day = 1\n        var total = 0\n\n        for i in 0..<values.count {\n            for j in 0..<values[i].count {\n                maxHeap.insert((values[i][j], 1))\n            }\n        }\n\n        while !maxHeap.isEmpty {\n            let (value, d) = maxHeap.remove()!\n            total += value * day\n            day += 1\n        }\n\n        return total\n    }\n}\n\nstruct Heap<T> {\n    var nodes = [T]()\n    private var orderCriteria: (T, T) -> Bool\n\n    init(sort: @escaping (T, T) -> Bool) {\n        self.orderCriteria = sort\n    }\n\n    var isEmpty: Bool {\n        return nodes.isEmpty\n    }\n\n    var count: Int {\n        return nodes.count\n    }\n\n    func peek() -> T? {\n        return nodes.first\n    }\n\n    func leftChildIndex(ofParentAt index: Int) -> Int {\n        return (2 * index) + 1\n    }\n\n    func rightChildIndex(ofParentAt index: Int) -> Int {\n        return (2 * index) + 2\n    }\n\n    func parentIndex(ofChildAt index: Int) -> Int {\n        return (index - 1) / 2\n    }\n\n    mutating func insert(_ value: T) {\n        nodes.append(value)\n        siftUp(from: nodes.count - 1)\n    }\n\n    mutating func siftUp(from index: Int) {\n        var childIndex = index\n        let child = nodes[childIndex]\n        var parentIndex = self.parentIndex(ofChildAt: childIndex)\n\n        while childIndex > 0 && orderCriteria(child, nodes[parentIndex]) {\n            nodes[childIndex] = nodes[parentIndex]\n            childIndex = parentIndex\n            parentIndex = self.parentIndex(ofChildAt: childIndex)\n        }\n\n        nodes[childIndex] = child\n    }\n\n    mutating func remove() -> T? {\n        guard !nodes.isEmpty else { return nil }\n\n        if nodes.count == 1 {\n            return nodes.removeLast()\n        } else {\n            let value = nodes[0]\n            nodes[0] = nodes.removeLast()\n            siftDown(from: 0)\n            return value\n        }\n    }\n\n    mutating func siftDown(from index: Int) {\n        var parentIndex = index\n        while true {\n            let leftChildIndex = self.leftChildIndex(ofParentAt: parentIndex)\n            let rightChildIndex = self.rightChildIndex(ofParentAt: parentIndex)\n            var optionalSwapIndex: Int?\n\n            if leftChildIndex < nodes.count && orderCriteria(nodes[leftChildIndex], nodes[parentIndex]) {\n                optionalSwapIndex = leftChildIndex\n            }\n\n            if rightChildIndex < nodes.count && orderCriteria(nodes[rightChildIndex], nodes[optionalSwapIndex ?? parentIndex]) {\n                optionalSwapIndex = rightChildIndex\n            }\n\n            guard let swapIndex = optionalSwapIndex else { return }\n\n            nodes.swapAt(parentIndex, swapIndex)\n            parentIndex = swapIndex\n        }\n    }\n}"
}