{
    "acRate": 44.90120146956608,
    "difficulty": "Hard",
    "freqBar": null,
    "frontendQuestionId": "2791",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Count Paths That Can Form a Palindrome in a Tree",
    "titleSlug": "count-paths-that-can-form-a-palindrome-in-a-tree",
    "topicTags": [
        {
            "name": "Dynamic Programming",
            "id": "VG9waWNUYWdOb2RlOjEz",
            "slug": "dynamic-programming"
        },
        {
            "name": "Bit Manipulation",
            "id": "VG9waWNUYWdOb2RlOjE5",
            "slug": "bit-manipulation"
        },
        {
            "name": "Tree",
            "id": "VG9waWNUYWdOb2RlOjIw",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "id": "VG9waWNUYWdOb2RlOjIx",
            "slug": "depth-first-search"
        },
        {
            "name": "Bitmask",
            "id": "VG9waWNUYWdOb2RlOjYxMDc4",
            "slug": "bitmask"
        }
    ],
    "hasSolution": false,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Solution { public:     long long countPalindromePaths(vector<int>& parent, string s) {              } };"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {     public long countPalindromePaths(List<Integer> parent, String s) {              } }"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Solution(object):     def countPalindromePaths(self, parent, s):         \"\"\"         :type parent: List[int]         :type s: str         :rtype: int         \"\"\"         "
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Solution:     def countPalindromePaths(self, parent: List[int], s: str) -> int:         "
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "long long countPalindromePaths(int* parent, int parentSize, char * s){  }"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Solution {     public long CountPalindromePaths(IList<int> parent, string s) {              } }"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * @param {number[]} parent  * @param {string} s  * @return {number}  */ var countPalindromePaths = function(parent, s) {      };"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "function countPalindromePaths(parent: number[], s: string): number {  };"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Solution {      /**      * @param Integer[] $parent      * @param String $s      * @return Integer      */     function countPalindromePaths($parent, $s) {              } }"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Solution {     func countPalindromePaths(_ parent: [Int], _ s: String) -> Int {              } }"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Solution {     fun countPalindromePaths(parent: List<Int>, s: String): Long {              } }"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Solution {   int countPalindromePaths(List<int> parent, String s) {    } }"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "func countPalindromePaths(parent []int, s string) int64 {      }"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# @param {Integer[]} parent # @param {String} s # @return {Integer} def count_palindrome_paths(parent, s)      end"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "object Solution {     def countPalindromePaths(parent: List[Int], s: String): Long = {              } }"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "impl Solution {     pub fn count_palindrome_paths(parent: Vec<i32>, s: String) -> i64 {              } }"
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define/contract (count-palindrome-paths parent s)   (-> (listof exact-integer?) string? exact-integer?)    )"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec count_palindrome_paths(Parent :: [integer()], S :: unicode:unicode_binary()) -> integer(). count_palindrome_paths(Parent, S) ->   ."
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Solution do   @spec count_palindrome_paths(parent :: [integer], s :: String.t) :: integer   def count_palindrome_paths(parent, s) do    end end"
        }
    ],
    "content": "You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1. You are also given a string s of length n, where s[i] is the character assigned to the edge between i and parent[i]. s[0] can be ignored. Return the number of pairs of nodes (u, v) such that u < v and the characters assigned to edges on the path from u to v can be rearranged to form a palindrome. A string is a palindrome when it reads the same backwards as forwards.  Example 1:   Input: parent = [-1,0,0,1,1,2], s = \"acaabc\" Output: 8 Explanation: The valid pairs are: - All the pairs (0,1), (0,2), (1,3), (1,4) and (2,5) result in one character which is always a palindrome. - The pair (2,3) result in the string \"aca\" which is a palindrome. - The pair (1,5) result in the string \"cac\" which is a palindrome. - The pair (3,5) result in the string \"acac\" which can be rearranged into the palindrome \"acca\".  Example 2:  Input: parent = [-1,0,0,0,0], s = \"aaaaa\" Output: 10 Explanation: Any pair of nodes (u,v) where u < v is valid.   Constraints:  n == parent.length == s.length 1 <= n <= 105 0 <= parent[i] <= n - 1 for all i >= 1 parent[0] == -1 parent represents a valid tree. s consists of only lowercase English letters.  "
}