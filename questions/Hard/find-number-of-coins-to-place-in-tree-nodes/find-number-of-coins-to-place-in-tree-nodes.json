{
    "acRate": 32.602161020391584,
    "difficulty": "Hard",
    "freqBar": null,
    "frontendQuestionId": "2973",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Find Number of Coins to Place in Tree Nodes",
    "titleSlug": "find-number-of-coins-to-place-in-tree-nodes",
    "topicTags": [
        {
            "name": "Dynamic Programming",
            "id": "VG9waWNUYWdOb2RlOjEz",
            "slug": "dynamic-programming"
        },
        {
            "name": "Tree",
            "id": "VG9waWNUYWdOb2RlOjIw",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "id": "VG9waWNUYWdOb2RlOjIx",
            "slug": "depth-first-search"
        },
        {
            "name": "Sorting",
            "id": "VG9waWNUYWdOb2RlOjYxMDQ5",
            "slug": "sorting"
        },
        {
            "name": "Heap (Priority Queue)",
            "id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "slug": "heap-priority-queue"
        }
    ],
    "hasSolution": false,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "code": "class Solution { public:     vector<long long> placedCoins(vector<vector<int>>& edges, vector<int>& cost) {              } };"
        },
        {
            "code": "class Solution {     public long[] placedCoins(int[][] edges, int[] cost) {              } }"
        },
        {
            "code": "class Solution(object):     def placedCoins(self, edges, cost):         \"\"\"         :type edges: List[List[int]]         :type cost: List[int]         :rtype: List[int]         \"\"\"         "
        },
        {
            "code": "class Solution:     def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:         "
        },
        {
            "code": "/**  * Note: The returned array must be malloced, assume caller calls free().  */ long long* placedCoins(int** edges, int edgesSize, int* edgesColSize, int* cost, int costSize, int* returnSize) {      }"
        },
        {
            "code": "public class Solution {     public long[] PlacedCoins(int[][] edges, int[] cost) {              } }"
        },
        {
            "code": "/**  * @param {number[][]} edges  * @param {number[]} cost  * @return {number[]}  */ var placedCoins = function(edges, cost) {      };"
        },
        {
            "code": "function placedCoins(edges: number[][], cost: number[]): number[] {      };"
        },
        {
            "code": "class Solution {      /**      * @param Integer[][] $edges      * @param Integer[] $cost      * @return Integer[]      */     function placedCoins($edges, $cost) {              } }"
        },
        {
            "code": "class Solution {     func placedCoins(_ edges: [[Int]], _ cost: [Int]) -> [Int] {              } }"
        },
        {
            "code": "class Solution {     fun placedCoins(edges: Array<IntArray>, cost: IntArray): LongArray {              } }"
        },
        {
            "code": "class Solution {   List<int> placedCoins(List<List<int>> edges, List<int> cost) {        } }"
        },
        {
            "code": "func placedCoins(edges [][]int, cost []int) []int64 {      }"
        },
        {
            "code": "# @param {Integer[][]} edges # @param {Integer[]} cost # @return {Integer[]} def placed_coins(edges, cost)      end"
        },
        {
            "code": "object Solution {     def placedCoins(edges: Array[Array[Int]], cost: Array[Int]): Array[Long] = {              } }"
        },
        {
            "code": "impl Solution {     pub fn placed_coins(edges: Vec<Vec<i32>>, cost: Vec<i32>) -> Vec<i64> {              } }"
        },
        {
            "code": "(define/contract (placed-coins edges cost)   (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))   )"
        },
        {
            "code": "-spec placed_coins(Edges :: [[integer()]], Cost :: [integer()]) -> [integer()]. placed_coins(Edges, Cost) ->   ."
        },
        {
            "code": "defmodule Solution do   @spec placed_coins(edges :: [[integer]], cost :: [integer]) :: [integer]   def placed_coins(edges, cost) do        end end"
        }
    ],
    "content": "You are given an undirected tree with n nodes labeled from 0 to n - 1, and rooted at node 0. You are given a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given a 0-indexed integer array cost of length n, where cost[i] is the cost assigned to the ith node. You need to place some coins on every node of the tree. The number of coins to be placed at node i can be calculated as:  If size of the subtree of node i is less than 3, place 1 coin. Otherwise, place an amount of coins equal to the maximum product of cost values assigned to 3 distinct nodes in the subtree of node i. If this product is negative, place 0 coins.  Return an array coin of size n such that coin[i] is the number of coins placed at node i.  Example 1:   Input: edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6] Output: [120,1,1,1,1,1] Explanation: For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.  Example 2:   Input: edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2] Output: [280,140,32,1,1,1,1,1,1] Explanation: The coins placed on each node are: - Place 8 * 7 * 5 = 280 coins on node 0. - Place 7 * 5 * 4 = 140 coins on node 1. - Place 8 * 2 * 2 = 32 coins on node 2. - All other nodes are leaves with subtree of size 1, place 1 coin on each of them.  Example 3:   Input: edges = [[0,1],[0,2]], cost = [1,2,-2] Output: [0,1,1] Explanation: Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.   Constraints:  2 <= n <= 2 * 104 edges.length == n - 1 edges[i].length == 2 0 <= ai, bi < n cost.length == n 1 <= |cost[i]| <= 104 The input is generated such that edges represents a valid tree.  "
}