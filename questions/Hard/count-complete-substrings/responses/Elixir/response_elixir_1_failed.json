{
    "status_code": 20,
    "lang": "elixir",
    "run_success": false,
    "compile_error": "",
    "full_compile_error": "** (ArgumentError) cannot pipe byte_size(word) |> Kernel.min(i + k - 1, &1) |> Kernel.max(j) into an anonymous function without calling the function; use Kernel.then/2 instead or define the anonymous function as a regular private function\n    (elixir 1.15.7) lib/macro.ex:328: Macro.pipe/3\n    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3\n    (elixir 1.15.7) expanding macro: Kernel.|>/2\nLine 7:     Solution.count_complete_substrings/2\n    (elixir 1.15.7) expanding macro: Kernel.|>/2\nLine 5:     Solution.count_complete_substrings/2",
    "status_runtime": "N/A",
    "memory": 0,
    "question_id": "3223",
    "task_finish_time": 1708308538427,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": null,
    "total_testcases": null,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1179360854",
    "status_msg": "Compile Error",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec count_complete_substrings(word :: String.t, k :: integer) :: integer\n  def count_complete_substrings(word, k) do\n    1..(byte_size(word) - k + 1)\n    |> Enum.reduce(0, fn i, acc ->\n      acc + Enum.count(1..(byte_size(word) - k + 1), fn j ->\n        substring = byte_size(word) |> Kernel.min(i + k - 1, &1) |> Kernel.max(j) |> fn end_pos -> String.slice(word, j - 1, end_pos - j + 1) end\n        valid_substring?(substring, k)\n      end)\n    end)\n  end\n\n  defp valid_substring?(substring, k) do\n    counts = Enum.reduce(substring |> String.graphemes(), %{}, fn char, acc ->\n      Map.update(acc, char, 1, &(&1 + 1))\n    end)\n\n    valid_counts = Enum.all?(counts, fn {_char, count} -> count == k end)\n    valid_chars = Enum.all?(String.graphemes(substring), fn char ->\n      next_char = String.next_codepoint(char)\n      prev_char = String.previous_codepoint(char)\n\n      Enum.any?(String.graphemes(substring), fn other_char ->\n        other_char == char || other_char == next_char || other_char == prev_char\n      end)\n    end)\n\n    valid_counts and valid_chars\n  end\n\n  defp String.next_codepoint(char) do\n    [codepoint] = char |> String.to_charlist()\n    [codepoint + 1] |> List.to_string()\n  end\n\n  defp String.previous_codepoint(char) do\n    [codepoint] = char |> String.to_charlist()\n    [codepoint - 1] |> List.to_string()\n  end\nend"
}