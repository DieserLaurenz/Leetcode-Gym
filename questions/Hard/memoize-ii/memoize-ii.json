{
    "acRate": 31.79516972362852,
    "difficulty": "Hard",
    "freqBar": null,
    "frontendQuestionId": "2630",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Memoize II",
    "titleSlug": "memoize-ii",
    "topicTags": [],
    "hasSolution": true,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * @param {Function} fn  * @return {Function}  */ function memoize(fn) {          return function() {              } }   /**   * let callCount = 0;  * const memoizedFn = memoize(function (a, b) {  *  callCount += 1;  *   return a + b;  * })  * memoizedFn(2, 3) // 5  * memoizedFn(2, 3) // 5  * console.log(callCount) // 1   */"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "type Fn = (...params: any) => any  function memoize(fn: Fn): Fn {          return function() {              } }   /**   * let callCount = 0;  * const memoizedFn = memoize(function (a, b) {  *  callCount += 1;  *   return a + b;  * })  * memoizedFn(2, 3) // 5  * memoizedFn(2, 3) // 5  * console.log(callCount) // 1   */"
        }
    ],
    "content": "Given a function fn,returnamemoizedversion of that function. Amemoizedfunction is a function that will never be called twice withthe same inputs. Instead it will returna cached value. fncan be any function and there are no constraints on what type of values it accepts. Inputs are considered identical if they are=== to each other.  Example 1:  Input:  getInputs = () => [[2,2],[2,2],[1,2]] fn = function (a, b) { return a + b; } Output: [{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}] Explanation: const inputs = getInputs(); const memoized = memoize(fn); for (const arr of inputs) {   memoized(...arr); }  For the inputs of (2, 2): 2 + 2 = 4, and it required a call to fn(). For the inputs of (2, 2): 2 + 2 = 4, but those inputs were seen before so no call to fn() was required. For the inputs of (1, 2): 1 + 2 = 3, and it required another call to fn() for a total of 2.  Example 2:  Input:  getInputs = () => [[{},{}],[{},{}],[{},{}]]  fn = function (a, b) { return ({...a, ...b}); } Output: [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}] Explanation: Merging two empty objects will always result in an empty object. It may seem like there should only be 1call to fn() because of cache-hits, however none of those objects are === to each other.  Example 3:  Input:  getInputs = () => { const o = {}; return [[o,o],[o,o],[o,o]]; } fn = function (a, b) { return ({...a, ...b}); } Output: [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}] Explanation: Merging two empty objects will always result in an empty object. The 2nd and 3rd third function calls result in a cache-hit. This is because every object passed in is identical.   Constraints:  1 <= inputs.length <= 105 0 <= inputs.flat().length <= 105 inputs[i][j] != NaN  "
}