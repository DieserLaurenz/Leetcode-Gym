{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 6488000,
    "question_id": "2826",
    "elapsed_time": 112,
    "compare_result": "0010000001000100000011100000000000100110001000000000010010001001110000000100001000100010000001000000000100000101001000010010100000000000010000011110001000100001000001000100011011101100000000000000101100110000100010000000011001001000100100001000101000101001010000111010100000000000000011000000000010100010000000000000100100001100000000000001010001100100101101010110000110100011000000000001000001000001010000000010000000000011000110011000000010010000000001010001000000000000100000000011000011011011000001000000000000010000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001100010000000000000000000000000000000101",
    "code_output": "[]",
    "std_output": "",
    "last_testcase": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "expected_output": "[0,1]",
    "task_finish_time": 1708454512140,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 130,
    "total_testcases": 685,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1181260449",
    "input_formatted": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "input": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn good_subsetof_binary_matrix(grid: Vec<Vec<i32>>) -> Vec<i32> {\n        let m = grid.len();\n        let n = grid[0].len();\n        let mut dp = vec![vec![false; 1 << n]; m + 1];\n        let mut prev = vec![vec![0; 1 << n]; m + 1];\n        dp[0][0] = true;\n\n        for i in 1..=m {\n            for mask in 0..(1 << n) {\n                dp[i][mask] = dp[i - 1][mask];\n                if dp[i][mask] {\n                    prev[i][mask] = mask;\n                }\n                let mut new_mask = 0;\n                let mut valid = true;\n                for j in 0..n {\n                    if grid[i - 1][j] == 1 {\n                        if (mask >> j) & 1 == 1 {\n                            valid = false;\n                            break;\n                        } else {\n                            new_mask |= 1 << j;\n                        }\n                    }\n                }\n                if valid && dp[i - 1][mask ^ new_mask] {\n                    dp[i][mask] = true;\n                    prev[i][mask] = mask ^ new_mask;\n                }\n            }\n        }\n\n        for mask in (0..(1 << n)).rev() {\n            if dp[m][mask] {\n                let mut res = vec![];\n                let mut cur_mask = mask;\n                for i in (1..=m).rev() {\n                    if prev[i][cur_mask] != cur_mask {\n                        res.push((i - 1) as i32);\n                        cur_mask = prev[i][cur_mask];\n                    }\n                }\n                res.reverse();\n                return res;\n            }\n        }\n\n        vec![]\n    }\n}"
}