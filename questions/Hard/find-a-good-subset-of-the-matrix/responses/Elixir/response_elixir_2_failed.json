{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 986088000,
    "question_id": "2826",
    "elapsed_time": 1306,
    "compare_result": "0111000111111100010011101100011010100111011011111100011010111111111111001111011001111010000001000011000101101111111111010111110011101101110000011110011100100011000001011111111011111111110010010100111111111011111110111011111011011110101110011001111011101011011111111110101010011010111011010100011110101111010101001011101110111110011111100011011001101111101101111111101111110111001101001001111011011101011000101010001100110011000110111100100111110100001001010001001101011101111111111111000111111111110011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "[1,0]",
    "std_output": "",
    "last_testcase": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "expected_output": "[0,1]",
    "task_finish_time": 1708455020485,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 322,
    "total_testcases": 685,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1181267587",
    "input_formatted": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "input": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec good_subsetof_binary_matrix(grid :: [[integer]]) :: [integer]\n  def good_subsetof_binary_matrix(grid) do\n    (1..length(grid))\n    |> Enum.flat_map(fn size -> Enum.filter(combinations(Enum.to_list(0..length(grid) - 1), size), &good_subset?(grid, &1)) end)\n    |> Enum.sort()\n    |> List.first()\n    |> case do\n      nil -> []\n      good_subset -> good_subset\n    end\n  end\n\n  defp combinations(enum, k), do: Enum.reduce(enum, [[]], fn x, acc -> acc ++ Enum.map(acc, fn c -> [x | c] end) end) |> Enum.filter(&(&1 |> length() == k))\n\n  defp good_subset?(grid, indices) do\n    subset = Enum.map(indices, fn index -> Enum.at(grid, index) end)\n    cols = length(List.first(grid))\n    1..cols\n    |> Enum.all?(fn col ->\n      sum = Enum.map(subset, fn row -> Enum.at(row, col - 1) end) |> Enum.sum()\n      sum <= div(length(indices), 2)\n    end)\n  end\nend"
}