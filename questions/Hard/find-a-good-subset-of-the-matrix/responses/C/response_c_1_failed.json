{
    "status_code": 14,
    "lang": "c",
    "run_success": false,
    "status_runtime": "N/A",
    "memory": 5556000,
    "question_id": "2826",
    "elapsed_time": 3008,
    "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[[1,0,1],[0,1,1],[0,1,0],[1,1,0],[1,1,0],[0,1,0],[1,1,1],[0,1,1],[1,0,1],[0,1,0],[0,0,1],[0,0,0],[0,1,0],[0,0,0],[1,0,0],[1,1,1],[0,0,1],[0,0,0],[1,1,0],[0,1,1],[0,1,1],[1,1,0],[1,0,0],[1,0,1],[1,1,0],[0,0,0]]",
    "expected_output": "[11]",
    "task_finish_time": 1708444902362,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 503,
    "total_testcases": 685,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1181098510",
    "status_msg": "Time Limit Exceeded",
    "state": "SUCCESS",
    "code": "#include <stdlib.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize){\n    *returnSize = 0;\n    // Check if there's no grid or column size is zero.\n    if (gridSize == 0 || *gridColSize == 0) {\n        return NULL;\n    }\n\n    // Allocate memory to store the subset of rows. In the worst case, all rows can be part of the subset.\n    int* subset = (int*)malloc(sizeof(int) * gridSize);\n    if (!subset) {\n        return NULL; // Return NULL if memory allocation fails.\n    }\n\n    int maxSubsetSize = 0; // Maximum size of a good subset found so far.\n\n    // Iterate over all possible subsets using bitwise representation (2^gridSize possibilities).\n    for (int subsetMask = 1; subsetMask < (1 << gridSize); ++subsetMask) {\n        int currentSubsetSize = 0; // Size of the current subset being considered.\n        int sumCol[*gridColSize]; // Sum of each column in the current subset.\n        for (int j = 0; j < *gridColSize; ++j) {\n            sumCol[j] = 0;\n        }\n\n        // Iterate through each row to check if it is part of the current subset.\n        for (int row = 0; row < gridSize; ++row) {\n            if (subsetMask & (1 << row)) { // Check if the row is part of the current subset.\n                currentSubsetSize++;\n                for (int col = 0; col < *gridColSize; ++col) {\n                    sumCol[col] += grid[row][col]; // Add the cell value to the column sum.\n                }\n            }\n        }\n\n        // Check if the current subset is a good subset.\n        int isGoodSubset = 1; // Flag to check if the current subset is good.\n        for (int col = 0; col < *gridColSize; ++col) {\n            if (sumCol[col] > currentSubsetSize / 2) { // Condition for a good subset.\n                isGoodSubset = 0;\n                break;\n            }\n        }\n\n        // Update the best (maximum size) good subset found so far.\n        if (isGoodSubset && currentSubsetSize > maxSubsetSize) {\n            maxSubsetSize = currentSubsetSize;\n            *returnSize = 0;\n            for (int row = 0; row < gridSize; ++row) {\n                if (subsetMask & (1 << row)) {\n                    subset[*returnSize] = row; // Store the row index in the subset.\n                    (*returnSize)++;\n                }\n            }\n        }\n    }\n\n    // If no good subset is found, free the allocated memory and return NULL.\n    if (*returnSize == 0) {\n        free(subset);\n        return NULL;\n    }\n\n    // Return the indices of the rows forming the best good subset found.\n    return subset;\n}"
}