{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 26996000,
    "question_id": "2826",
    "elapsed_time": 348,
    "compare_result": "0111001111111110010001101110111110101101111011111100001000110110101111001111011001111110000001010111000101101111111111000111110011101101110101000000011110100011110000011111101110010111110010010100110111111011111110111011110010010110101111010001111011011011001111011111101110011011111001010100111111001111010111101111111110110011011111100111001101101011101100101111101011110111001101001101111011011101101000111100001100111011000100101110101111101100101111100001001101111101111111111101000111101110110010011000111011101110111111111111111110111111101111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111101011111101111010000000000000010000000000000101",
    "code_output": "[]",
    "std_output": "",
    "last_testcase": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "expected_output": "[0,1]",
    "task_finish_time": 1708444944390,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 462,
    "total_testcases": 685,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1181099223",
    "input_formatted": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "input": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <stdlib.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* goodSubsetofBinaryMatrix(int** grid, int gridSize, int* gridColSize, int* returnSize) {\n    *returnSize = 0;\n    // For gridSize 1, any single row forms a valid subset.\n    if (gridSize == 1) {\n        int* result = (int*)malloc(sizeof(int));\n        if (!result) return NULL; // Check for malloc failure.\n        result[0] = 0;\n        *returnSize = 1;\n        return result;\n    }\n\n    // Attempt to find a good subset by checking each row individually.\n    for (int i = 0; i < gridSize; ++i) {\n        int isGood = 1;\n        for (int j = 0; j < *gridColSize; ++j) {\n            if (grid[i][j] == 1) { // If any column in a row has a 1, it cannot be part of a good subset.\n                isGood = 0;\n                break;\n            }\n        }\n        if (isGood) { // If a row is found with all 0s, it's a good subset on its own.\n            // This approach does not consider subsets of size > 1, as it aims to avoid TLE by not examining all possible subsets.\n            int* result = (int*)malloc(sizeof(int));\n            if (!result) return NULL; // Check for malloc failure.\n            result[0] = i;\n            *returnSize = 1;\n            return result;\n        }\n    }\n\n    // If no individual row forms a good subset, return an empty array.\n    return malloc(0); // Allocate a 0-byte block to return a valid non-NULL pointer.\n}"
}