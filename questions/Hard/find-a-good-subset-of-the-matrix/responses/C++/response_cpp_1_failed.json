{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 975468000,
    "question_id": "2826",
    "elapsed_time": 4061,
    "compare_result": "0100000010110000000000001110000010000001000011100100000000110000001001101000010000010101000000010101000000100000110001100101010000100001100101100000000010000110100000000001000000010001010000000100000011000111011000000001000100000110001010000000000000000010000001000001000000011101001000010100010101000100000001100011000000100001001001101010000000001001000010000000101000000000101000100100010010010000100000000000000001110000010001100000100000001101001000100000000101010010011011000100000000100100110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "[0,1,2]",
    "std_output": "",
    "last_testcase": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "expected_output": "[0,1]",
    "task_finish_time": 1708444550051,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 125,
    "total_testcases": 685,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1181092930",
    "input_formatted": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "input": "[[0,1,1,0],[0,0,0,1],[1,1,1,1]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> goodSubsetofBinaryMatrix(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(1 << m, vector<int>(n + 1, -1));\n        dp[0][0] = 0;\n\n        for (int mask = 0; mask < (1 << m); ++mask) {\n            int count = __builtin_popcount(mask);\n            if (dp[mask][0] == -1) continue;\n            for (int i = 0; i < m; ++i) {\n                if (mask & (1 << i)) continue;\n                int nextMask = mask | (1 << i);\n                bool valid = true;\n                for (int j = 0; j < n; ++j) {\n                    int newSum = dp[mask][j + 1] + grid[i][j];\n                    if (newSum > count / 2) {\n                        valid = false;\n                        break;\n                    }\n                    dp[nextMask][j + 1] = newSum;\n                }\n                if (valid) dp[nextMask][0] = count + 1;\n            }\n        }\n\n        int maxSubset = max_element(dp.begin(), dp.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[0] < b[0];\n        }) - dp.begin();\n\n        vector<int> result;\n        for (int i = 0; i < m; ++i) {\n            if (maxSubset & (1 << i)) result.push_back(i);\n        }\n\n        return result;\n    }\n};"
}