{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 71144000,
    "question_id": "2921",
    "elapsed_time": 6018,
    "compare_result": "100000100010000000000000100000000000000100001110110010100010000001000100010000000000000000000000000000000000000100000000000000001000000000001000000001010000100000010000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000000000000000001000000000100000010000111000101000000000000100000000000000000100000000000000000000000000000000000000000000000000000000001000001000000001100100010010000100001000000100000000100000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000100000000000000000000000100010000010101001000000000001010001010000000000000000000000000000000000100000000000000000100000000000000000000000000000100100000000000000000000011000000001000010000000000000001001000000001000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "0",
    "std_output": "",
    "last_testcase": "\"90\"\n\"101\"",
    "expected_output": "2",
    "task_finish_time": 1708373013546,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 72,
    "total_testcases": 2523,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1180251562",
    "input_formatted": "\"90\", \"101\"",
    "input": "\"90\"\n\"101\"",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec count_stepping_numbers(low :: String.t(), high :: String.t()) :: integer()\n  def count_stepping_numbers(low, high) do\n    low_int = String.to_integer(low)\n    high_int = String.to_integer(high)\n    modulo = 1_000_000_007\n\n    0..9\n    |> Enum.reduce(%{}, fn digit, acc -> Map.put(acc, digit, bfs(digit, low_int, high_int, modulo)) end)\n    |> Map.values()\n    |> Enum.sum()\n    |> rem(modulo)\n  end\n\n  defp bfs(start, low, high, modulo, acc \\\\ 0)\n\n  defp bfs(start, low, high, modulo, acc) when start < low, do: acc\n  defp bfs(start, low, high, _modulo, acc) when start > high, do: acc\n  defp bfs(start, low, high, modulo, acc) when low <= start and start <= high, do: bfs_steps(start, low, high, modulo, acc + 1)\n\n  defp bfs_steps(start, low, high, modulo, acc) do\n    last_digit = rem(start, 10)\n    neighbors = Enum.filter([-1, 1], fn x -> last_digit + x in 0..9 end)\n    |> Enum.map(fn x -> start * 10 + last_digit + x end)\n\n    Enum.reduce(neighbors, acc, fn neighbor, acc ->\n      if neighbor <= high do\n        bfs(neighbor, low, high, modulo, acc)\n      else\n        acc\n      end\n    end)\n  end\nend"
}