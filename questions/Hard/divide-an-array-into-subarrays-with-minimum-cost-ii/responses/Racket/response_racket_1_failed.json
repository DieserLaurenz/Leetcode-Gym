{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "list-ref: index too large for list",
    "full_runtime_error": "list-ref: index too large for list\n  index: 6\n  in: '(1 3 2 6 4 2)\n  context...:\n   solution.rkt:7:8: loop\n   [repeats 1 more time]\n   solution.rkt:11:2: loop\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:21:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 99984000,
    "question_id": "3260",
    "elapsed_time": 274,
    "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[1,3,2,6,4,2]\n3\n3",
    "expected_output": "5",
    "task_finish_time": 1708443902146,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 691,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1181082919",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (minimum-cost nums k dist)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  (define n (length nums))\n  (define (min-cost-helper start k)\n    (if (= k 1)\n        (list-ref nums start)\n        (let loop ((end (+ start 1)) (min-val +inf.0))\n          (if (> end n) min-val\n              (let ((new-cost (+ (list-ref nums start) (min-cost-helper end (- k 1)))))\n                (loop (+ end 1) (min min-val new-cost)))))))\n  (let loop ((i 0) (min-val +inf.0))\n    (if (> i (- n k)) min-val\n        (let ((cost (min-cost-helper i k)))\n          (if (and (<= (- n i) dist) (< cost min-val))\n              (loop (+ i 1) cost)\n              (loop (+ i 1) min-val))))))"
}