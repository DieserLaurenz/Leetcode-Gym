{
    "status_code": 11,
    "lang": "python",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 23964000,
    "question_id": "3032",
    "elapsed_time": 2414,
    "compare_result": "001111000101110000000010100001110000111100000010000001000000000000000000010000000010000000000010000000000000000000000000000000000000000000000010000000000000010000000000000000000000000000010000000000000000000000000000000000000000000001000000001000000010000000000000000000000000000000000000010001000000000001000000000001000100000000000000000000000110000000000000000000000000000000010000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000010000000000000010000000000000000000000000000000000000000000000001000000000000000000100000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000001000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000010000000000000000000000000000000",
    "code_output": "5",
    "std_output": "",
    "last_testcase": "[2,0,1]\n4",
    "expected_output": "6",
    "task_finish_time": 1708891865248,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 49,
    "total_testcases": 948,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Python",
    "submission_id": "1186104466",
    "input_formatted": "[2,0,1], 4",
    "input": "[2,0,1]\n4",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution(object):\n    def getMaxFunctionValue(self, receiver, k):\n        \"\"\"\n        :type receiver: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        n = len(receiver)\n        dp = [0] * n  # To store the sum of ids for each player\n        next_player = [0] * n  # To store the next player id for each player\n        for i in range(n):\n            next_player[i] = receiver[i]\n            dp[i] = i  # Initial value is the player's own id\n\n        # Precompute the receiver of each player after k passes using binary lifting\n        for _ in range(31):\n            new_next = [0] * n\n            for i in range(n):\n                new_next[i] = next_player[next_player[i]]\n            next_player = new_next\n\n        # Calculate the sum for each player\n        for i in range(n):\n            sum_ids = i  # Start with the player's own id\n            current_player = i\n            remaining_passes = k\n            while remaining_passes > 0:\n                if remaining_passes & 1:\n                    sum_ids += dp[current_player]  # Add the precomputed sum for this player\n                current_player = next_player[current_player]  # Move to the next player\n                remaining_passes >>= 1  # Divide the remaining passes by 2\n            dp[i] = sum_ids  # Store the total sum of ids after k passes for player i\n\n        return max(dp)  # Return the maximum sum of ids"
}