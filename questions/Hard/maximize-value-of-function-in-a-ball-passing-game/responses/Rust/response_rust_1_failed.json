{
    "status_code": 14,
    "lang": "rust",
    "run_success": false,
    "status_runtime": "N/A",
    "memory": 1972000,
    "question_id": "3032",
    "elapsed_time": 2082,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[2,0,1]\n4",
    "expected_output": "6",
    "task_finish_time": 1708546718787,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 948,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1182365812",
    "status_msg": "Time Limit Exceeded",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn get_max_function_value(receiver: Vec<i32>, k: i64) -> i64 {\n        let n = receiver.len() as i32;\n        let mut f = vec![0i64; n as usize];\n        let mut next = vec![(0, 0); n as usize];\n\n        for i in 0..n as usize {\n            next[i] = (receiver[i] as usize, 1);\n        }\n\n        for _ in 0..60 {\n            let mut new_next = vec![(0, 0); n as usize];\n            for i in 0..n as usize {\n                let (next_player, passes) = next[i];\n                new_next[i].0 = next[next_player].0;\n                new_next[i].1 = next[next_player].1 + passes;\n            }\n            next = new_next;\n        }\n\n        for i in 0..n {\n            let mut sum = 0i64;\n            let mut current = i as usize;\n            let mut k_left = k;\n            while k_left > 0 {\n                let (next_player, passes) = next[current];\n                let passes_taken = std::cmp::min(k_left, passes as i64);\n                sum += passes_taken * next_player as i64;\n                k_left -= passes_taken;\n                current = next_player;\n            }\n            f[i as usize] = i as i64 + sum;\n        }\n\n        *f.iter().max().unwrap()\n    }\n}"
}