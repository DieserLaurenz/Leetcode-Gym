{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 2024000,
    "question_id": "3243",
    "elapsed_time": 507,
    "compare_result": "11111111111111111111111111111111111111111111111111111111111111111011111111110111111111011111111101111111110111111111011111111101111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000011",
    "code_output": "9",
    "std_output": "",
    "last_testcase": "1\n2000\n8\n\"1\"",
    "expected_output": "162",
    "task_finish_time": 1708424761287,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 233,
    "total_testcases": 932,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1180844520",
    "input_formatted": "1, 2000, 8, \"1\"",
    "input": "1\n2000\n8\n\"1\"",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn number_of_powerful_int(start: i64, finish: i64, limit: i32, s: String) -> i64 {\n        let mut count = 0i64;\n        let s_len = s.len() as i64;\n        let suffix = s.parse::<i64>().unwrap();\n        let mut prefix = 0i64;\n\n        while let Ok(num) = format!(\"{}{}\", prefix, s).parse::<i64>() {\n            if num > finish {\n                break;\n            }\n            if num >= start && is_valid(prefix, limit) {\n                count += 1;\n            }\n            prefix = next_prefix(prefix, limit);\n            // If prefix length exceeds possible length, break\n            if prefix.to_string().len() > s_len as usize {\n                break;\n            }\n        }\n\n        count\n    }\n}\n\nfn is_valid(mut num: i64, limit: i32) -> bool {\n    if num == 0 {\n        return true;\n    }\n    while num > 0 {\n        if num % 10 > limit as i64 {\n            return false;\n        }\n        num /= 10;\n    }\n    true\n}\n\nfn next_prefix(prefix: i64, limit: i32) -> i64 {\n    if prefix == 0 && limit >= 1 {\n        return 1;\n    }\n    let mut next = prefix + 1;\n    while !is_valid(next, limit) {\n        next += 1;\n    }\n    next\n}"
}