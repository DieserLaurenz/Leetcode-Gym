{
    "status_code": 14,
    "lang": "csharp",
    "run_success": false,
    "status_runtime": "N/A",
    "memory": 38580000,
    "question_id": "3243",
    "elapsed_time": 4010,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "1\n6000\n4\n\"124\"",
    "expected_output": "5",
    "task_finish_time": 1708423049926,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 932,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C#",
    "submission_id": "1180823924",
    "status_msg": "Time Limit Exceeded",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public long NumberOfPowerfulInt(long start, long finish, int limit, string s) {\n        long count = 0;\n        long suffix = long.Parse(s);\n        if (suffix > finish) return 0; // No number can have s as a suffix if s is greater than finish.\n        \n        // Calculate the minimum number that can have s as a suffix and is within the range.\n        long minNumWithSuffix = suffix;\n        while (minNumWithSuffix < start) {\n            minNumWithSuffix += suffix;\n        }\n        \n        // Adjust minNumWithSuffix to the next possible number within the limit if necessary.\n        string minStr = minNumWithSuffix.ToString();\n        bool withinLimit = true;\n        for (int i = 0; i < minStr.Length - s.Length; i++) {\n            if (minStr[i] - '0' > limit) {\n                withinLimit = false;\n                break;\n            }\n        }\n        if (!withinLimit) return 0; // If the prefix of minNumWithSuffix exceeds limit, no valid numbers exist.\n        \n        // Generate all possible numbers with s as a suffix and each digit <= limit.\n        long multiplier = 1;\n        for (int i = 0; i < s.Length; i++) {\n            multiplier *= 10;\n        }\n\n        for (long prefix = 0; prefix < multiplier; prefix++) {\n            long current = prefix * multiplier + suffix;\n            if (current > finish) break; // Stop if the current number exceeds the finish.\n            if (current >= start && current <= finish) {\n                bool isValid = true;\n                while (prefix > 0) {\n                    if (prefix % 10 > limit) {\n                        isValid = false;\n                        break;\n                    }\n                    prefix /= 10;\n                }\n                if (isValid) count++;\n            }\n        }\n        \n        return count;\n    }\n}"
}