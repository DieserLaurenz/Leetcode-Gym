{
    "status_code": 10,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "10 ms",
    "memory": 8452000,
    "question_id": "2757",
    "elapsed_time": 29,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1708319598761,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 615,
    "total_testcases": 615,
    "runtime_percentile": 93.30019999999999,
    "status_memory": "8.5 MB",
    "memory_percentile": 52.6055,
    "pretty_lang": "C++",
    "submission_id": "1179495289",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nclass Solution {\n    static const int MOD = 1e9 + 7;\n    int dp[25][2][2][500]; // Increased dimensions to handle larger inputs and digit sums\n\n    // Helper function to calculate the sum of digits of a number recursively\n    int dfs(int idx, bool lessNum1, bool lessNum2, int sum, const string &num1, const string &num2, int min_sum, int max_sum) {\n        // Base case: when we have considered all digits\n        if (idx == num2.length()) {\n            return min_sum <= sum && sum <= max_sum;\n        }\n        // Use memoization to save results of subproblems\n        if (dp[idx][lessNum1][lessNum2][sum] != -1) return dp[idx][lessNum1][lessNum2][sum];\n\n        int low = lessNum1 ? 0 : num1[idx] - '0'; // Determine the lowest digit we can use at this position\n        int high = lessNum2 ? 9 : num2[idx] - '0'; // Determine the highest digit we can use at this position\n        int res = 0;\n        for (int digit = low; digit <= high; ++digit) {\n            // Calculate the result for the next position\n            res = (res + dfs(idx + 1, lessNum1 || digit > num1[idx] - '0', lessNum2 || digit < num2[idx] - '0', sum + digit, num1, num2, min_sum, max_sum)) % MOD;\n        }\n\n        // Save and return the result for this subproblem\n        return dp[idx][lessNum1][lessNum2][sum] = res;\n    }\n\npublic:\n    int count(string num1, string num2, int min_sum, int max_sum) {\n        // Make sure num1 and num2 have the same length by padding num1 with leading zeros\n        num1 = string(max(0, (int)num2.length() - (int)num1.length()), '0') + num1;\n\n        // Initialize dp array with -1 to indicate that no calculations have been done for this state\n        memset(dp, -1, sizeof(dp));\n\n        // Start DFS from the first digit, with no restrictions on the lower and upper bounds yet\n        return dfs(0, false, false, 0, num1, num2, min_sum, max_sum);\n    }\n};"
}