{
    "status_code": 15,
    "lang": "rust",
    "run_success": false,
    "runtime_error": "",
    "full_runtime_error": "",
    "status_runtime": "N/A",
    "memory": 2608000,
    "question_id": "2757",
    "elapsed_time": 14,
    "compare_result": "111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"1012640017461217236611\"\n\"9234552128261772272769\"\n67\n148",
    "expected_output": "683479047",
    "task_finish_time": 1708330086294,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 5,
    "total_testcases": 615,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1179645680",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn count(num1: String, num2: String, min_sum: i32, max_sum: i32) -> i32 {\n        const MOD: i32 = 1_000_000_007;\n        fn dfs(l: usize, r: usize, sum: i32, is_limited: bool, is_num_started: bool, dp: &mut Vec<Vec<Vec<i32>>>, digits: &Vec<i32>, min_sum: i32, max_sum: i32) -> i32 {\n            if l > r {\n                return if sum >= min_sum && sum <= max_sum { 1 } else { 0 };\n            }\n            if !is_limited && is_num_started && dp[l][sum as usize][is_num_started as usize] != -1 {\n                return dp[l][sum as usize][is_num_started as usize];\n            }\n            let mut res = 0;\n            let up = if is_limited { digits[l] } else { 9 };\n            for i in 0..=up {\n                if is_num_started || i > 0 {\n                    res += dfs(l + 1, r, sum + i, is_limited && i == up, true, dp, digits, min_sum, max_sum);\n                } else {\n                    res += dfs(l + 1, r, sum, is_limited && i == up, false, dp, digits, min_sum, max_sum);\n                }\n                res %= MOD;\n            }\n            if !is_limited && is_num_started {\n                dp[l][sum as usize][is_num_started as usize] = res;\n            }\n            res\n        }\n        let num1: i64 = num1.parse().unwrap();\n        let num2: i64 = num2.parse().unwrap();\n        let mut digits = Vec::new();\n        let mut n = num2;\n        while n > 0 {\n            digits.push((n % 10) as i32);\n            n /= 10;\n        }\n        digits.reverse();\n        let len = digits.len();\n        let mut dp = vec![vec![vec![-1; 2]; 400 + 1]; len];\n        let count_num2 = dfs(0, len - 1, 0, true, false, &mut dp, &digits, min_sum, max_sum);\n\n        digits.clear();\n        n = num1 - 1;\n        if n == 0 {\n            return count_num2;\n        }\n        while n > 0 {\n            digits.push((n % 10) as i32);\n            n /= 10;\n        }\n        digits.reverse();\n        let len = digits.len();\n        dp = vec![vec![vec![-1; 2]; 400 + 1]; len];\n        let count_num1 = dfs(0, len - 1, 0, true, false, &mut dp, &digits, min_sum, max_sum);\n\n        (count_num2 - count_num1 + MOD) % MOD\n    }\n}"
}