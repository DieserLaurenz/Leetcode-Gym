{
    "status_code": 10,
    "lang": "golang",
    "run_success": true,
    "status_runtime": "296 ms",
    "memory": 12740000,
    "question_id": "2757",
    "elapsed_time": 543,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1708329560475,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 615,
    "total_testcases": 615,
    "runtime_percentile": 11.111200000000018,
    "status_memory": "12.7 MB",
    "memory_percentile": 11.11120000000001,
    "pretty_lang": "Go",
    "submission_id": "1179639219",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "package main\n\nimport \"math/big\"\n\nfunc count(num1 string, num2 string, min_sum int, max_sum int) int {\n mod := 1000000007\n\n // Function to calculate the sum of digits of numbers less than or equal to num\n sumDigits := func(num string) *big.Int {\n  digits := len(num)\n  dp := make([][][]*big.Int, digits+1)\n  for i := range dp {\n   dp[i] = make([][]*big.Int, 2)\n   for j := range dp[i] {\n    dp[i][j] = make([]*big.Int, max_sum+1)\n    for k := range dp[i][j] {\n     dp[i][j][k] = big.NewInt(0)\n    }\n   }\n  }\n\n  dp[0][1][0] = big.NewInt(1) // Base case\n\n  for i := 0; i < digits; i++ {\n   for j := 0; j < 2; j++ {\n    for k := 0; k <= max_sum; k++ {\n     if dp[i][j][k].Sign() == 0 {\n      continue\n     }\n     limit := 9\n     if j == 1 {\n      limit = int(num[i] - '0')\n     }\n     for d := 0; d <= limit; d++ {\n      if k+d <= max_sum {\n       next := dp[i][j][k]\n       if j == 1 && d == limit {\n        dp[i+1][1][k+d].Add(dp[i+1][1][k+d], next)\n       } else {\n        dp[i+1][0][k+d].Add(dp[i+1][0][k+d], next)\n       }\n      }\n     }\n    }\n   }\n  }\n\n  result := big.NewInt(0)\n  for j := 0; j < 2; j++ {\n   for k := min_sum; k <= max_sum; k++ {\n    result.Add(result, dp[digits][j][k])\n   }\n  }\n  return result\n }\n\n num1Big, _ := big.NewInt(0).SetString(num1, 10)\n num1Big.Sub(num1Big, big.NewInt(1)) // Decrement num1 to include numbers strictly less than num1\n num2Big, _ := big.NewInt(0).SetString(num2, 10)\n\n total := sumDigits(num2Big.String())\n if num1Big.Cmp(big.NewInt(0)) > 0 {\n  total.Sub(total, sumDigits(num1Big.String()))\n }\n\n return int(total.Mod(total, big.NewInt(int64(mod))).Int64())\n}"
}