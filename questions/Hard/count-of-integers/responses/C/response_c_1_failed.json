{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 5500000,
    "question_id": "2757",
    "elapsed_time": 12,
    "compare_result": "110110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "883045898",
    "std_output": "",
    "last_testcase": "\"4179205230\"\n\"7748704426\"\n8\n46",
    "expected_output": "883045899",
    "task_finish_time": 1708328091651,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 4,
    "total_testcases": 615,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1179620643",
    "input_formatted": "\"4179205230\", \"7748704426\", 8, 46",
    "input": "\"4179205230\"\n\"7748704426\"\n8\n46",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nint dp[20][200][2][2];\n\nint digitSum(int x) {\n    int sum = 0;\n    while (x) {\n        sum += x % 10;\n        x /= 10;\n    }\n    return sum;\n}\n\nint recurse(char *num, int n, int sum, int tight, int leadingZero, int min_sum, int max_sum) {\n    if (n == 0) return sum >= min_sum && sum <= max_sum;\n    if (dp[n][sum][tight][leadingZero] != -1) return dp[n][sum][tight][leadingZero];\n    \n    int limit = tight ? num[strlen(num) - n] - '0' : 9;\n    int res = 0;\n    \n    for (int d = 0; d <= limit; ++d) {\n        int newTight = tight && (d == limit);\n        int newSum = leadingZero && d == 0 ? 0 : sum + d;\n        int newLeadingZero = leadingZero && d == 0;\n        res = (res + recurse(num, n - 1, newSum, newTight, newLeadingZero, min_sum, max_sum)) % MOD;\n    }\n    \n    return dp[n][sum][tight][leadingZero] = res;\n}\n\nint solve(char *num, int min_sum, int max_sum) {\n    memset(dp, -1, sizeof(dp));\n    return recurse(num, strlen(num), 0, 1, 1, min_sum, max_sum);\n}\n\nint count(char * num1, char * num2, int min_sum, int max_sum){\n    int len2 = strlen(num2);\n    char *bigNum2 = (char *)malloc(len2 + 2);\n    strcpy(bigNum2 + 1, num2);\n    bigNum2[0] = '0';\n\n    int ans2 = solve(bigNum2, min_sum, max_sum);\n    int ans1 = solve(num1, min_sum, max_sum);\n\n    int num1Sum = digitSum(atoi(num1));\n    int adjust = (num1Sum >= min_sum && num1Sum <= max_sum) ? 1 : 0;\n\n    free(bigNum2);\n\n    return (ans2 - ans1 + adjust + MOD) % MOD;\n}"
}