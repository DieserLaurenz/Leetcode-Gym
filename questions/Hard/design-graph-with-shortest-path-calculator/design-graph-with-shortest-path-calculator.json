{
    "acRate": 70.91391123710275,
    "difficulty": "Hard",
    "freqBar": null,
    "frontendQuestionId": "2642",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Design Graph With Shortest Path Calculator",
    "titleSlug": "design-graph-with-shortest-path-calculator",
    "topicTags": [
        {
            "name": "Graph",
            "id": "VG9waWNUYWdOb2RlOjI0",
            "slug": "graph"
        },
        {
            "name": "Design",
            "id": "VG9waWNUYWdOb2RlOjI1",
            "slug": "design"
        },
        {
            "name": "Heap (Priority Queue)",
            "id": "VG9waWNUYWdOb2RlOjYxMDUw",
            "slug": "heap-priority-queue"
        },
        {
            "name": "Shortest Path",
            "id": "VG9waWNUYWdOb2RlOjYxMDc2",
            "slug": "shortest-path"
        }
    ],
    "hasSolution": true,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Graph { public:     Graph(int n, vector<vector<int>>& edges) {              }          void addEdge(vector<int> edge) {              }          int shortestPath(int node1, int node2) {              } };  /**  * Your Graph object will be instantiated and called as such:  * Graph* obj = new Graph(n, edges);  * obj->addEdge(edge);  * int param_2 = obj->shortestPath(node1,node2);  */"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Graph {      public Graph(int n, int[][] edges) {              }          public void addEdge(int[] edge) {              }          public int shortestPath(int node1, int node2) {              } }  /**  * Your Graph object will be instantiated and called as such:  * Graph obj = new Graph(n, edges);  * obj.addEdge(edge);  * int param_2 = obj.shortestPath(node1,node2);  */"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Graph(object):      def __init__(self, n, edges):         \"\"\"         :type n: int         :type edges: List[List[int]]         \"\"\"               def addEdge(self, edge):         \"\"\"         :type edge: List[int]         :rtype: None         \"\"\"               def shortestPath(self, node1, node2):         \"\"\"         :type node1: int         :type node2: int         :rtype: int         \"\"\"            # Your Graph object will be instantiated and called as such: # obj = Graph(n, edges) # obj.addEdge(edge) # param_2 = obj.shortestPath(node1,node2)"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Graph:      def __init__(self, n: int, edges: List[List[int]]):               def addEdge(self, edge: List[int]) -> None:               def shortestPath(self, node1: int, node2: int) -> int:            # Your Graph object will be instantiated and called as such: # obj = Graph(n, edges) # obj.addEdge(edge) # param_2 = obj.shortestPath(node1,node2)"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "   typedef struct {      } Graph;   Graph* graphCreate(int n, int** edges, int edgesSize, int* edgesColSize) {      }  void graphAddEdge(Graph* obj, int* edge, int edgeSize) {      }  int graphShortestPath(Graph* obj, int node1, int node2) {      }  void graphFree(Graph* obj) {      }  /**  * Your Graph struct will be instantiated and called as such:  * Graph* obj = graphCreate(n, edges, edgesSize, edgesColSize);  * graphAddEdge(obj, edge, edgeSize);    * int param_2 = graphShortestPath(obj, node1, node2);    * graphFree(obj); */"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Graph {      public Graph(int n, int[][] edges) {              }          public void AddEdge(int[] edge) {              }          public int ShortestPath(int node1, int node2) {              } }  /**  * Your Graph object will be instantiated and called as such:  * Graph obj = new Graph(n, edges);  * obj.AddEdge(edge);  * int param_2 = obj.ShortestPath(node1,node2);  */"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * @param {number} n  * @param {number[][]} edges  */ var Graph = function(n, edges) {      };  /**   * @param {number[]} edge  * @return {void}  */ Graph.prototype.addEdge = function(edge) {      };  /**   * @param {number} node1   * @param {number} node2  * @return {number}  */ Graph.prototype.shortestPath = function(node1, node2) {      };  /**   * Your Graph object will be instantiated and called as such:  * var obj = new Graph(n, edges)  * obj.addEdge(edge)  * var param_2 = obj.shortestPath(node1,node2)  */"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "class Graph {     constructor(n: number, edges: number[][]) {              }      addEdge(edge: number[]): void {              }      shortestPath(node1: number, node2: number): number {              } }  /**  * Your Graph object will be instantiated and called as such:  * var obj = new Graph(n, edges)  * obj.addEdge(edge)  * var param_2 = obj.shortestPath(node1,node2)  */"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Graph {     /**      * @param Integer $n      * @param Integer[][] $edges      */     function __construct($n, $edges) {              }        /**      * @param Integer[] $edge      * @return NULL      */     function addEdge($edge) {              }        /**      * @param Integer $node1      * @param Integer $node2      * @return Integer      */     function shortestPath($node1, $node2) {              } }  /**  * Your Graph object will be instantiated and called as such:  * $obj = Graph($n, $edges);  * $obj->addEdge($edge);  * $ret_2 = $obj->shortestPath($node1, $node2);  */"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": " class Graph {      init(_ n: Int, _ edges: [[Int]]) {              }          func addEdge(_ edge: [Int]) {              }          func shortestPath(_ node1: Int, _ node2: Int) -> Int {              } }  /**  * Your Graph object will be instantiated and called as such:  * let obj = Graph(n, edges)  * obj.addEdge(edge)  * let ret_2: Int = obj.shortestPath(node1, node2)  */"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Graph(n: Int, edges: Array<IntArray>) {      fun addEdge(edge: IntArray) {              }      fun shortestPath(node1: Int, node2: Int): Int {              }  }  /**  * Your Graph object will be instantiated and called as such:  * var obj = Graph(n, edges)  * obj.addEdge(edge)  * var param_2 = obj.shortestPath(node1,node2)  */"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Graph {    Graph(int n, List<List<int>> edges) {        }      void addEdge(List<int> edge) {        }      int shortestPath(int node1, int node2) {        } }  /**  * Your Graph object will be instantiated and called as such:  * Graph obj = Graph(n, edges);  * obj.addEdge(edge);  * int param2 = obj.shortestPath(node1,node2);  */"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "type Graph struct {      }   func Constructor(n int, edges [][]int) Graph {      }   func (this *Graph) AddEdge(edge []int)  {      }   func (this *Graph) ShortestPath(node1 int, node2 int) int {      }   /**  * Your Graph object will be instantiated and called as such:  * obj := Constructor(n, edges);  * obj.AddEdge(edge);  * param_2 := obj.ShortestPath(node1,node2);  */"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "class Graph  =begin     :type n: Integer     :type edges: Integer[][] =end     def initialize(n, edges)              end   =begin     :type edge: Integer[]     :rtype: Void =end     def add_edge(edge)              end   =begin     :type node1: Integer     :type node2: Integer     :rtype: Integer =end     def shortest_path(node1, node2)              end   end  # Your Graph object will be instantiated and called as such: # obj = Graph.new(n, edges) # obj.add_edge(edge) # param_2 = obj.shortest_path(node1, node2)"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "class Graph(_n: Int, _edges: Array[Array[Int]]) {      def addEdge(edge: Array[Int]) {              }      def shortestPath(node1: Int, node2: Int): Int = {              }  }  /**  * Your Graph object will be instantiated and called as such:  * var obj = new Graph(n, edges)  * obj.addEdge(edge)  * var param_2 = obj.shortestPath(node1,node2)  */"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "struct Graph {  }   /**   * `&self` means the method takes an immutable reference.  * If you need a mutable reference, change it to `&mut self` instead.  */ impl Graph {      fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {              }          fn add_edge(&self, edge: Vec<i32>) {              }          fn shortest_path(&self, node1: i32, node2: i32) -> i32 {              } }  /**  * Your Graph object will be instantiated and called as such:  * let obj = Graph::new(n, edges);  * obj.add_edge(edge);  * let ret_2: i32 = obj.shortest_path(node1, node2);  */"
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define graph%   (class object%     (super-new)          ; n : exact-integer?     ; edges : (listof (listof exact-integer?))     (init-field       n       edges)          ; add-edge : (listof exact-integer?) -> void?     (define/public (add-edge edge)       )     ; shortest-path : exact-integer? exact-integer? -> exact-integer?     (define/public (shortest-path node1 node2)       )))  ;; Your graph% object will be instantiated and called as such: ;; (define obj (new graph% [n n] [edges edges])) ;; (send obj add-edge edge) ;; (define param_2 (send obj shortest-path node1 node2))"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec graph_init_(N :: integer(), Edges :: [[integer()]]) -> any(). graph_init_(N, Edges) ->   .  -spec graph_add_edge(Edge :: [integer()]) -> any(). graph_add_edge(Edge) ->   .  -spec graph_shortest_path(Node1 :: integer(), Node2 :: integer()) -> integer(). graph_shortest_path(Node1, Node2) ->   .   %% Your functions will be called as such: %% graph_init_(N, Edges), %% graph_add_edge(Edge), %% Param_2 = graph_shortest_path(Node1, Node2),  %% graph_init_ will be called before every test case, in which you can do some necessary initializations."
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Graph do   @spec init_(n :: integer, edges :: [[integer]]) :: any   def init_(n, edges) do        end    @spec add_edge(edge :: [integer]) :: any   def add_edge(edge) do        end    @spec shortest_path(node1 :: integer, node2 :: integer) :: integer   def shortest_path(node1, node2) do        end end  # Your functions will be called as such: # Graph.init_(n, edges) # Graph.add_edge(edge) # param_2 = Graph.shortest_path(node1, node2)  # Graph.init_ will be called before every test case, in which you can do some necessary initializations."
        }
    ],
    "content": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti. Implement the Graph class:  Graph(int n, int[][] edges) initializes the object with n nodes and the given edges. addEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one. int shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.   Example 1:   Input [\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"] [[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]] Output [null, 6, -1, null, 6]  Explanation Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]); g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6. g.shortestPath(0, 3); // return -1. There is no path from 0 to 3. g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above. g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.   Constraints:  1 <= n <= 100 0 <= edges.length <= n * (n - 1) edges[i].length == edge.length == 3 0 <= fromi, toi, from, to, node1, node2 <= n - 1 1 <= edgeCosti, edgeCost <= 106 There are no repeated edges and no self-loops in the graph at any point. At most 100 calls will be made for addEdge. At most 100 calls will be made for shortestPath.  "
}