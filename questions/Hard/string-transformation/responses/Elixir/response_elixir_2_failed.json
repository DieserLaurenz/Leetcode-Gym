{
    "status_code": 15,
    "lang": "elixir",
    "run_success": false,
    "runtime_error": "Line 25: ** (FunctionClauseError) no function clause matching in String.slice/2",
    "full_runtime_error": "Line 25: ** (FunctionClauseError) no function clause matching in String.slice/2\n    The following arguments were given to String.slice/2:\n        # 1\n        \"abcd\"\n        # 2\n        -1\n    Attempted function clauses (showing 2 out of 2):\n        def slice(+string+, -first..last//step = range-) when +is_binary(string)+\n        def slice(+string+, -%{__struct__: Range, first: first, last: last} = range-) when +is_binary(string)+\n    (elixir 1.15.7) lib/string.ex:2241: String.slice/2\n    solution.ex:25: anonymous fn/3 in Solution.number_of_ways/3\n    (elixir 1.15.7) lib/enum.ex:4204: Enum.predicate_range/5\n    solution.ex:24: Solution.number_of_ways/3\n    solution.ex:62: Driver.consume_test_cases/2\n    solution.ex:46: Driver.start/0\n    nofile:1: (file)",
    "status_runtime": "N/A",
    "memory": 78132000,
    "question_id": "3024",
    "elapsed_time": 477,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"abcd\"\n\"cdab\"\n2",
    "expected_output": "2",
    "task_finish_time": 1708986623673,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 726,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1187159730",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec number_of_ways(s :: String.t(), t :: String.t(), k :: integer()) :: integer()\n  def number_of_ways(s, t, k) do\n    mod = 1_000_000_007\n\n    if s == t do\n      # When s equals t, and k is odd, you can't get s to equal t in k moves\n      if rem(k, 2) == 1 do\n        0\n      else\n        # If k is even, there are 2 ways if k is 2 (direct swap or rotate all but one character)\n        # For k > 2, it's 2^(k-2) ways for the first k-2 moves, then 2 ways for the last 2 moves\n        if k == 2 do\n          2\n        else\n          rem(2 * pow(2, k - 2, mod), mod)\n        end\n      end\n    else\n      if k == 1 do\n        0\n      else\n        # When s != t, check if s can be made to equal t in one move\n        can_transform_in_one_move = Enum.any?(1..String.length(s)-1, fn i ->\n          String.slice(s, -i) <> String.slice(s, 0, String.length(s) - i) == t\n        end)\n\n        if can_transform_in_one_move do\n          if k == 2 do\n            1\n          else\n            rem(pow(2, k - 2, mod), mod)\n          end\n        else\n          0\n        end\n      end\n    end\n  end\n\n  defp pow(a, b, mod), do: :math.pow(a, b) |> round() |> rem(mod)\nend"
}