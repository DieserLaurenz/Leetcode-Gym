{
    "status_code": 20,
    "lang": "racket",
    "run_success": false,
    "compile_error": "Line 12: Char 11: if: bad syntax",
    "full_compile_error": "Line 12: Char 11: if: bad syntax\n  in: (if (or (null? sorted-pairs) (<= remaining-sum x)) (if (<= remaining-sum x) steps -1) (let* ((pair (car sorted-pairs)) (index (car pair)) (num1 (cadr pair)) (num2 (caddr pair)) (new-sum (- remaining-sum num1))) (if (<= new-sum x) (set! steps (+ steps 1)...\n  compilation context...:\n   solution.rkt\n  location...:\n   prog_joined.rkt:23:10",
    "status_runtime": "N/A",
    "memory": 0,
    "question_id": "2952",
    "task_finish_time": 1708923639633,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": null,
    "total_testcases": null,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1186391710",
    "status_msg": "Compile Error",
    "state": "SUCCESS",
    "code": "(define/contract (minimum-time nums1 nums2 x)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer? exact-integer?)\n  \n  (let* ((pairs (map list nums1 nums2))\n         (indexed-pairs (map (lambda (pair index) (cons index pair)) pairs (range)))\n         (sorted-pairs (sort indexed-pairs (lambda (a b) (> (/ (cadr a) (if (= (caddr a) 0) 1 (caddr a))) \n                                                              (/ (cadr b) (if (= (caddr b) 0) 1 (caddr b)))))))\n         (total-sum (apply + (map car pairs)))\n         (steps 0))\n    (if (> total-sum x)\n        (let loop ((remaining-sum total-sum) (sorted-pairs sorted-pairs))\n          (if (or (null? sorted-pairs) (<= remaining-sum x))\n              (if (<= remaining-sum x) steps -1)\n              (let* ((pair (car sorted-pairs))\n                     (index (car pair))\n                     (num1 (cadr pair))\n                     (num2 (caddr pair))\n                     (new-sum (- remaining-sum num1)))\n                (if (<= new-sum x)\n                    (set! steps (+ steps 1))\n                    (begin\n                      (set! steps (+ steps 1))\n                      (set! remaining-sum new-sum)\n                      (for-each (lambda (p) (when (= (car p) index) \n                                              (set-cdr! p (list 0 0))))\n                                sorted-pairs))))\n          (loop remaining-sum (cdr sorted-pairs))))\n        0)))"
}