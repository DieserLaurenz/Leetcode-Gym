{
    "status_code": 14,
    "lang": "racket",
    "run_success": false,
    "status_runtime": "N/A",
    "memory": 125700000,
    "question_id": "3047",
    "elapsed_time": 5040,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[49,5,31,27,29,44,18,25,3,49,5,29,49,4]",
    "expected_output": "79",
    "task_finish_time": 1708597629326,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 116,
    "total_testcases": 663,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1182920260",
    "status_msg": "Time Limit Exceeded",
    "state": "SUCCESS",
    "code": "(define/contract (maximum-sum nums)\n  (-> (listof exact-integer?) exact-integer?)\n  \n  (define (prime-factors n)\n    (let loop ([n n] [f 2] [acc '()])\n      (cond\n       [(= n 1) acc]\n       [(zero? (modulo n f)) (loop (/ n f) f (cons f acc))]\n       [else (loop n (+ f 1) acc)])))\n  \n  (define (perfect-square-pair? a b)\n    (let ([a-factors (prime-factors a)]\n          [b-factors (prime-factors b)])\n      (equal? '() \n              (foldl (lambda (x acc)\n                       (if (odd? (count (curry equal? x) (append a-factors b-factors)))\n                           (cons x acc)\n                           acc))\n                     '() (append a-factors b-factors)))))\n  \n  (define (subsets lst)\n    (if (null? lst)\n        '(())\n        (let ([rest (subsets (cdr lst))])\n          (append rest (map (lambda (x) (cons (car lst) x)) rest)))))\n  \n  (define (all-perfect-square-subsets lst)\n    (filter (lambda (subset)\n              (or (= (length subset) 1)\n                  (let loop ([pairs (subsets subset)])\n                    (cond\n                     [(null? pairs) #t]\n                     [(= (length (car pairs)) 2)\n                      (if (perfect-square-pair? (car (car pairs)) (cadr (car pairs)))\n                          (loop (cdr pairs))\n                          #f)]\n                     [else (loop (cdr pairs))]))))\n            (subsets lst)))\n  \n  (define (maximum-element-sum lst)\n    (apply max (map (lambda (subset) (apply + (map (lambda (i) (list-ref nums (sub1 i))) subset))) (all-perfect-square-subsets lst))))\n  \n  (maximum-element-sum (range 1 (add1 (length nums)))))"
}