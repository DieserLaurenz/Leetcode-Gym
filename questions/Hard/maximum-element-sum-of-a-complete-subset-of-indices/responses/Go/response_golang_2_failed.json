{
    "status_code": 11,
    "lang": "golang",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 8680000,
    "question_id": "3047",
    "elapsed_time": 745,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "[8,7,3,5,7,2,4,9]",
    "expected_output": "16",
    "task_finish_time": 1708588720971,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 663,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Go",
    "submission_id": "1182815818",
    "input_formatted": "[8,7,3,5,7,2,4,9]",
    "input": "[8,7,3,5,7,2,4,9]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "import (\n \"math/big\"\n)\n\nfunc maximumSum(nums []int) int64 {\n primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}\n masks := make(map[int]int64)\n var maxSum int64\n\n for _, num := range nums {\n  mask := 0\n  for i, prime := range primes {\n   count := 0\n   for num%prime == 0 {\n    num /= prime\n    count++\n   }\n   if count%2 != 0 {\n    mask |= 1 << i\n   }\n  }\n  if _, exists := masks[mask]; !exists {\n   masks[mask] = 0\n  }\n  masks[mask] += int64(num)\n  if masks[mask] > maxSum {\n   maxSum = masks[mask]\n  }\n }\n\n // Check if any combination of masks forms a perfect square and update maxSum accordingly\n for m1, sum1 := range masks {\n  for m2, sum2 := range masks {\n   if m1 != m2 && big.NewInt(int64(m1&m2)).ProbablyPrime(0) {\n    if tempSum := sum1 + sum2; tempSum > maxSum {\n     maxSum = tempSum\n    }\n   }\n  }\n }\n\n return maxSum\n}"
}