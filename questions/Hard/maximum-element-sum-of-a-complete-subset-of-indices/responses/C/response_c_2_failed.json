{
    "status_code": 11,
    "lang": "c",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 8036000,
    "question_id": "3047",
    "elapsed_time": 77,
    "compare_result": "000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "77",
    "std_output": "",
    "last_testcase": "[8,7,3,5,7,2,4,9]",
    "expected_output": "16",
    "task_finish_time": 1708587465849,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 1,
    "total_testcases": 663,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1182800261",
    "input_formatted": "[8,7,3,5,7,2,4,9]",
    "input": "[8,7,3,5,7,2,4,9]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nlong long maximumSum(int* nums, int numsSize) {\n    long long answer = 0;\n    int primeFactors[10000][11] = {0}; // Stores exponents of the first 11 primes for each number\n    int primes[11] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}; // First 10 primes\n\n    // Preprocess the nums array to count the powers of primes up to 29 in their prime factorization\n    for (int i = 0; i < numsSize; i++) {\n        int num = nums[i];\n        for (int j = 0; j < 10; j++) {\n            while (num % primes[j] == 0) {\n                primeFactors[i][j]++;\n                num /= primes[j];\n            }\n        }\n        if (num > 1) { // Handle the case where num is a prime > 29\n            primeFactors[i][10] = 1; // Mark this as a unique prime factor\n        }\n    }\n\n    // Use bitmask dynamic programming to find the maximum subset sum\n    // where the product of elements is a perfect square\n    long long dp[1 << 10] = {0}; // dp[mask] = maximum sum of subset with mask representing square-free basis\n    for (int i = 0; i < numsSize; i++) {\n        int mask = 0;\n        for (int j = 0; j < 10; j++) {\n            if (primeFactors[i][j] % 2) { // If odd, it contributes to the mask\n                mask |= 1 << j;\n            }\n        }\n        // Update dp for all subsets\n        for (int subset = mask; ; subset = (subset - 1) & mask) {\n            dp[subset] = fmax(dp[subset], dp[subset ^ mask] + nums[i]);\n            if (subset == 0) break;\n        }\n    }\n\n    // Find the maximum sum where the product of elements is a perfect square\n    for (int i = 0; i < (1 << 10); i++) {\n        answer = fmax(answer, dp[i]);\n    }\n    return answer;\n}"
}