{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "add-mod: arity mismatch;",
    "full_runtime_error": "add-mod: arity mismatch;\n the expected number of arguments does not match the given number\n  expected: 3\n  given: 2\n  context...:\n   solution.rkt:1:0: sum-counts\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:24:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 99912000,
    "question_id": "3139",
    "elapsed_time": 260,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[1,2,1]",
    "expected_output": "15",
    "task_finish_time": 1709005914947,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 542,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1187323167",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (sum-counts nums)\n  (-> (listof exact-integer?) exact-integer?)\n  (let ([mod 1000000007])\n    (define (add-mod a b mod)\n      (modulo (+ a b) mod))\n    (define (mult-mod a b mod)\n      (modulo (* a b) mod))\n    (define (sum-squares n mod)\n      (mult-mod (mult-mod n (add-mod n 1) mod) (add-mod (mult-mod 2 n mod) 1) mod))\n    (let loop ([nums nums] [last -1] [result 0] [freq (make-hash)] [total 0] [squares 0])\n      (if (null? nums)\n          (modulo (- result squares) mod)\n          (let* ([num (car nums)]\n                 [prev (hash-ref freq num 0)]\n                 [new-total (add-mod total 1 mod)]\n                 [new-squares (add-mod squares (sum-squares (sub1 new-total) mod) mod)]\n                 [to-subtract (if (= prev 0) 0 (sum-squares (sub1 (- total prev)) mod))]\n                 [new-result (add-mod result (add-mod new-squares (modulo (- mod to-subtract) mod) mod) mod)])\n            (loop (cdr nums) num new-result (hash-set freq num new-total) new-total new-squares))))))"
}