{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 146448000,
    "question_id": "3139",
    "elapsed_time": 6024,
    "compare_result": "00000001000001000100000101000000000100001101000000001100000000001100100100000000001000001100010000010011100000101000000000000000000001000100000100000000100100000000000001000000100010000001000011001100100000000000000010010001000000100100100010000001001100000110001000000000000000001000000100101000000010000010000000000010000000000000010000100000010000000000000000100100000000000000000100010000010000100010110000101000000000100000100010010000000000000000000000000100100000110000001000010001000000000011010000000000000000000000000000000000000000",
    "code_output": "18",
    "std_output": "",
    "last_testcase": "[1,2,1]",
    "expected_output": "15",
    "task_finish_time": 1709006159334,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 87,
    "total_testcases": 542,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1187325931",
    "input_formatted": "[1,2,1]",
    "input": "[1,2,1]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec sum_counts(nums :: [integer]) :: integer\n  def sum_counts(nums) do\n    nums\n    |> Enum.with_index()\n    |> Enum.reduce(%{}, fn {num, idx}, acc ->\n      Map.update(acc, num, [idx], &[idx | &1])\n    end)\n    |> Enum.reduce({0, 0, Map.new()}, fn {_, positions}, {total, prev_total, last_pos} ->\n      positions\n      |> Enum.reverse()\n      |> Enum.reduce({0, prev_total, last_pos}, fn pos, {sum, inner_total, last_pos_acc} ->\n        {new_last_pos, add} = Map.get_and_update(last_pos_acc, pos, fn old_pos ->\n          {old_pos, pos}\n        end)\n\n        case new_last_pos do\n          nil -> {sum + length(nums) - pos, inner_total, Map.put(last_pos_acc, pos, pos)}\n          old_pos -> {sum + old_pos - pos, inner_total + sum * (old_pos - pos), Map.put(last_pos_acc, pos, pos)}\n        end\n      end)\n      |> then(fn {sum, inner_total, last_pos_acc} ->\n        new_total = (inner_total + sum * length(nums)) |> rem(1_000_000_007)\n        {total + new_total - prev_total |> rem(1_000_000_007), new_total, last_pos_acc}\n      end)\n    end)\n    |> then(fn {total, _, _} -> total end)\n  end\nend"
}