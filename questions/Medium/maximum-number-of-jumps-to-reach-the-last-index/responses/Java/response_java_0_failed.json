{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 44964000,
    "display_runtime": "18",
    "question_id": "2855",
    "elapsed_time": 205,
    "compare_result": "00111111111001100110011001100110011000110001100011000110001100011000110001100010000110001100011000110001000011000110001100011000110001100011000110001100011000011000011000011000011000011000011000011000011000011000011000011000011000011000011100011100011000011000011000011000011000011000011000011000011000011000011000011000011000011000011000011000011000010100011000010100011000011000011000011000011000011000011000011000011000010000011000011000011000011000011000010000011000011000011000010000011000011000010000011000011000010000011000011000010000011000011000011000010000011000011000011000011000011000010000011000011000011000011000011000011000011000011000011000010100011000010100011000011000011000011000011000011000011000011000011000011000011000011000011000011000011000011000011000011100011100011000011000011000011000011000011000011000011000011000011000011000011000011000011000010001111101111100100001001010011010000100111100011111000111001001001100010011111100110000010010001110100110000010110100011011000001100101011101110101100010000000000111010000010010000000100100001000111000110101110010101111010010011010010011100110011101110110000001000000011101000101000010100011100101110000101010100010000011011101000111110000001100001010010111001001111001000001001111011101010000100100010011001111110001011111111001011100111111100100100001001110000001001111100111110101100001010110001011010111110010010010111001000100111001001110000110100000000000010110011100000000100110110010000011011001011010010100111010100111001010001010010111100101100110000000100100100001000010011110011110010100110100100010111100011111110001110100010101101101000111110010110000010100000010101110001000001001011011011000000100111101111001010101110101011100100000100010011001001110010100101010101101010101011100000111010011110010110100101111010011111111110001001101101000101000101100001011100110100000110110001001000000100000000100000000010000100000010111000101101000001000101000100000000001011000010000001010000001100000101100010000100100100000000000110011110100000000000011010100000010000001000000000101011000000000010010100100010000001010001000000000001000100000100000000100000010010010110000000000010000010100101001000000000001001000001000000000101100000000011100000010010000010100100000010110000100001000100000110001000010000010000000000000001000000100010000000000000000101001001000001100000000000101000000100010010001001001000000000010001000000000000000000001000000000010000000000001000010010000000000000100000000000011000000000001001000000100100000010000001000110100011001000101000000000001110100000000000000000001000001000000000011000000000000000001000100000000000111111",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "[1,3,6,4,1,2]\n2",
    "expected_output": "3",
    "task_finish_time": 1707607985558,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 915,
    "total_testcases": 2639,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1171802365",
    "input_formatted": "[1,3,6,4,1,2], 2",
    "input": "[1,3,6,4,1,2]\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    public int maximumJumps(int[] nums, int target) {\n        int n = nums.length;\n        int[] dp = new int[n]; // dp[i] stores the maximum jumps to reach i\n        Arrays.fill(dp, -1); // Initialize with -1, as we haven't calculated any jumps yet\n        dp[0] = 0; // Base case: 0 jumps to reach the start\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (Math.abs(nums[i] - nums[j]) <= target) {\n                    if (dp[j] != -1) {\n                        if (dp[i] == -1) dp[i] = dp[j] + 1;\n                        else dp[i] = Math.min(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n        }\n\n        if (dp[n-1] == -1) return -1; // If dp[n-1] is still -1, it means we can't reach the end\n\n        // To find the maximum number of jumps, we need to calculate the number of jumps for each index\n        // and then find the maximum value. However, since the problem requires us to reach the end with the maximum\n        // jumps, we just need to ensure we've reached the last index.\n        int maxJumps = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[i] > maxJumps) maxJumps = dp[i];\n        }\n        return maxJumps;\n    }\n}"
}