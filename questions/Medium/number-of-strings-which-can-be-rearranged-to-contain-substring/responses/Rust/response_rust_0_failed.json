{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 3172000,
    "question_id": "3200",
    "elapsed_time": 2030,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "0",
    "std_output": "",
    "last_testcase": "4",
    "expected_output": "12",
    "task_finish_time": 1708083478195,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 264,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1176901942",
    "input_formatted": "4",
    "input": "4",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn string_count(n: i32) -> i32 {\n        const MOD: i64 = 1_000_000_007;\n        let n = n as i64;\n        let mut dp = vec![0i64; n as usize + 1];\n        dp[0] = 1; // Base case: there's one way to arrange 0 characters\n\n        // Calculate factorial modulo MOD\n        let mut factorial = vec![1i64; n as usize + 1];\n        for i in 1..=n as usize {\n            factorial[i] = factorial[i - 1] * i as i64 % MOD;\n        }\n\n        for i in 1..=n as usize {\n            dp[i] = (dp[i] + factorial[i] - 24 * dp[i.saturating_sub(4)]) % MOD;\n            if i > 4 {\n                // For each n > 4, subtract arrangements that don't include \"leet\"\n                for j in 1..=i - 4 {\n                    dp[i] = (dp[i] - (factorial[j] * 24 % MOD) * dp[i - 4 - j] % MOD + MOD) % MOD;\n                }\n            }\n        }\n        \n        dp[n as usize] as i32\n    }\n}"
}