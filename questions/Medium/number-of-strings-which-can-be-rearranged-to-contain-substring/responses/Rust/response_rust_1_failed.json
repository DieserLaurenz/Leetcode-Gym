{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 1992000,
    "question_id": "3200",
    "elapsed_time": 39,
    "compare_result": "101110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "493917714",
    "std_output": "",
    "last_testcase": "10",
    "expected_output": "83943898",
    "task_finish_time": 1708083518646,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 4,
    "total_testcases": 264,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1176902308",
    "input_formatted": "10",
    "input": "10",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn string_count(n: i32) -> i32 {\n        const MOD: i64 = 1_000_000_007;\n        if n < 4 { return 0; } // If n is less than 4, it's impossible to form \"leet\"\n        \n        let mut total = 1i64; // Start with one possible string\n        let n = n as i64;\n\n        // Calculate total possible strings of length n\n        for i in 1..=n {\n            total = total * 26 % MOD; // Each position can be any of the 26 letters\n        }\n\n        // If n is exactly 4, all permutations of \"leet\" are valid\n        if n == 4 {\n            return 12;\n        }\n\n        // For n > 4, calculate combinations for positions not occupied by \"leet\"\n        let mut comb = 1i64; // Combinations of choosing positions for \"leet\"\n        for i in 1..=n-4 {\n            comb = comb * (n - i + 1) % MOD * pow_mod(i, MOD-2, MOD) % MOD; // nCi * 24 (for permutations of \"leet\")\n            total = (total + comb * 24 % MOD * pow_mod(26, n-4-i, MOD) % MOD) % MOD; // Add combinations times remaining letters\n        }\n\n        total as i32\n    }\n}\n\n// Fast exponentiation modulo MOD\nfn pow_mod(mut base: i64, mut exp: i64, modu: i64) -> i64 {\n    let mut res = 1;\n    base %= modu;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res = res * base % modu;\n        }\n        base = base * base % modu;\n        exp /= 2;\n    }\n    res\n}"
}