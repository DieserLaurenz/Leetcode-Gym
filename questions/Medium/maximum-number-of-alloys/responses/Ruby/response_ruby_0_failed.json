{
    "status_code": 11,
    "lang": "ruby",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 212304000,
    "question_id": "3095",
    "elapsed_time": 247,
    "compare_result": "00000000001000100100000000101000000011000100010101000000000000100000001000000000000010000000001010000000000000000000000000000000010100011000000000000110100000000001000010011000000100011000001000100000100000000000000011000000000101000000010000000000000000000011100001000000100010010100001010001000000011001010000101000010000100100000100100001000000010000000000011000000000001000101000000100000001011001000000001000000000100001000000000000000000001001000000000000001000000010000011000000100000000000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000111110001000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "3\n2\n15\n[[1,1,1],[1,1,10]]\n[0,0,0]\n[1,2,3]",
    "expected_output": "2",
    "task_finish_time": 1707598067850,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 91,
    "total_testcases": 731,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Ruby",
    "submission_id": "1171728824",
    "input_formatted": "3, 2, 15, [[1,1,1],[1,1,10]], [0,0,0], [1,2,3]",
    "input": "3\n2\n15\n[[1,1,1],[1,1,10]]\n[0,0,0]\n[1,2,3]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "# @param {Integer} n\n# @param {Integer} k\n# @param {Integer} budget\n# @param {Integer[][]} composition\n# @param {Integer[]} stock\n# @param {Integer[]} cost\n# @return {Integer}\ndef max_number_of_alloys(n, k, budget, composition, stock, cost)\n  max_alloys = 0\n  k.times do |machine|\n    total_cost = 0\n    max_alloy_possible = Float::INFINITY\n    n.times do |metal|\n      required_metal = composition[machine][metal]\n      if required_metal > 0\n        metal_cost = cost[metal]\n        available_stock = stock[metal]\n        max_alloy_for_metal = (budget / (metal_cost * required_metal)).floor\n        additional_cost = [0, required_metal - available_stock].max * metal_cost\n        total_cost += additional_cost\n        max_alloy_possible = [max_alloy_possible, max_alloy_for_metal].min\n      end\n    end\n    alloys_with_budget = (budget - total_cost) / (composition[machine].zip(cost).map { |comp, c| comp * c }.sum)\n    max_alloys = [max_alloys, alloys_with_budget.floor].max if total_cost <= budget\n  end\n  max_alloys\nend"
}