{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "vector-ref: contract violation",
    "full_runtime_error": "vector-ref: contract violation\n  expected: vector?\n  given: '(8 6 1 5 3)\n  context...:\n   solution.rkt:1:0: minimum-sum\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:28:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 100332000,
    "question_id": "3186",
    "elapsed_time": 317,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[8,6,1,5,3]",
    "expected_output": "9",
    "task_finish_time": 1707991867273,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 788,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1175916802",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (minimum-sum nums)\n  (-> (listof exact-integer?) exact-integer?)\n  \n  (let ([left-min (make-vector (length nums) #f)]\n        [right-max (make-vector (length nums) #f)])\n    (let loop-left ([i 1] [min-val (vector-ref nums 0)])\n      (when (< i (length nums))\n        (vector-set! left-min i min-val)\n        (loop-left (add1 i) (min min-val (vector-ref nums i)))))\n    (let loop-right ([i (- (length nums) 2)] [max-val (vector-ref nums (- (length nums) 1))])\n      (when (>= i 0)\n        (vector-set! right-max i max-val)\n        (loop-right (sub1 i) (max max-val (vector-ref nums i)))))\n    (let find-minimum ([i 1] [min-sum #f])\n      (if (< i (- (length nums) 1))\n          (let ([left (vector-ref left-min i)]\n                [right (vector-ref right-max i)]\n                [current (vector-ref nums i)])\n            (if (and left right (< left current) (> right current))\n                (let ([sum (+ left current right)])\n                  (find-minimum (add1 i) (if (or (not min-sum) (< sum min-sum)) sum min-sum)))\n                (find-minimum (add1 i) min-sum)))\n          (if min-sum min-sum -1)))))"
}