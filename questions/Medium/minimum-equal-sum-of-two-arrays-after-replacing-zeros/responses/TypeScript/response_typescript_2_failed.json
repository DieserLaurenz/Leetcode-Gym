{
    "status_code": 11,
    "lang": "typescript",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 70416000,
    "question_id": "3171",
    "elapsed_time": 144,
    "compare_result": "010000000000000000000000000000000000000010000000000000000000100000000000000100000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000001110000000000100000000100000000000000000000000000000000000100000000001000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000100000000100001000000000000000000000010001000000000000000000000000000000000000000011000000001100000000000000011100000100000000000000000000100000000100001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001110000000000000000000000000000000",
    "code_output": "13",
    "std_output": "",
    "last_testcase": "[3,2,0,1,0]\n[6,5,0]",
    "expected_output": "12",
    "task_finish_time": 1707784745673,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 32,
    "total_testcases": 636,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "TypeScript",
    "submission_id": "1173662039",
    "input_formatted": "[3,2,0,1,0], [6,5,0]",
    "input": "[3,2,0,1,0]\n[6,5,0]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "function minSum(nums1: number[], nums2: number[]): number {\n    let sum1 = nums1.reduce((acc, val) => acc + val, 0);\n    let sum2 = nums2.reduce((acc, val) => acc + val, 0);\n    let zeroCount1 = nums1.filter(val => val === 0).length;\n    let zeroCount2 = nums2.filter(val => val === 0).length;\n\n    if (zeroCount1 === 0 && zeroCount2 === 0 && sum1 !== sum2) {\n        return -1; // Impossible to modify the sum if there are no zeros and sums are different\n    }\n\n    let totalZeroCount = zeroCount1 + zeroCount2;\n    if (sum1 === sum2) {\n        return sum1; // Sums are already equal, no need to replace zeros\n    }\n\n    // The strategy is to make the sums equal by adjusting the zero values\n    // If sums are not equal, we need to distribute the difference over the zeros\n\n    // The minimum value to be added to make the sums equal is the difference divided by the number of zeros,\n    // adjusted up to ensure it is a positive integer (if there are zeros to replace)\n    let diff = Math.abs(sum1 - sum2);\n\n    // Impossible to equalize if one array has zeros and the other has a higher sum without zeros\n    if ((zeroCount1 > 0 && sum1 < sum2 && zeroCount2 === 0) || (zeroCount2 > 0 && sum2 < sum1 && zeroCount1 === 0)) {\n        return -1;\n    }\n\n    // Find minimum value to increment such that the sums become equal\n    // The goal is to distribute the required increment (to match the higher sum) across all zeros in both arrays\n    if (zeroCount1 + zeroCount2 > 0) {\n        let increment = diff / (zeroCount1 + zeroCount2); // This assumes an even distribution\n        if (Math.floor(increment) !== increment) { // If increment is not an integer, round up since we deal with integers\n            increment = Math.floor(increment) + 1;\n        }\n        // Calculate new sum by adding increment to all zeros in both arrays\n        let newSum = Math.max(sum1, sum2) + increment * Math.min(zeroCount1, zeroCount2);\n        return newSum;\n    }\n\n    return -1; // Default case, should not be reached due to the checks above\n}"
}