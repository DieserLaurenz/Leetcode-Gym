{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 209316000,
    "question_id": "2787",
    "elapsed_time": 5937,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000001000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "12",
    "std_output": "",
    "last_testcase": "[-2,0,2]\n\"RLL\"\n3",
    "expected_output": "8",
    "task_finish_time": 1708003216157,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 7,
    "total_testcases": 2567,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1176030943",
    "input_formatted": "[-2,0,2], \"RLL\", 3",
    "input": "[-2,0,2]\n\"RLL\"\n3",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec sum_distance(nums :: [integer], s :: String.t, d :: integer) :: integer\n  def sum_distance(nums, s, d) do\n    initial_positions = Enum.with_index(nums)\n    |> Enum.map(fn {num, index} -> \n      dir = String.at(s, index)\n      move = if dir == \"L\", do: -d, else: d\n      {num + move, move}\n    end)\n    |> Enum.sort()\n\n    len = length(nums)\n    mod = 1_000_000_007\n\n    total_distance = Enum.reduce(initial_positions, {0, 0, 0}, fn {pos, move}, {acc, prev_left, count_left} ->\n      new_acc =\n        if move < 0 do\n          acc\n        else\n          acc + (pos * count_left - prev_left) * 2\n        end\n\n      new_prev_left = if move < 0, do: prev_left + pos, else: prev_left\n      new_count_left = if move < 0, do: count_left + 1, else: count_left\n      {rem(new_acc, mod), new_prev_left, new_count_left}\n    end)\n    |> elem(0)\n\n    rem(total_distance, mod)\n  end\nend"
}