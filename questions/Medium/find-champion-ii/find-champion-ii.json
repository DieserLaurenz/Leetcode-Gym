{
    "acRate": 56.09377093101139,
    "difficulty": "Medium",
    "freqBar": null,
    "frontendQuestionId": "2924",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Find Champion II",
    "titleSlug": "find-champion-ii",
    "topicTags": [
        {
            "name": "Graph",
            "id": "VG9waWNUYWdOb2RlOjI0",
            "slug": "graph"
        }
    ],
    "hasSolution": false,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Solution { public:     int findChampion(int n, vector<vector<int>>& edges) {              } };"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {     public int findChampion(int n, int[][] edges) {              } }"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Solution(object):     def findChampion(self, n, edges):         \"\"\"         :type n: int         :type edges: List[List[int]]         :rtype: int         \"\"\"         "
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Solution:     def findChampion(self, n: int, edges: List[List[int]]) -> int:         "
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "int findChampion(int n, int** edges, int edgesSize, int* edgesColSize) {      }"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Solution {     public int FindChampion(int n, int[][] edges) {              } }"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * @param {number} n  * @param {number[][]} edges  * @return {number}  */ var findChampion = function(n, edges) {      };"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "function findChampion(n: number, edges: number[][]): number {      };"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Solution {      /**      * @param Integer $n      * @param Integer[][] $edges      * @return Integer      */     function findChampion($n, $edges) {              } }"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Solution {     func findChampion(_ n: Int, _ edges: [[Int]]) -> Int {              } }"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Solution {     fun findChampion(n: Int, edges: Array<IntArray>): Int {              } }"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Solution {   int findChampion(int n, List<List<int>> edges) {        } }"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "func findChampion(n int, edges [][]int) int {      }"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# @param {Integer} n # @param {Integer[][]} edges # @return {Integer} def find_champion(n, edges)      end"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "object Solution {     def findChampion(n: Int, edges: Array[Array[Int]]): Int = {              } }"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "impl Solution {     pub fn find_champion(n: i32, edges: Vec<Vec<i32>>) -> i32 {              } }"
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define/contract (find-champion n edges)   (-> exact-integer? (listof (listof exact-integer?)) exact-integer?)   )"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec find_champion(N :: integer(), Edges :: [[integer()]]) -> integer(). find_champion(N, Edges) ->   ."
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Solution do   @spec find_champion(n :: integer, edges :: [[integer]]) :: integer   def find_champion(n, edges) do        end end"
        }
    ],
    "content": "There are n teams numbered from 0 to n - 1 in a tournament; each team is also a node in a DAG. You are given the integer n and a 0-indexed 2D integer array edges of length m representing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi in the graph. A directed edge from a to b in the graph means that team a is stronger than team b and team b is weaker than team a. Team a will be the champion of the tournament if there is no team b that is stronger than team a. Return the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1. Notes  A cycle is a series of nodes a1, a2, ..., an, an+1 such that node a1 is the same node as node an+1, the nodes a1, a2, ..., an are distinct, and there is a directed edge from the node ai to node ai+1 for every i in the range [1, n]. A DAG is a directed graph that does not have any cycle.   Example 1:   Input: n = 3, edges = [[0,1],[1,2]] Output: 0 Explanation: Team 1 is weaker than team 0. Team 2 is weaker than team 1. So the champion is team 0.  Example 2:   Input: n = 4, edges = [[0,2],[1,3],[1,2]] Output: -1 Explanation: Team 2 is weaker than team 0 and team 1. Team 3 is weaker than team 1. But team 1 and team 0 are not weaker than any other teams. So the answer is -1.   Constraints:  1 <= n <= 100 m == edges.length 0 <= m <= n * (n - 1) / 2 edges[i].length == 2 0 <= edge[i][j] <= n - 1 edges[i][0] != edges[i][1] The input is generated such that if team a is stronger than team b, team b is not stronger than team a. The input is generated such that if team a is stronger than team b and team b is stronger than team c, then team a is stronger than team c.  "
}