{
    "acRate": 48.64719510177065,
    "difficulty": "Medium",
    "freqBar": null,
    "frontendQuestionId": "2816",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Double a Number Represented as a Linked List",
    "titleSlug": "double-a-number-represented-as-a-linked-list",
    "topicTags": [
        {
            "name": "Linked List",
            "id": "VG9waWNUYWdOb2RlOjc=",
            "slug": "linked-list"
        },
        {
            "name": "Math",
            "id": "VG9waWNUYWdOb2RlOjg=",
            "slug": "math"
        },
        {
            "name": "Stack",
            "id": "VG9waWNUYWdOb2RlOjE1",
            "slug": "stack"
        }
    ],
    "hasSolution": false,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "/**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode() : val(0), next(nullptr) {}  *     ListNode(int x) : val(x), next(nullptr) {}  *     ListNode(int x, ListNode *next) : val(x), next(next) {}  * };  */ class Solution { public:     ListNode* doubleIt(ListNode* head) {              } };"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode() {}  *     ListNode(int val) { this.val = val; }  *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }  * }  */ class Solution {     public ListNode doubleIt(ListNode head) {              } }"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "# Definition for singly-linked list. # class ListNode(object): #     def __init__(self, val=0, next=None): #         self.val = val #         self.next = next class Solution(object):     def doubleIt(self, head):         \"\"\"         :type head: Optional[ListNode]         :rtype: Optional[ListNode]         \"\"\"         "
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "# Definition for singly-linked list. # class ListNode: #     def __init__(self, val=0, next=None): #         self.val = val #         self.next = next class Solution:     def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:         "
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "/**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     struct ListNode *next;  * };  */ struct ListNode* doubleIt(struct ListNode* head){  }"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "/**  * Definition for singly-linked list.  * public class ListNode {  *     public int val;  *     public ListNode next;  *     public ListNode(int val=0, ListNode next=null) {  *         this.val = val;  *         this.next = next;  *     }  * }  */ public class Solution {     public ListNode DoubleIt(ListNode head) {              } }"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * Definition for singly-linked list.  * function ListNode(val, next) {  *     this.val = (val===undefined ? 0 : val)  *     this.next = (next===undefined ? null : next)  * }  */ /**  * @param {ListNode} head  * @return {ListNode}  */ var doubleIt = function(head) {      };"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "/**  * Definition for singly-linked list.  * class ListNode {  *     val: number  *     next: ListNode | null  *     constructor(val?: number, next?: ListNode | null) {  *         this.val = (val===undefined ? 0 : val)  *         this.next = (next===undefined ? null : next)  *     }  * }  */  function doubleIt(head: ListNode | null): ListNode | null {  };"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "/**  * Definition for a singly-linked list.  * class ListNode {  *     public $val = 0;  *     public $next = null;  *     function __construct($val = 0, $next = null) {  *         $this->val = $val;  *         $this->next = $next;  *     }  * }  */ class Solution {      /**      * @param ListNode $head      * @return ListNode      */     function doubleIt($head) {              } }"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "/**  * Definition for singly-linked list.  * public class ListNode {  *     public var val: Int  *     public var next: ListNode?  *     public init() { self.val = 0; self.next = nil; }  *     public init(_ val: Int) { self.val = val; self.next = nil; }  *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }  * }  */ class Solution {     func doubleIt(_ head: ListNode?) -> ListNode? {              } }"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "/**  * Example:  * var li = ListNode(5)  * var v = li.`val`  * Definition for singly-linked list.  * class ListNode(var `val`: Int) {  *     var next: ListNode? = null  * }  */ class Solution {     fun doubleIt(head: ListNode?): ListNode? {              } }"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "/**  * Definition for singly-linked list.  * class ListNode {  *   int val;  *   ListNode? next;  *   ListNode([this.val = 0, this.next]);  * }  */ class Solution {   ListNode? doubleIt(ListNode? head) {    } }"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "/**  * Definition for singly-linked list.  * type ListNode struct {  *     Val int  *     Next *ListNode  * }  */ func doubleIt(head *ListNode) *ListNode {      }"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# Definition for singly-linked list. # class ListNode #     attr_accessor :val, :next #     def initialize(val = 0, _next = nil) #         @val = val #         @next = _next #     end # end # @param {ListNode} head # @return {ListNode} def double_it(head)      end"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "/**  * Definition for singly-linked list.  * class ListNode(_x: Int = 0, _next: ListNode = null) {  *   var next: ListNode = _next  *   var x: Int = _x  * }  */ object Solution {     def doubleIt(head: ListNode): ListNode = {              } }"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "// Definition for singly-linked list. // #[derive(PartialEq, Eq, Clone, Debug)] // pub struct ListNode { //   pub val: i32, //   pub next: Option<Box<ListNode>> // } //  // impl ListNode { //   #[inline] //   fn new(val: i32) -> Self { //     ListNode { //       next: None, //       val //     } //   } // } impl Solution {     pub fn double_it(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {              } }"
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "; Definition for singly-linked list: #|  ; val : integer? ; next : (or/c list-node? #f) (struct list-node   (val next) #:mutable #:transparent)  ; constructor (define (make-list-node [val 0])   (list-node val #f))  |#  (define/contract (double-it head)   (-> (or/c list-node? #f) (or/c list-node? #f))    )"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "%% Definition for singly-linked list. %% %% -record(list_node, {val = 0 :: integer(), %%                     next = null :: 'null' | #list_node{}}).  -spec double_it(Head :: #list_node{} | null) -> #list_node{} | null. double_it(Head) ->   ."
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "# Definition for singly-linked list. # # defmodule ListNode do #   @type t :: %__MODULE__{ #           val: integer, #           next: ListNode.t() | nil #         } #   defstruct val: 0, next: nil # end  defmodule Solution do   @spec double_it(head :: ListNode.t | nil) :: ListNode.t | nil   def double_it(head) do    end end"
        }
    ],
    "content": "You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes. Return the head of the linked list after doubling it.  Example 1:   Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.  Example 2:   Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998.    Constraints:  The number of nodes in the list is in the range [1, 104] 0 <= Node.val <= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself.  "
}