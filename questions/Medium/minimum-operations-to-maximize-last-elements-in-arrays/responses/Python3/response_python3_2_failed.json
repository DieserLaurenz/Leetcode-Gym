{
    "status_code": 11,
    "lang": "python3",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 16824000,
    "question_id": "3190",
    "elapsed_time": 168,
    "compare_result": "000100111011101101111000100001000101010000000000000110100000100100000000000001000011000001000000000000001100000100000000000100000001000000000000000000100000010001100001000001000000001000001000000000000000010000000000000000000000000100010000000000000000000000000001000000000110001000100100000000000000000000000000000000000000000000000000000000000000000100000000000100000000000000000100000000000000000000000000000000000001001000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000001000000000011011100010000010000000000000000000000000000000",
    "code_output": "0",
    "std_output": "",
    "last_testcase": "[1,2,7]\n[4,5,3]",
    "expected_output": "1",
    "task_finish_time": 1708829681614,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 64,
    "total_testcases": 702,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Python3",
    "submission_id": "1185343634",
    "input_formatted": "[1,2,7], [4,5,3]",
    "input": "[1,2,7]\n[4,5,3]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "from typing import List\n\nclass Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        ops = 0\n        \n        # Sort both arrays to make it easier to decide which elements to swap\n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0  # Pointers for nums1 and nums2 respectively\n        \n        # While loop until one of the pointers reaches the end\n        while i < n and j < n:\n            if nums1[n-1] == max(nums1) and nums2[n-1] == max(nums2):\n                return ops  # Both conditions are satisfied\n            \n            # Find the maximum of the current and next elements to decide on swapping\n            if nums1[n-1] < nums2[j] or nums2[n-1] < nums1[i]:\n                if nums1[i] < nums2[j]:\n                    nums1[n-1], nums2[j] = nums2[j], nums1[n-1]\n                else:\n                    nums1[i], nums2[n-1] = nums2[n-1], nums1[i]\n                ops += 1  # Increment operation count\n                nums1.sort()  # Re-sort nums1\n                nums2.sort()  # Re-sort nums2\n            \n            # Move the pointers\n            if nums1[i] <= nums2[j]:\n                i += 1\n            else:\n                j += 1\n        \n        if nums1[n-1] != max(nums1) or nums2[n-1] != max(nums2):\n            return -1  # It's not possible to satisfy the conditions\n        \n        return ops"
}