{
    "status_code": 15,
    "lang": "elixir",
    "run_success": false,
    "runtime_error": "Line 12: ** (ArgumentError) the Access module does not support accessing lists by index, got: 1",
    "full_runtime_error": "Line 12: ** (ArgumentError) the Access module does not support accessing lists by index, got: 1\nAccessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module\n    (elixir 1.15.7) lib/access.ex:334: Access.get/3\n    solution.ex:12: anonymous fn/5 in Solution.max_non_decreasing_length/2\n    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3\n    solution.ex:8: Solution.max_non_decreasing_length/2\n    solution.ex:56: Driver.consume_test_cases/2\n    solution.ex:42: Driver.start/0\n    nofile:1: (file)",
    "status_runtime": "N/A",
    "memory": 74608000,
    "question_id": "2869",
    "elapsed_time": 347,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[2,3,1]\n[1,2,1]",
    "expected_output": "2",
    "task_finish_time": 1707525679672,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 2973,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1171032807",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec max_non_decreasing_length(nums1 :: [integer], nums2 :: [integer]) :: integer\n  def max_non_decreasing_length(nums1, nums2) do\n    n = length(nums1)\n    dp = :array.new(n, default: {0, 0})\n    dp = :array.set(0, {1, 1}, dp)\n\n    for i <- 1..n-1 do\n      {prev1, prev2} = :array.get(i-1, dp)\n      {cur1, cur2} = {1, 1}\n\n      if nums1[i] >= nums1[i-1] do\n        cur1 = max(cur1, prev1 + 1)\n      end\n\n      if nums2[i] >= nums2[i-1] do\n        cur2 = max(cur2, prev2 + 1)\n      end\n\n      if nums1[i] >= nums2[i-1] do\n        cur1 = max(cur1, prev2 + 1)\n      end\n\n      if nums2[i] >= nums1[i-1] do\n        cur2 = max(cur2, prev1 + 1)\n      end\n\n      dp = :array.set(i, {cur1, cur2}, dp)\n    end\n\n    max_vals = Enum.map(0..n-1, fn i -> \n      {v1, v2} = :array.get(i, dp)\n      max(v1, v2)\n    end)\n\n    Enum.max(max_vals)\n  end\nend"
}