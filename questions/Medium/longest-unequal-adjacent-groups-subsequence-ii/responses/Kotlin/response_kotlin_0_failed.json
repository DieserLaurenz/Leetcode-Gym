{
    "status_code": 14,
    "lang": "kotlin",
    "run_success": false,
    "status_runtime": "N/A",
    "memory": 31560000,
    "question_id": "3142",
    "elapsed_time": 5143,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "expected_output": "[\"bab\",\"cab\"]",
    "task_finish_time": 1707536582964,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Kotlin",
    "submission_id": "1171093878",
    "status_msg": "Time Limit Exceeded",
    "state": "SUCCESS",
    "code": "class Solution {\n    fun getWordsInLongestSubsequence(n: Int, words: Array<String>, groups: IntArray): List<String> {\n        val graph = Array(n) { mutableListOf<Int>() }\n        for (i in 0 until n) {\n            for (j in i + 1 until n) {\n                if (words[i].length == words[j].length && groups[i] != groups[j] && hammingDistance(words[i], words[j]) == 1) {\n                    graph[i].add(j)\n                    graph[j].add(i)\n                }\n            }\n        }\n\n        var maxLength = 0\n        var endIndex = -1\n        val visited = BooleanArray(n)\n        val dp = IntArray(n) { 1 }\n        val parent = IntArray(n) { -1 }\n\n        for (i in 0 until n) {\n            if (!visited[i]) {\n                dfs(i, graph, visited, dp, parent)\n            }\n            if (dp[i] > maxLength) {\n                maxLength = dp[i]\n                endIndex = i\n            }\n        }\n\n        val result = mutableListOf<String>()\n        while (endIndex != -1) {\n            result.add(0, words[endIndex])\n            endIndex = parent[endIndex]\n        }\n\n        return result\n    }\n\n    private fun dfs(current: Int, graph: Array<MutableList<Int>>, visited: BooleanArray, dp: IntArray, parent: IntArray) {\n        visited[current] = true\n        for (neighbour in graph[current]) {\n            if (!visited[neighbour]) {\n                dfs(neighbour, graph, visited, dp, parent)\n            }\n            if (dp[current] < dp[neighbour] + 1) {\n                dp[current] = dp[neighbour] + 1\n                parent[current] = neighbour\n            }\n        }\n    }\n\n    private fun hammingDistance(word1: String, word2: String): Int {\n        var count = 0\n        for (i in word1.indices) {\n            if (word1[i] != word2[i]) count++\n        }\n        return count\n    }\n}"
}