{
    "status_code": 12,
    "lang": "kotlin",
    "run_success": false,
    "status_runtime": "N/A",
    "memory": 167720000,
    "question_id": "3142",
    "elapsed_time": 437,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "expected_output": "[\"bab\",\"cab\"]",
    "task_finish_time": 1707536620384,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Kotlin",
    "submission_id": "1171094157",
    "status_msg": "Memory Limit Exceeded",
    "state": "SUCCESS",
    "code": "class Solution {\n    fun getWordsInLongestSubsequence(n: Int, words: Array<String>, groups: IntArray): List<String> {\n        val adj = MutableList(n) { mutableListOf<Int>() }\n        for (i in 0 until n) {\n            for (j in 0 until i) {\n                if (groups[i] != groups[j] && words[i].length == words[j].length && hammingDistance(words[i], words[j]) == 1) {\n                    adj[i].add(j)\n                    adj[j].add(i)\n                }\n            }\n        }\n\n        var maxPath = listOf<Int>()\n        for (i in 0 until n) {\n            val path = findLongestPathFromNode(i, adj, n)\n            if (path.size > maxPath.size) {\n                maxPath = path\n            }\n        }\n\n        return maxPath.map { words[it] }\n    }\n\n    private fun findLongestPathFromNode(node: Int, adj: List<List<Int>>, n: Int): List<Int> {\n        val dp = MutableList(n) { -1 }\n        val nextNode = MutableList(n) { -1 }\n        var maxLength = 0\n        var startNode = node\n\n        fun dfs(v: Int): Int {\n            if (dp[v] != -1) return dp[v]\n            dp[v] = 1\n            for (u in adj[v]) {\n                val candidateLength = dfs(u) + 1\n                if (candidateLength > dp[v]) {\n                    dp[v] = candidateLength\n                    nextNode[v] = u\n                }\n            }\n            if (dp[v] > maxLength) {\n                maxLength = dp[v]\n                startNode = v\n            }\n            return dp[v]\n        }\n\n        dfs(node)\n\n        val path = mutableListOf<Int>()\n        var current = startNode\n        while (current != -1) {\n            path.add(current)\n            current = nextNode[current]\n        }\n        return path\n    }\n\n    private fun hammingDistance(a: String, b: String): Int {\n        var diff = 0\n        for (i in a.indices) {\n            if (a[i] != b[i]) diff++\n        }\n        return diff\n    }\n}"
}