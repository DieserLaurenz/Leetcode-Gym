{
    "status_code": 10,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "157 ms",
    "memory": 21992000,
    "question_id": "3142",
    "elapsed_time": 183,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1707537232517,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 441,
    "total_testcases": 441,
    "runtime_percentile": 33.33339999999999,
    "status_memory": "22 MB",
    "memory_percentile": 33.33339999999999,
    "pretty_lang": "Rust",
    "submission_id": "1171098393",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn get_words_in_longest_subsequence(n: i32, words: Vec<String>, groups: Vec<i32>) -> Vec<String> {\n        let mut dp = vec![vec![0; n as usize]; n as usize];\n        let mut next = vec![vec![None; n as usize]; n as usize];\n        let mut max_len = 1;\n        let mut last_index = 0;\n\n        for i in 0..n as usize {\n            dp[i][i] = 1;\n            for j in 0..i {\n                if words[i].len() == words[j].len() && groups[i] != groups[j] {\n                    let mut diff = 0;\n                    for (a, b) in words[i].chars().zip(words[j].chars()) {\n                        if a != b {\n                            diff += 1;\n                        }\n                    }\n                    if diff == 1 {\n                        for k in 0..n as usize {\n                            if dp[j][k] + 1 > dp[i][k] {\n                                dp[i][k] = dp[j][k] + 1;\n                                next[i][k] = Some(j);\n                                if dp[i][k] > max_len {\n                                    max_len = dp[i][k];\n                                    last_index = k;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        let mut sequence = Vec::new();\n        let mut current = None;\n        for i in 0..n as usize {\n            if dp[i][last_index] == max_len {\n                current = Some(i);\n                break;\n            }\n        }\n        while let Some(idx) = current {\n            sequence.push(words[idx].clone());\n            current = next[idx][last_index];\n        }\n        sequence.reverse();\n        sequence\n    }\n}"
}