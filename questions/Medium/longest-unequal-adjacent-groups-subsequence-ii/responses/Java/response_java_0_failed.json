{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 45652000,
    "display_runtime": "107",
    "question_id": "3142",
    "elapsed_time": 288,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111011111011111010111110101111001111011011111111000101111101101111011111111110100111110111011000100110111110111011101001001100100010111000101111100001001010011110111111101001001110101111110101001000010110010110010001010101011000000000001010100000001100000001000001000000001010000000001010000010001000000110000000000000000000000111111111111111111111111111111111110000",
    "code_output": "[\"bd\",\"bb\",\"cb\"]",
    "std_output": "",
    "last_testcase": "7\n[\"bd\",\"dbd\",\"dcc\",\"cb\",\"ac\",\"abd\",\"bb\"]\n[1,3,3,6,6,4,5]",
    "expected_output": "[\"cb\",\"bb\"]",
    "task_finish_time": 1707536056568,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 267,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1171090338",
    "input_formatted": "7, [\"bd\",\"dbd\",\"dcc\",\"cb\",\"ac\",\"abd\",\"bb\"], [1,3,3,6,6,4,5]",
    "input": "7\n[\"bd\",\"dbd\",\"dcc\",\"cb\",\"ac\",\"abd\",\"bb\"]\n[1,3,3,6,6,4,5]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    public List<String> getWordsInLongestSubsequence(int n, String[] words, int[] groups) {\n        List<Integer>[] graph = new List[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (groups[i] != groups[j] && words[i].length() == words[j].length() && hammingDistance(words[i], words[j]) == 1) {\n                    graph[i].add(j);\n                    graph[j].add(i);\n                }\n            }\n        }\n\n        boolean[] visited = new boolean[n];\n        List<String> result = new ArrayList<>();\n        List<String> temp = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                temp.clear();\n                dfs(graph, words, visited, i, temp);\n                if (temp.size() > result.size()) {\n                    result = new ArrayList<>(temp);\n                }\n            }\n        }\n        return result;\n    }\n\n    private void dfs(List<Integer>[] graph, String[] words, boolean[] visited, int current, List<String> temp) {\n        visited[current] = true;\n        temp.add(words[current]);\n        for (Integer next : graph[current]) {\n            if (!visited[next]) {\n                dfs(graph, words, visited, next, temp);\n                break; // Only extend to one direction to maintain sequence\n            }\n        }\n    }\n\n    private int hammingDistance(String s1, String s2) {\n        int count = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"
}