{
    "status_code": 11,
    "lang": "golang",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 7640000,
    "question_id": "3142",
    "elapsed_time": 3010,
    "compare_result": "011111111111111111111111111111111111111111111111111111111111011111111111111111011110011011010111110101001001010011011011111000101101001001110001111111010100111110110010000100110111110111011100001001100100010101000100111100001001010001000111010101001000000100001100000000000010100010010010001000100000000000000000010000000001100000000000000000000000000000000000000000010001000000000000000000000000000000111111111111111111111111111111111000000",
    "code_output": "[\"dab\",\"bab\",\"cab\"]",
    "std_output": "",
    "last_testcase": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "expected_output": "[\"bab\",\"cab\"]",
    "task_finish_time": 1707536787944,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 214,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Go",
    "submission_id": "1171095299",
    "input_formatted": "3, [\"bab\",\"dab\",\"cab\"], [1,2,2]",
    "input": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "func getWordsInLongestSubsequence(n int, words []string, groups []int) []string {\n    if n == 1 {\n        return words\n    }\n\n    graph := make([][]int, n)\n    for i := 0; i < n; i++ {\n        for j := i + 1; j < n; j++ {\n            diffs := 0\n            if len(words[i]) == len(words[j]) {\n                for k := 0; k < len(words[i]); k++ {\n                    if words[i][k] != words[j][k] {\n                        diffs++\n                    }\n                }\n                if diffs == 1 && groups[i] != groups[j] {\n                    graph[i] = append(graph[i], j)\n                    graph[j] = append(graph[j], i)\n                }\n            }\n        }\n    }\n\n    maxPath := []int{}\n    var dfs func(node int, path []int)\n    visited := make([]bool, n)\n\n    dfs = func(node int, path []int) {\n        visited[node] = true\n        path = append(path, node)\n\n        if len(path) > len(maxPath) {\n            maxPath = make([]int, len(path))\n            copy(maxPath, path)\n        }\n\n        for _, next := range graph[node] {\n            if !visited[next] {\n                dfs(next, path)\n            }\n        }\n\n        path = path[:len(path)-1]\n        visited[node] = false\n    }\n\n    for i := 0; i < n; i++ {\n        dfs(i, []int{})\n    }\n\n    result := make([]string, len(maxPath))\n    for i, idx := range maxPath {\n        result[i] = words[idx]\n    }\n    return result\n}"
}