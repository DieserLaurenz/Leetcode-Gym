{
    "status_code": 10,
    "lang": "golang",
    "run_success": true,
    "status_runtime": "33 ms",
    "memory": 4964000,
    "question_id": "3142",
    "elapsed_time": 49,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1707536823138,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 441,
    "total_testcases": 441,
    "runtime_percentile": 50.0,
    "status_memory": "5 MB",
    "memory_percentile": 50.0,
    "pretty_lang": "Go",
    "submission_id": "1171095570",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "func getWordsInLongestSubsequence(n int, words []string, groups []int) []string {\n    // Edge case: If there's only one word, it's trivially the longest subsequence\n    if n == 1 {\n        return words\n    }\n\n    // Function to check if two words have a Hamming distance of 1\n    hammingDistanceOne := func(word1, word2 string) bool {\n        if len(word1) != len(word2) {\n            return false\n        }\n        diff := 0\n        for i := range word1 {\n            if word1[i] != word2[i] {\n                diff++\n            }\n        }\n        return diff == 1\n    }\n\n    // Dynamic programming table to store the length of the longest valid subsequence ending at each word\n    dp := make([]int, n)\n    // For tracking the predecessor of each word in the optimal subsequence\n    pred := make([]int, n)\n    for i := range pred {\n        pred[i] = -1 // Initialize predecessors with -1\n    }\n\n    maxLength := 0\n    lastIndex := -1\n\n    // Main DP loop\n    for i := 0; i < n; i++ {\n        dp[i] = 1 // Each word is at least a subsequence of length 1 by itself\n        for j := 0; j < i; j++ {\n            if hammingDistanceOne(words[i], words[j]) && groups[i] != groups[j] && dp[j]+1 > dp[i] {\n                dp[i] = dp[j] + 1\n                pred[i] = j\n            }\n        }\n        if dp[i] > maxLength {\n            maxLength = dp[i]\n            lastIndex = i\n        }\n    }\n\n    // Reconstruct the longest subsequence\n    sequence := make([]string, maxLength)\n    for i := lastIndex; i != -1; i = pred[i] {\n        sequence[maxLength-1] = words[i]\n        maxLength--\n    }\n\n    return sequence\n}"
}