{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "vector-ref: contract violation",
    "full_runtime_error": "vector-ref: contract violation\n  expected: vector?\n  given: '(1 2 2)\n  context...:\n   solution.rkt:1:0: get-words-in-longest-subsequence\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:50:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 99864000,
    "question_id": "3142",
    "elapsed_time": 229,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "expected_output": "[\"bab\",\"cab\"]",
    "task_finish_time": 1707537355157,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1171099285",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (get-words-in-longest-subsequence n words groups)\n  (-> exact-integer? (listof string?) (listof exact-integer?) (listof string?))\n\n  (define (hamming-distance s1 s2)\n    (let loop ([i 0] [count 0])\n      (if (= i (string-length s1))\n          count\n          (loop (+ i 1) (if (not (char=? (string-ref s1 i) (string-ref s2 i)))\n                            (+ count 1)\n                            count)))))\n\n  (define (build-graph)\n    (let ([graph (make-vector n '())])\n      (for ([i (in-range n)])\n        (for ([j (in-range n)])\n          (when (and (not (= (vector-ref groups i) (vector-ref groups j)))\n                     (= (string-length (vector-ref words i)) (string-length (vector-ref words j)))\n                     (= 1 (hamming-distance (vector-ref words i) (vector-ref words j))))\n            (vector-set! graph i (cons j (vector-ref graph i))))))\n      graph))\n\n  (define (dfs graph node visited path)\n    (if (vector-ref visited node)\n        path\n        (let ([new-path (cons (vector-ref words node) path)])\n          (vector-set! visited node #t)\n          (foldl (lambda (next acc-path)\n                   (if (vector-ref visited next)\n                       acc-path\n                       (dfs graph next visited acc-path)))\n                 new-path\n                 (vector-ref graph node)))))\n\n  (define (find-longest-path graph)\n    (let ([visited (make-vector n #f)])\n      (let loop ([i 0] [longest-path '()])\n        (if (= i n)\n            longest-path\n            (let ([path (dfs graph i visited '())])\n              (if (> (length path) (length longest-path))\n                  (loop (+ i 1) path)\n                  (loop (+ i 1) longest-path)))))))\n\n  (let ([graph (build-graph)])\n    (reverse (find-longest-path graph))))"
}