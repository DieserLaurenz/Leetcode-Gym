{
    "status_code": 11,
    "lang": "ruby",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 243172000,
    "question_id": "3142",
    "elapsed_time": 3148,
    "compare_result": "011111111111111111111111111111111111111111111111111111111111011111111111111111011110011011010111110101001001010011011011111000101101001001110001111111010100111110110010000100110111110111011100001001100100010101000100111100001001010001000111010101001000000100001100000000000010100010010010001000100000000000000000010000000001100000000000000000000000000000000000000000010001000000000000000000000000000000111111111111111111111111111111111000000",
    "code_output": "[\"dab\",\"bab\",\"cab\"]",
    "std_output": "",
    "last_testcase": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "expected_output": "[\"bab\",\"cab\"]",
    "task_finish_time": 1707536944159,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 214,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Ruby",
    "submission_id": "1171096386",
    "input_formatted": "3, [\"bab\",\"dab\",\"cab\"], [1,2,2]",
    "input": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "# @param {Integer} n\n# @param {String[]} words\n# @param {Integer[]} groups\n# @return {String[]}\ndef get_words_in_longest_subsequence(n, words, groups)\n  adj = Array.new(n) { [] }\n  (0...n).each do |i|\n    (i+1...n).each do |j|\n      if words[i].length == words[j].length && hamming_distance(words[i], words[j]) == 1 && groups[i] != groups[j]\n        adj[i] << j\n        adj[j] << i\n      end\n    end\n  end\n\n  best_sequence = []\n  (0...n).each do |i|\n    sequence = dfs(i, adj, words, groups, [i], {})\n    best_sequence = sequence if sequence.length > best_sequence.length\n  end\n\n  best_sequence.map { |i| words[i] }\nend\n\ndef hamming_distance(s1, s2)\n  s1.chars.zip(s2.chars).count { |c1, c2| c1 != c2 }\nend\n\ndef dfs(node, adj, words, groups, path, memo)\n  return memo[node] if memo[node]\n  best = path\n  adj[node].each do |nei|\n    next if path.include?(nei) || groups[path.last] == groups[nei]\n    new_path = dfs(nei, adj, words, groups, path + [nei], memo)\n    best = new_path if new_path.length > best.length\n  end\n  memo[node] = best\n  best\nend"
}