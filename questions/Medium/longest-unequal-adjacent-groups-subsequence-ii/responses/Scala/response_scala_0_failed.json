{
    "status_code": 11,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 371548000,
    "question_id": "3142",
    "elapsed_time": 10202,
    "compare_result": "000000000000000000000000001001000000000100000000100110010000010001101001100100000010010010000010000001000000000011001000000000100100000001100001000010010000110100110000000000110110110001001100001001100100010101000100111100001000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "[\"bab\",\"cab\",\"bab\",\"dab\"]",
    "std_output": "",
    "last_testcase": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "expected_output": "[\"bab\",\"cab\"]",
    "task_finish_time": 1707537011374,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 57,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Scala",
    "submission_id": "1171096811",
    "input_formatted": "3, [\"bab\",\"dab\",\"cab\"], [1,2,2]",
    "input": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "object Solution {\n    def getWordsInLongestSubsequence(n: Int, words: Array[String], groups: Array[Int]): List[String] = {\n        def hammingDistance(s1: String, s2: String): Int = s1.zip(s2).count { case (c1, c2) => c1 != c2 }\n\n        val edges = for {\n            i <- 0 until n\n            j <- i + 1 until n\n            if words(i).length == words(j).length && hammingDistance(words(i), words(j)) == 1 && groups(i) != groups(j)\n        } yield (i, j)\n\n        val graph = edges.foldLeft(Map.empty[Int, List[Int]]) {\n            case (acc, (src, dst)) => acc.updated(src, dst :: acc.getOrElse(src, Nil)).updated(dst, src :: acc.getOrElse(dst, Nil))\n        }\n\n        def dfs(node: Int, visited: Set[Int], path: List[Int]): List[Int] = {\n            if (visited.contains(node)) path\n            else {\n                val newVisited = visited + node\n                graph.getOrElse(node, Nil).foldLeft(path)((acc, n) => dfs(n, newVisited, node :: acc))\n            }\n        }\n\n        val longestPath = graph.keys.foldLeft(List.empty[Int]) {\n            case (acc, node) => {\n                val path = dfs(node, Set.empty, Nil)\n                if (path.length > acc.length) path.reverse else acc\n            }\n        }\n\n        longestPath.map(words)\n    }\n}"
}