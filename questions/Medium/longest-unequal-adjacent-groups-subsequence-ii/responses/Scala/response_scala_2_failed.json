{
    "status_code": 11,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 61504000,
    "question_id": "3142",
    "elapsed_time": 10131,
    "compare_result": "011111111111111111111111111111111111111111111111111111111111011111111111111111011110011011010111110101001001010011011011111000101101001001110001111111010100111110110010000100110111110111011100001001100100010101000100111100001001010001000111010101001000000100001100000000000010100010010010001000100000000000000000010000000001100000000000000000000000000000000000000000010001000000000000000000000000000000111111111111111111111111111111111000000",
    "code_output": "[\"dab\",\"bab\",\"cab\"]",
    "std_output": "",
    "last_testcase": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "expected_output": "[\"bab\",\"cab\"]",
    "task_finish_time": 1707537081446,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 214,
    "total_testcases": 441,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Scala",
    "submission_id": "1171097272",
    "input_formatted": "3, [\"bab\",\"dab\",\"cab\"], [1,2,2]",
    "input": "3\n[\"bab\",\"dab\",\"cab\"]\n[1,2,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "object Solution {\n    def getWordsInLongestSubsequence(n: Int, words: Array[String], groups: Array[Int]): List[String] = {\n        val adj = Array.fill(n)(scala.collection.mutable.ListBuffer[Int]())\n        for (i <- words.indices; j <- i + 1 until words.length) {\n            if (words(i).length == words(j).length && groups(i) != groups(j)) {\n                val hamming = words(i).zip(words(j)).count { case (a, b) => a != b }\n                if (hamming == 1) {\n                    adj(i).append(j)\n                    adj(j).append(i)\n                }\n            }\n        }\n\n        var maxPath = List[Int]()\n\n        def dfs(v: Int, path: List[Int]): Unit = {\n            if (path.length > maxPath.length) maxPath = path\n            adj(v).foreach { u =>\n                if (!path.contains(u)) dfs(u, u :: path)\n            }\n        }\n\n        for (i <- words.indices) {\n            dfs(i, List(i))\n        }\n\n        maxPath.reverse.map(words)\n    }\n}"
}