{
    "status_code": 10,
    "lang": "typescript",
    "run_success": true,
    "status_runtime": "117 ms",
    "memory": 53508000,
    "question_id": "3142",
    "elapsed_time": 125,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1707536372056,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 441,
    "total_testcases": 441,
    "runtime_percentile": 100,
    "status_memory": "53.5 MB",
    "memory_percentile": 100,
    "pretty_lang": "TypeScript",
    "submission_id": "1171092477",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "function getWordsInLongestSubsequence(n: number, words: string[], groups: number[]): string[] {\n    // Helper function to check if the hamming distance between two strings is 1\n    const hammingDistanceIsOne = (a: string, b: string): boolean => {\n        let diff = 0;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] !== b[i]) diff++;\n            if (diff > 1) return false;\n        }\n        return diff === 1;\n    };\n\n    // Dynamic programming table to keep track of the longest subsequence ending at each index\n    const dp = Array(n).fill(1);\n    const parent = Array(n).fill(-1); // To reconstruct the sequence\n    let maxLen = 1, lastIndex = 0;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (groups[i] !== groups[j] && words[i].length === words[j].length && hammingDistanceIsOne(words[i], words[j]) && dp[j] + 1 > dp[i]) {\n                dp[i] = dp[j] + 1;\n                parent[i] = j; // Store the predecessor\n                if (dp[i] > maxLen) {\n                    maxLen = dp[i];\n                    lastIndex = i;\n                }\n            }\n        }\n    }\n\n    // Reconstruct the longest subsequence\n    const sequence = [];\n    while (lastIndex !== -1) {\n        sequence.unshift(words[lastIndex]);\n        lastIndex = parent[lastIndex];\n    }\n\n    return sequence;\n};"
}