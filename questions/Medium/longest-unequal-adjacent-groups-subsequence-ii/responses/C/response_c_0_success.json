{
    "status_code": 10,
    "lang": "c",
    "run_success": true,
    "status_runtime": "109 ms",
    "memory": 6948000,
    "question_id": "3142",
    "elapsed_time": 122,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1707536187435,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 441,
    "total_testcases": 441,
    "runtime_percentile": 100,
    "status_memory": "6.9 MB",
    "memory_percentile": 100,
    "pretty_lang": "C",
    "submission_id": "1171091236",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <stdlib.h>\n#include <string.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** getWordsInLongestSubsequence(int n, char** words, int wordsSize, int* groups, int groupsSize, int* returnSize) {\n    // Helper function to calculate hamming distance\n    int hammingDistance(const char* s1, const char* s2) {\n        int distance = 0;\n        while (*s1) {\n            if (*s1++ != *s2++) distance++;\n        }\n        return distance;\n    }\n\n    // Dynamic programming table\n    int dp[n];\n    int prev[n];\n    memset(dp, 0, sizeof(dp));\n    memset(prev, -1, sizeof(prev));\n\n    // Initial setup\n    for (int i = 0; i < n; i++) dp[i] = 1;\n\n    // Compute longest subsequence\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (groups[i] != groups[j] && strlen(words[i]) == strlen(words[j]) && hammingDistance(words[i], words[j]) == 1) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    prev[i] = j;\n                }\n            }\n        }\n    }\n\n    // Find the end of the longest subsequence\n    int maxIndex = 0;\n    for (int i = 1; i < n; i++) {\n        if (dp[i] > dp[maxIndex]) maxIndex = i;\n    }\n\n    // Backtrack to find the sequence\n    *returnSize = dp[maxIndex];\n    char** result = (char**)malloc(*returnSize * sizeof(char*));\n    int currentIndex = maxIndex;\n    for (int i = *returnSize - 1; i >= 0; i--) {\n        result[i] = words[currentIndex];\n        currentIndex = prev[currentIndex];\n    }\n\n    return result;\n}"
}