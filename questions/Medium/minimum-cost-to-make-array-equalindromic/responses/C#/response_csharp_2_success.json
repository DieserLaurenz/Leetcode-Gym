{
    "status_code": 10,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "224 ms",
    "memory": 64864000,
    "question_id": "3229",
    "elapsed_time": 323,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1707774303924,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 648,
    "total_testcases": 648,
    "runtime_percentile": 48.8086,
    "status_memory": "64.9 MB",
    "memory_percentile": 27.379900000000006,
    "pretty_lang": "C#",
    "submission_id": "1173581164",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public long MinimumCost(int[] nums) {\n        long minCost = long.MaxValue;\n        // Since we need to convert all elements to a single palindromic number,\n        // the optimal strategy does not necessarily involve converting all numbers to their average.\n        // We sort the array to work with median(s) for minimized absolute differences.\n        Array.Sort(nums);\n        int n = nums.Length;\n        // Check for the closest palindromic number around the median(s)\n        // If the array length is odd, we check around the median. If even, we check around the two middle elements.\n        int[] medianCandidates;\n        if (n % 2 == 0) {\n            medianCandidates = new int[] { nums[n / 2 - 1], nums[n / 2] };\n        } else {\n            medianCandidates = new int[] { nums[n / 2] };\n        }\n\n        // Extending the search to nearby palindromic numbers might be necessary,\n        // but for efficiency, we initially focus on the median or the middle elements themselves.\n        foreach (var candidate in medianCandidates) {\n            // Directly using the candidate if it's already a palindrome\n            if (IsPalindrome(candidate)) {\n                long cost = 0;\n                foreach (int num in nums) {\n                    cost += Math.Abs(num - candidate);\n                }\n                minCost = Math.Min(minCost, cost);\n            } else {\n                // Generating palindromic numbers close to the candidate\n                var palindromes = GenerateClosestPalindromes(candidate);\n                foreach (var pal in palindromes) {\n                    long cost = 0;\n                    foreach (int num in nums) {\n                        cost += Math.Abs(num - pal);\n                    }\n                    minCost = Math.Min(minCost, cost);\n                }\n            }\n        }\n\n        return minCost;\n    }\n\n    private bool IsPalindrome(int num) {\n        var str = num.ToString();\n        for (int i = 0, j = str.Length - 1; i < j; i++, j--) {\n            if (str[i] != str[j]) return false;\n        }\n        return true;\n    }\n\n    private List<int> GenerateClosestPalindromes(int num) {\n        var list = new List<int>();\n        // Adding the number itself in case it's already a palindrome\n        if (IsPalindrome(num)) list.Add(num);\n        // Generating next larger palindrome\n        for (int i = num + 1; ; i++) {\n            if (IsPalindrome(i)) {\n                list.Add(i);\n                break;\n            }\n        }\n        // Generating previous smaller palindrome\n        for (int i = num - 1; i > 0; i--) {\n            if (IsPalindrome(i)) {\n                list.Add(i);\n                break;\n            }\n        }\n        return list;\n    }\n}"
}