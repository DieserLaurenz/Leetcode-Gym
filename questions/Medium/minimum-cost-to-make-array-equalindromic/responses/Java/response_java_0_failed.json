{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 56328000,
    "display_runtime": "15",
    "question_id": "3229",
    "elapsed_time": 253,
    "compare_result": "101111111111111111111111111111111111111111001000001000001000100000000000000000000000000011110111111111111011111111111111111111111111111101010111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111110111000001111100001011000010110000000010001011111111011111000000000110100110000000110111100110000000000011101111111000000001110111011110000000010111110101000001111111000000111000011000111000000111111100000001110001111110000001110100011100000001110000011011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
    "code_output": "7",
    "std_output": "",
    "last_testcase": "[10,12,13,14,15]",
    "expected_output": "11",
    "task_finish_time": 1707773943088,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 456,
    "total_testcases": 648,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1173578010",
    "input_formatted": "[10,12,13,14,15]",
    "input": "[10,12,13,14,15]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    public long minimumCost(int[] nums) {\n        long totalCost = 0;\n        int median = findMedian(nums);\n        for (int num : nums) {\n            totalCost += Math.abs(num - median);\n        }\n        return totalCost;\n    }\n\n    private int findMedian(int[] nums) {\n        java.util.Arrays.sort(nums);\n        int n = nums.length;\n        if (n % 2 == 1) {\n            return nums[n / 2];\n        } else {\n            // In case of an even number of elements, choose the closest palindromic number between the two middle elements\n            int mid1 = nums[n / 2 - 1];\n            int mid2 = nums[n / 2];\n            int palindromic1 = closestPalindrome(mid1);\n            int palindromic2 = closestPalindrome(mid2);\n            long cost1 = 0, cost2 = 0;\n            for (int num : nums) {\n                cost1 += Math.abs(num - palindromic1);\n                cost2 += Math.abs(num - palindromic2);\n            }\n            return cost1 <= cost2 ? palindromic1 : palindromic2;\n        }\n    }\n\n    private int closestPalindrome(int num) {\n        if (isPalindrome(num)) return num;\n        int higher = num + 1;\n        while (!isPalindrome(higher)) ++higher;\n        int lower = num - 1;\n        while (lower > 0 && !isPalindrome(lower)) --lower;\n        return (num - lower) <= (higher - num) ? lower : higher;\n    }\n\n    private boolean isPalindrome(int num) {\n        int original = num, reversed = 0;\n        while (num != 0) {\n            int digit = num % 10;\n            reversed = reversed * 10 + digit;\n            num /= 10;\n        }\n        return original == reversed;\n    }\n}"
}