{
    "status_code": 15,
    "lang": "cpp",
    "run_success": false,
    "runtime_error": "AddressSanitizer: heap-use-after-free on address 0x502000000050 at pc 0x55833ca589f6 bp 0x7fffc1de6310 sp 0x7fffc1de6308",
    "full_runtime_error": "=================================================================\n==23==ERROR: AddressSanitizer: heap-use-after-free on address 0x502000000050 at pc 0x55833ca589f6 bp 0x7fffc1de6310 sp 0x7fffc1de6308\nREAD of size 8 at 0x502000000050 thread T0\n    #2 0x7fb88fdcad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)\n    #3 0x7fb88fdcae3f  (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)\n0x502000000050 is located 0 bytes inside of 8-byte region [0x502000000050,0x502000000058)\nfreed by thread T0 here:\n    #6 0x7fb88fdcad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)\npreviously allocated by thread T0 here:\n    #6 0x7fb88fdcad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f) (BuildId: c289da5071a3399de893d2af81d6a30c62646e1e)\nShadow bytes around the buggy address:\n  0x501ffffffd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x501ffffffe00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x501ffffffe80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x501fffffff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x501fffffff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x502000000000: fa fa fd fa fa fa fd fa fa fa[fd]fa fa fa fa fa\n  0x502000000080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000180: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000200: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x502000000280: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==23==ABORTING",
    "status_runtime": "N/A",
    "memory": 8204000,
    "question_id": "2802",
    "elapsed_time": 12,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "10",
    "expected_output": "182",
    "task_finish_time": 1707355563513,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 216,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1169286003",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "class Solution {\npublic:\n    int punishmentNumber(int n) {\n        auto canPartition = [](int i, int square) {\n            string squareStr = to_string(square);\n            int length = squareStr.length();\n            vector<vector<bool>> dp(length + 1, vector<bool>(i + 1, false));\n            dp[0][0] = true;\n            for (int j = 1; j <= length; j++) {\n                for (int k = 0; k <= i; k++) {\n                    dp[j][k] = dp[j - 1][k]; // not take the current digit\n                    if (k - (squareStr[j - 1] - '0') >= 0) {\n                        int val = 0;\n                        for (int l = j; l > 0; l--) {\n                            val += (squareStr[l - 1] - '0') * pow(10, j - l);\n                            if (val > k) break; // optimization to stop early\n                            if (k - val >= 0 && dp[l - 1][k - val]) {\n                                dp[j][k] = true;\n                                break; // found a valid partition\n                            }\n                        }\n                    }\n                }\n            }\n            return dp[length][i];\n        };\n\n        int sum = 0;\n        for (int i = 1; i <= n; ++i) {\n            int square = i * i;\n            if (canPartition(i, square)) sum += square;\n        }\n        return sum;\n    }\n};"
}