{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 72052000,
    "question_id": "3046",
    "elapsed_time": 723,
    "compare_result": "000111111111111111111011110111101111111110111111111011111111101111111110111101111011111111101111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000001010",
    "code_output": "7",
    "std_output": "",
    "last_testcase": "\"2245047\"",
    "expected_output": "2",
    "task_finish_time": 1707917242112,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 93,
    "total_testcases": 813,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1175132161",
    "input_formatted": "\"2245047\"",
    "input": "\"2245047\"",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec minimum_operations(num :: String.t) :: integer\n  def minimum_operations(num) do\n    # Define the suffixes that make a number special if it ends with them\n    suffixes = [\"00\", \"25\", \"50\", \"75\"]\n\n    # Convert the string num into a list of characters and get the length\n    chars = String.graphemes(num)\n    len = length(chars)\n\n    # Initialize the minimum operations to a high number\n    min_ops = len\n\n    # Iterate through each suffix\n    for suffix <- suffixes do\n      # Initialize variables for counting operations and checking the suffix\n      ops = 0\n      found = false\n      suffix_chars = String.graphemes(suffix)\n\n      # Iterate backwards through the num characters to match the suffix\n      for {char, index} <- Enum.reverse(chars) |> Enum.with_index() do\n        if not found do\n          # Check if the current char matches the expected suffix character\n          if char == Enum.at(suffix_chars, -1 - ops) do\n            ops = ops + 1\n            # If both characters of the suffix are found, mark as found\n            found = ops == length(suffix_chars)\n          end\n        end\n\n        # If not found, this char would need to be deleted\n        if not found or (found and ops < length(suffix_chars)) do\n          ops = ops + 1\n        end\n      end\n\n      # Update the minimum operations if a new minimum is found\n      min_ops = if ops < min_ops, do: ops, else: min_ops\n    end\n\n    # Return the minimum operations required\n    min_ops\n  end\nend"
}