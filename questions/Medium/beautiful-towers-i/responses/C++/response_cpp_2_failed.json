{
    "status_code": 20,
    "lang": "cpp",
    "run_success": false,
    "compile_error": "Line 13: Char 23: error: no matching function for call to 'min'",
    "full_compile_error": "Line 13: Char 23: error: no matching function for call to 'min'\n   13 |             left[i] = std::min(maxHeights[i], left[i - 1]);\n      |                       ^~~~~~~~\n/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/algorithmfwd.h:420:5: note: candidate template ignored: deduced conflicting types for parameter '_Tp' ('value_type' (aka 'int') vs. 'value_type' (aka 'long long'))\n  411 |     min(const _Tp&, const _Tp&);\n      |     ^\n/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_algo.h:3455:5: note: candidate template ignored: could not match 'initializer_list<_Tp>' against 'value_type' (aka 'int')\n 3446 |     min(initializer_list<_Tp> __l, _Compare __comp)\n      |     ^\n/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_algo.h:3449:5: note: candidate function template not viable: requires single argument '__l', but 2 arguments were provided\n 3440 |     min(initializer_list<_Tp> __l)\n      |     ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/algorithmfwd.h:425:5: note: candidate function template not viable: requires 3 arguments, but 2 were provided\n  416 |     min(const _Tp&, const _Tp&, _Compare);\n      |     ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "status_runtime": "N/A",
    "memory": 0,
    "question_id": "3114",
    "task_finish_time": 1706741118496,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": null,
    "total_testcases": null,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1162431133",
    "status_msg": "Compile Error",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    long long maximumSumOfHeights(vector<int>& maxHeights) {\n        int n = maxHeights.size();\n        vector<long long> left(n, 0), right(n, 0);\n        \n        // Compute maximum heights descending to the left\n        left[0] = maxHeights[0];\n        for (int i = 1; i < n; ++i) {\n            left[i] = std::min(maxHeights[i], left[i - 1]);\n        }\n\n        // Compute maximum heights descending to the right\n        right[n - 1] = maxHeights[n - 1];\n        for (int i = n - 2; i >= 0; --i) {\n            right[i] = std::min(maxHeights[i], right[i + 1]);\n        }\n\n        long long maxSum = 0;\n\n        // Calculate the maximum sum for each possible peak\n        for (int peak = 0; peak < n; ++peak) {\n            long long sum = 0;\n            long long peakHeight = maxHeights[peak];\n            \n            // Sum to the left of the peak\n            for (int i = 0; i <= peak; ++i) {\n                long long height = std::min(peakHeight, left[i]);\n                sum += height;\n                peakHeight = std::max(1LL, peakHeight - 1); // Ensure non-increasing\n            }\n\n            peakHeight = maxHeights[peak];\n            // Sum to the right of the peak, excluding the peak itself\n            for (int i = n - 1; i > peak; --i) {\n                long long height = std::min(peakHeight, right[i]);\n                sum += height;\n                peakHeight = std::max(1LL, peakHeight - 1); // Ensure non-increasing\n            }\n\n            maxSum = std::max(maxSum, sum);\n        }\n\n        return maxSum;\n    }\n};"
}