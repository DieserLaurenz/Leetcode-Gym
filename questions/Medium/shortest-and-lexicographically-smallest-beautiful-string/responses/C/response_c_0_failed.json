{
    "status_code": 15,
    "lang": "c",
    "run_success": false,
    "runtime_error": "AddressSanitizer: SEGV on unknown address 0x55e48ba33870 (pc 0x7f57180cdb46 bp 0x55e48ba33880 sp 0x7fff33d90760 T0)",
    "full_runtime_error": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==22==ERROR: AddressSanitizer: SEGV on unknown address 0x55e48ba33870 (pc 0x7f57180cdb46 bp 0x55e48ba33880 sp 0x7fff33d90760 T0)\n==22==The signal is caused by a WRITE memory access.\n    #0 0x7f57180cdb46 in bool __sanitizer::atomic_compare_exchange_strong<__sanitizer::atomic_uint8_t>(__sanitizer::atomic_uint8_t volatile*, __sanitizer::atomic_uint8_t::Type*, __sanitizer::atomic_uint8_t::Type, __sanitizer::memory_order) ../../../../src/libsanitizer/sanitizer_common/sanitizer_atomic_clang.h:80\n    #1 0x7f57180cdb46 in __asan::Allocator::AtomicallySetQuarantineFlagIfAllocated(__asan::AsanChunk*, void*, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:621\n    #2 0x7f57180cdb46 in __asan::Allocator::Deallocate(void*, unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) ../../../../src/libsanitizer/asan/asan_allocator.cpp:697\n    #3 0x7f57180cdb46 in __asan::asan_free(void*, __sanitizer::BufferedStackTrace*, __asan::AllocType) ../../../../src/libsanitizer/asan/asan_allocator.cpp:971\n    #4 0x7f57181594f4 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:128\n    #7 0x7f5717789d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f5717789e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV ../../../../src/libsanitizer/sanitizer_common/sanitizer_atomic_clang.h:80 in bool __sanitizer::atomic_compare_exchange_strong<__sanitizer::atomic_uint8_t>(__sanitizer::atomic_uint8_t volatile*, __sanitizer::atomic_uint8_t::Type*, __sanitizer::atomic_uint8_t::Type, __sanitizer::memory_order)\n==22==ABORTING",
    "status_runtime": "N/A",
    "memory": 14016000,
    "question_id": "3150",
    "elapsed_time": 56,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"100011001\"\n3",
    "expected_output": "\"11001\"",
    "task_finish_time": 1708143892474,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 674,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C",
    "submission_id": "1177475669",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "#include <string.h>\n#include <stdlib.h>\n\nchar* shortestBeautifulSubstring(char* s, int k) {\n    int onesCount = 0, start = 0, minLen = INT_MAX;\n    char *result = \"\", *temp;\n    for (int i = 0; s[i] != '\\0'; ++i) {\n        onesCount += s[i] == '1';\n        if (onesCount == k) {\n            int j = start;\n            while (onesCount - (s[j] == '1') >= k) {\n                onesCount -= s[j] == '1';\n                ++j;\n            }\n            if (i - j + 1 < minLen) {\n                minLen = i - j + 1;\n                temp = (char*)malloc(sizeof(char) * (minLen + 1));\n                strncpy(temp, s + j, minLen);\n                temp[minLen] = '\\0';\n                free(result);\n                result = temp;\n            } else if (i - j + 1 == minLen) {\n                temp = (char*)malloc(sizeof(char) * (minLen + 1));\n                strncpy(temp, s + j, minLen);\n                temp[minLen] = '\\0';\n                if (strcmp(temp, result) < 0) {\n                    free(result);\n                    result = temp;\n                } else {\n                    free(temp);\n                }\n            }\n            onesCount -= s[start] == '1';\n            ++start;\n        }\n    }\n    if (minLen == INT_MAX) {\n        return \"\";\n    }\n    return result;\n}"
}