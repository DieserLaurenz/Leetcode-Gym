{
    "status_code": 11,
    "lang": "kotlin",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 39072000,
    "question_id": "2916",
    "elapsed_time": 270,
    "compare_result": "010111011110100000011111110010111110000011000000101011011100010010110100111111111101001111101110111111110111110101011011101100101011110001100001000111110101010011101111101000000010100000111100000110010111110000110011001011010000000000101000101111001001110000110110000111110111111111110010110010101101111110100111101111101111111110111110111111100101110111111000111111111001110100101010011101111010110000100100100111000011100010010101111011100000111010101100010100000101011101100111101000000001111110001010110011110001111101000110101",
    "code_output": "false",
    "std_output": "",
    "last_testcase": "[2, 2, 1]\n4",
    "expected_output": "true",
    "task_finish_time": 1706781712604,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 300,
    "total_testcases": 531,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Kotlin",
    "submission_id": "1162841140",
    "input_formatted": "[2, 2, 1], 4",
    "input": "[2, 2, 1]\n4",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    fun canSplitArray(nums: List<Int>, m: Int): Boolean {\n        // Calculate the total sum and the max element of nums\n        val totalSum = nums.sum()\n        val maxElement = nums.maxOrNull() ?: 0\n\n        // Define the binary search boundaries\n        var left = maxElement\n        var right = totalSum\n\n        // Function to check if it's possible to split the array into subarrays\n        // such that the sum of each subarray is less than or equal to `mid`\n        fun canSplit(mid: Int): Boolean {\n            var sum = 0\n            var count = 1\n            for (num in nums) {\n                // If the current sum with the next element exceeds `mid`, start a new subarray\n                if (sum + num > mid) {\n                    sum = num\n                    count++\n                } else {\n                    sum += num\n                }\n            }\n            return count <= nums.size\n        }\n\n        // Perform a binary search to find the minimum possible `mid`\n        // that allows splitting the array according to the given conditions\n        while (left < right) {\n            val mid = left + (right - left) / 2\n            if (canSplit(mid)) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n\n        // Check if we can achieve the split with the sum greater than or equal to `m`\n        return left >= m\n    }\n}"
}