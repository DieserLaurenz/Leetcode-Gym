{
    "status_code": 11,
    "lang": "typescript",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 52132000,
    "question_id": "2916",
    "elapsed_time": 91,
    "compare_result": "101111111111111111111111111111111111111111111111011111111111101101001011100000000011111000010001111111101111101010100100010011110111101111111110111000001010101110011110010111111101011111011111111001101000001111001100110111111111111111010111011011110110111111001011111110111100000010111111001101011110011001111000110101110001011001101111000100011011111100101111101100001110001011010101100010011101001111011111011010111101011101101010000100011111000101010011101011111010100010011000010111111110000001110101001100001110000010111001010",
    "code_output": "true",
    "std_output": "",
    "last_testcase": "[2, 1, 3]\n5",
    "expected_output": "false",
    "task_finish_time": 1706774549147,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 337,
    "total_testcases": 531,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "TypeScript",
    "submission_id": "1162764139",
    "input_formatted": "[2, 1, 3], 5",
    "input": "[2, 1, 3]\n5",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "function canSplitArray(nums: number[], m: number): boolean {\n    // Determine if it's possible to split the array into subarrays meeting the criteria\n    // by trying to find a sequence of splits where each part has a sum >= m or is a single element.\n\n    // Edge case: If the array length is 1, check if it meets the criteria by itself.\n    if (nums.length === 1) return nums[0] >= m || nums.length === 1;\n\n    // Calculate the prefix sums of the array to quickly sum segments.\n    let prefixSums = new Array(nums.length + 1).fill(0);\n    for (let i = 1; i <= nums.length; i++) {\n        prefixSums[i] = prefixSums[i - 1] + nums[i - 1];\n    }\n\n    // Dynamic programming approach to check if we can create the required splits.\n    // dp[i] represents if it's possible to split the first i elements into valid subarrays.\n    let dp = new Array(nums.length + 1).fill(false);\n    dp[0] = true; // Base case: no elements means the condition is trivially met.\n\n    for (let i = 1; i <= nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            // Check if the segment from j to i has a sum >= m or is a single element,\n            // and if we can split up to the jth element according to our criteria.\n            if ((prefixSums[i] - prefixSums[j] >= m || i - j === 1) && dp[j]) {\n                dp[i] = true;\n                break; // Found a valid split, no need to check further for this i.\n            }\n        }\n    }\n\n    return dp[nums.length];\n}"
}