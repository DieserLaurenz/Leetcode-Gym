{
    "status_code": 11,
    "lang": "racket",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 125968000,
    "question_id": "2916",
    "elapsed_time": 5018,
    "compare_result": "010111011110100000010001110000000110000000000000100000000000010010110100011111111100000111101110000000010000010101011011101100001000010000000001000111110101010001100001101000000010100000100000000110010111110000110011001000000000000000101000100100001001000000110100000001000011111101000000110010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "false",
    "std_output": "",
    "last_testcase": "[2, 2, 1]\n4",
    "expected_output": "true",
    "task_finish_time": 1706783061029,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 101,
    "total_testcases": 531,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1162856172",
    "input_formatted": "[2, 2, 1], 4",
    "input": "[2, 2, 1]\n4",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "(define/contract (can-split-array nums m)\n  (-> (listof exact-integer?) exact-integer? boolean?)\n\n  ; Helper function to calculate the sum of a sublist given start and end indices\n  (define (sum-sublist lst start end)\n    (if (> start end)\n        0\n        (+ (list-ref lst start) (sum-sublist lst (+ start 1) end))))\n\n  ; Function to check if it's possible to split the array into subarrays that meet the condition\n  (define (check-split lst m)\n    (define (helper lst remaining splits)\n      (cond\n        ; If we have made enough splits, check if the remaining list satisfies the condition\n        [(= splits 0) (>= (sum-sublist lst 0 (- (length lst) 1)) m)]\n        ; Base case: If the list is empty or has one element, we can't make more splits\n        [(or (null? lst) (= (length lst) 1)) #f]\n        ; Recursive case: Try to split the list and check both conditions\n        [else\n         (let loop ((i 1))\n           (if (> i (length lst))\n               #f\n               (let ((left (take lst i))\n                     (right (drop lst i)))\n                 (or (and (or (= (length left) 1) (>= (sum-sublist left 0 (- (length left) 1)) m))\n                          (or (= (length right) 1) (>= (sum-sublist right 0 (- (length right) 1)) m))\n                          (helper left m (- splits 1))\n                          (helper right m (- splits 1)))\n                     (loop (+ i 1))))))]))\n    (helper lst m (- (length nums) 1)))\n\n  (check-split nums m))"
}