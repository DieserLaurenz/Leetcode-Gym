{
    "status_code": 11,
    "lang": "ruby",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 222748000,
    "question_id": "2916",
    "elapsed_time": 3204,
    "compare_result": "010111011110100000011111110111111111111111100100100001011100010010110100111111111100001111101110111111010101110101011011101100101010010001000001000111110101010001100001101000000010100000100000000110010111110000110011001000000000000000101000100100001001000000110110000111100011111101000000110010100001110110000111001010001110100110010000111011100100000011010000010011110001110100101010011101100010110000100000100101000010100010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "false",
    "std_output": "",
    "last_testcase": "[2, 2, 1]\n4",
    "expected_output": "true",
    "task_finish_time": 1706782450295,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 196,
    "total_testcases": 531,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Ruby",
    "submission_id": "1162849297",
    "input_formatted": "[2, 2, 1], 4",
    "input": "[2, 2, 1]\n4",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "# @param {Integer[]} nums\n# @param {Integer} m\n# @return {Boolean}\ndef can_split_array(nums, m)\n  # Calculate the sum of all elements to use in checks\n  total_sum = nums.sum\n  \n  # Base case optimization: if total sum is less than m, immediate split is impossible\n  return false if total_sum < m\n  \n  # Dynamic programming table to memoize whether a specific index and current sum combination has been visited\n  @memo = {}\n  \n  can_split?(nums, 0, 0, m, nums.size)\nend\n\ndef can_split?(nums, index, current_sum, m, n, splits = 0)\n  # Base case: If all elements are visited and we have made enough splits\n  return splits == n - 1 if index == nums.size\n  \n  key = [index, current_sum, splits]\n  return @memo[key] if @memo.key?(key)\n  \n  # Option 1: Add current element to the current sum (continue the current subarray)\n  if current_sum + nums[index] >= m || nums[index] >= m\n    # If adding the current number meets the condition, we have the option to split here\n    @memo[key] = can_split?(nums, index + 1, 0, m, n, splits + 1) || can_split?(nums, index + 1, current_sum + nums[index], m, n, splits)\n  else\n    # Option 2: Do not split here, continue adding to the current sum/subarray\n    @memo[key] = can_split?(nums, index + 1, current_sum + nums[index], m, n, splits)\n  end\n  \n  @memo[key]\nend"
}