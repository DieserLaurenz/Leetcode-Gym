{
    "status_code": 10,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "46 ms",
    "memory": 2244000,
    "question_id": "2916",
    "elapsed_time": 64,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706782728856,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 531,
    "total_testcases": 531,
    "runtime_percentile": 25.0,
    "status_memory": "2.2 MB",
    "memory_percentile": 25.0,
    "pretty_lang": "Rust",
    "submission_id": "1162852426",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn can_split_array(nums: Vec<i32>, m: i32) -> bool {\n        let n = nums.len();\n        let mut prefix_sum = vec![0; n + 1];\n        for i in 0..n {\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n        }\n\n        let mut memo = vec![vec![-1; n]; n];\n        \n        fn can_split(start: usize, end: usize, nums: &Vec<i32>, m: i32, prefix_sum: &Vec<i32>, memo: &mut Vec<Vec<i32>>) -> bool {\n            if start == end {\n                return true;\n            }\n            if memo[start][end] != -1 {\n                return memo[start][end] == 1;\n            }\n            for i in start..end {\n                let sum_left = prefix_sum[i + 1] - prefix_sum[start];\n                let sum_right = prefix_sum[end + 1] - prefix_sum[i + 1];\n                if (sum_left >= m || i == start) && (sum_right >= m || i + 1 == end) {\n                    if can_split(start, i, nums, m, prefix_sum, memo) && can_split(i + 1, end, nums, m, prefix_sum, memo) {\n                        memo[start][end] = 1;\n                        return true;\n                    }\n                }\n            }\n            memo[start][end] = 0;\n            return false;\n        }\n\n        can_split(0, n - 1, &nums, m, &prefix_sum, &mut memo)\n    }\n}"
}