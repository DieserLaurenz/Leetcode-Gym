{
    "status_code": 10,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "0 ms",
    "memory": 7972000,
    "question_id": "3230",
    "elapsed_time": 13,
    "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1708123259773,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 779,
    "total_testcases": 779,
    "runtime_percentile": 100,
    "status_memory": "8 MB",
    "memory_percentile": 17.34880000000001,
    "pretty_lang": "C++",
    "submission_id": "1177343076",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int removeAlmostEqualCharacters(string word) {\n        int ops = 0;\n        for (int i = 1; i < word.size(); ++i) {\n            if (word[i] == word[i-1] || abs(word[i] - word[i-1]) == 1) {\n                ops++;\n                // Change current character to a letter that is not almost-equal to previous or next character\n                if (i + 1 < word.size()) {\n                    for (char ch = 'a'; ch <= 'z'; ++ch) {\n                        if (ch != word[i-1] && ch != word[i+1] && abs(ch - word[i-1]) > 1 && abs(ch - word[i+1]) > 1) {\n                            word[i] = ch;\n                            break;\n                        }\n                    }\n                } else {\n                    // If it's the last character, just ensure it's not almost-equal to the previous one\n                    for (char ch = 'a'; ch <= 'z'; ++ch) {\n                        if (ch != word[i-1] && abs(ch - word[i-1]) > 1) {\n                            word[i] = ch;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return ops;\n    }\n};"
}