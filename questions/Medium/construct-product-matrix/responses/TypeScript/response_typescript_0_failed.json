{
    "status_code": 11,
    "lang": "typescript",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 84336000,
    "question_id": "3031",
    "elapsed_time": 411,
    "compare_result": "000010001000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100000000000000000000000010000001111100000010000001001001000010011100001100001110000000000001100000000110011000000001001111110000000011110111100000010000100100110000001111000010000100111100110000001111110000000000111100100000000000010010011001001110010000011110011001100001001110000111000010010011000010000110000100001000000100111100111001001111001000011111110000110000111110001000000100001100001100000010000110010000100100100000000000010000100111001100110111",
    "code_output": "[[24,1557],[4128,9966]]",
    "std_output": "",
    "last_testcase": "[[1,2],[3,4]]",
    "expected_output": "[[24,12],[8,6]]",
    "task_finish_time": 1706835894716,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 160,
    "total_testcases": 1566,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "TypeScript",
    "submission_id": "1163463660",
    "input_formatted": "[[1,2],[3,4]]",
    "input": "[[1,2],[3,4]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "function constructProductMatrix(grid: number[][]): number[][] {\n    // Calculate the total product of all elements and count of zeros in each row.\n    let totalProduct = 1;\n    let zeroCount = 0;\n    const n = grid.length;\n    const m = grid[0].length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] !== 0) {\n                totalProduct = (totalProduct * grid[i][j]) % 12345;\n            } else {\n                zeroCount++;\n            }\n        }\n    }\n\n    // Construct the product matrix.\n    const p: number[][] = Array.from({length: n}, () => Array(m).fill(0));\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (zeroCount > 1) {\n                // If there are more than one zeros, all elements in p will be 0.\n                p[i][j] = 0;\n            } else if (zeroCount === 1) {\n                // If there's exactly one zero and it's not the current element, p[i][j] will be 0.\n                // If the current element is the zero, p[i][j] is the total product.\n                p[i][j] = grid[i][j] === 0 ? totalProduct : 0;\n            } else {\n                // When there are no zeros, divide the total product by the current element.\n                // Due to JavaScript's handling of integers, direct division and modulo might not work as expected for very large numbers.\n                // Thus, we use multiplication by modular multiplicative inverse for division under modulo.\n                let inverse = modInverse(grid[i][j], 12345);\n                p[i][j] = (totalProduct * inverse) % 12345;\n            }\n        }\n    }\n\n    return p;\n}\n\n// Function to find modular multiplicative inverse under modulo m\n// Using Fermat's Little Theorem for this purpose: a^(m-2) mod m\nfunction modInverse(a: number, m: number): number {\n    return modPow(a, m - 2, m);\n}\n\n// Function to calculate a^b mod m\nfunction modPow(a: number, b: number, m: number): number {\n    a = a % m;\n    let result = 1;\n    while (b > 0) {\n        if (b & 1) {\n            result = (result * a) % m;\n        }\n        a = (a * a) % m;\n        b >>= 1;\n    }\n    return result;\n}"
}