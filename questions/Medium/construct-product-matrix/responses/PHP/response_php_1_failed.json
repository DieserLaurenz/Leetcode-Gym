{
    "status_code": 15,
    "lang": "php",
    "run_success": false,
    "runtime_error": "Line 49: PHP Fatal error:  Uncaught DivisionByZeroError: Division by zero in solution.php",
    "full_runtime_error": "Line 49: PHP Fatal error:  Uncaught DivisionByZeroError: Division by zero in solution.php\nStack trace:\n#0 solution.php: intdiv()\n#1 solution.php: Solution->modInverse()\n#2 solution.php: Solution->constructProductMatrix()\n#3 {main}",
    "status_runtime": "N/A",
    "memory": 20096000,
    "question_id": "3031",
    "elapsed_time": 21,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[[1,2],[3,4]]",
    "expected_output": "[[24,12],[8,6]]",
    "task_finish_time": 1706836103023,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 1566,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "PHP",
    "submission_id": "1163465291",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer[][]\n     */\n    function constructProductMatrix($grid) {\n        $n = count($grid);\n        $m = count($grid[0]);\n        $productMatrix = array_fill(0, $n, array_fill(0, $m, 1));\n        $rowProduct = array_fill(0, $n, 1);\n        $colProduct = array_fill(0, $m, 1);\n\n        // First, compute the product of all numbers in each row and each column, excluding zeros\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $m; $j++) {\n                if ($grid[$i][$j] != 0) {\n                    $rowProduct[$i] = ($rowProduct[$i] * $grid[$i][$j]) % 12345;\n                    $colProduct[$j] = ($colProduct[$j] * $grid[$i][$j]) % 12345;\n                }\n            }\n        }\n\n        // Compute the product for each position by multiplying the row and column products, excluding the current element\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $m; $j++) {\n                $excludeCurrent = ($rowProduct[$i] * $colProduct[$j]) % 12345;\n                if ($grid[$i][$j] != 0) {\n                    $excludeCurrent = ($excludeCurrent * $this->modInverse($grid[$i][$j], 12345)) % 12345;\n                }\n                $productMatrix[$i][$j] = $excludeCurrent;\n            }\n        }\n\n        return $productMatrix;\n    }\n\n    private function modInverse($a, $m) {\n        // Placeholder for the modular inverse calculation\n        // Implementing the actual logic if needed\n        $m0 = $m;\n        $y = 0;\n        $x = 1;\n\n        if ($m == 1) return 0;\n\n        while ($a > 1) {\n            // q is quotient\n            $q = intdiv($a, $m);\n            $t = $m;\n\n            // m is remainder now, process same as Euclid's algo\n            $m = $a % $m;\n            $a = $t;\n            $t = $y;\n\n            // Update x and y\n            $y = $x - $q * $y;\n            $x = $t;\n        }\n\n        // Make x positive\n        if ($x < 0) $x += $m0;\n\n        return $x;\n    }\n}"
}