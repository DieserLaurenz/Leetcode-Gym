{
    "status_code": 15,
    "lang": "csharp",
    "run_success": false,
    "runtime_error": "Unhandled exception. System.DivideByZeroException: Attempted to divide by zero.",
    "full_runtime_error": "Unhandled exception. System.DivideByZeroException: Attempted to divide by zero.\nAt Solution.ModInverse(Int64 a, Int64 mod)\nAt Solution.ConstructProductMatrix(Int32[][] grid)\nAt __DriverSolution__.__Helper__(Int32[][] param_1)\nAt __Driver__.Main(String[] args)",
    "status_runtime": "N/A",
    "memory": 43812000,
    "question_id": "3031",
    "elapsed_time": 183,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[[1,2],[3,4]]",
    "expected_output": "[[24,12],[8,6]]",
    "task_finish_time": 1706835180079,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 1566,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C#",
    "submission_id": "1163458439",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public int[][] ConstructProductMatrix(int[][] grid) {\n        int n = grid.Length;\n        int m = grid[0].Length;\n        long totalProduct = 1;\n        int zeroCount = 0;\n        int[][] result = new int[n][];\n\n        // Initialize result matrix\n        for (int i = 0; i < n; i++) {\n            result[i] = new int[m];\n        }\n\n        // Calculate total product and count zeros\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 0) {\n                    zeroCount++;\n                } else {\n                    totalProduct = (totalProduct * grid[i][j]) % 12345;\n                }\n            }\n        }\n\n        // Fill in the result matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (zeroCount > 1) {\n                    result[i][j] = 0; // If more than one zero, all products are 0\n                } else if (zeroCount == 1) {\n                    result[i][j] = grid[i][j] == 0 ? (int)totalProduct : 0; // Non-zero positions are 0 if there's a zero in grid\n                } else {\n                    long productWithoutCurrent = totalProduct * ModInverse(grid[i][j], 12345) % 12345;\n                    result[i][j] = (int)productWithoutCurrent;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Calculate Modular Multiplicative Inverse\n    private long ModInverse(long a, long mod) {\n        long m0 = mod;\n        long y = 0, x = 1;\n\n        if (mod == 1)\n            return 0;\n\n        while (a > 1) {\n            long q = a / mod;\n            long t = mod;\n\n            // m is remainder now, process same as Euclid's algo\n            mod = a % mod; a = t;\n            t = y;\n\n            // Update y and x\n            y = x - q * y;\n            x = t;\n        }\n\n        // Make x positive\n        if (x < 0)\n            x += m0;\n\n        return x;\n    }\n}"
}