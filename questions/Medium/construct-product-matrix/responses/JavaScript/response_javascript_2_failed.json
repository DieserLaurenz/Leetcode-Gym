{
    "status_code": 11,
    "lang": "javascript",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 68504000,
    "question_id": "3031",
    "elapsed_time": 4012,
    "compare_result": "001111001100000000000110010000000000011111011000000110000000000000000001110110000001110100000000000000000000000000000000110000000111100000000000000000000000000000000000000111110000000000000000000000001100011100000000000000000000000111111110110100000000000000000000000000111111111111111100000000000000111111101111110000000000111111111111111111000000000000000001111111111111100000000000000001111111111111100000000000011111111111110000000000000000001111111111111000000111110111111000000000000011111111111000000000000000000000000000000000000000000000000000000001000100000000000000000010000000100010010000011000000000000100000000000000000000000000000000000000000000000000001000000000000010000010000101000011000000001100001110000000010001100010000111000001011001000011000011100000000000100010000010010001000000110010000011110110101011111100010011111001101100110011111010100100011100001000001100100000110111101001110111110100000000101010111011101011100111111110010101110100111110001001110101111001000011001011100011111001000010100000101101100110001100101000011011101001000100111111100010111111101011001110101100111101000010000000000000000010000001111100000010000001001001000010011100001100001110000000000001100000000110011000000001001111110000000011110111100000010000100100110000001111000010000100111100110000001111110000000000111100100000000000010010011001001110010000011110011001100001001110000111000010010011000010000110000100001000000100111100111001001111001000011111110000110000111110001000000100001100001100000010000110010000100100100000000000010000100111001100110100",
    "code_output": "[[24,12],[0,6]]",
    "std_output": "",
    "last_testcase": "[[1,2],[3,4]]",
    "expected_output": "[[24,12],[8,6]]",
    "task_finish_time": 1706835814054,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 536,
    "total_testcases": 1566,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "JavaScript",
    "submission_id": "1163463064",
    "input_formatted": "[[1,2],[3,4]]",
    "input": "[[1,2],[3,4]]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "/**\n * @param {number[][]} grid\n * @return {number[][]}\n */\nvar constructProductMatrix = function(grid) {\n    const n = grid.length;\n    const m = grid[0].length;\n    let p = new Array(n).fill(0).map(() => new Array(m).fill(1));\n    const mod = 12345;\n\n    // Calculate row and column products separately and then combine, avoiding division.\n    \n    // Calculate the product of all numbers in the grid once, except for the row and column of interest.\n    let totalProduct = 1;\n    let zeroCount = 0; // Count of zeros in the grid\n    grid.forEach(row => {\n        row.forEach(value => {\n            if (value !== 0) {\n                totalProduct = (totalProduct * value) % mod;\n            } else {\n                zeroCount++;\n            }\n        });\n    });\n\n    if (zeroCount > 1) { // If more than one zero, all elements in product matrix will be zero.\n        return p; // Already filled with 1s, will be overridden below if not all zeros.\n    }\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 0) { // Special case: the current element is zero\n                // Calculate product of all elements except the current row and column.\n                let productWithoutCurrent = 1;\n                for (let x = 0; x < n; x++) {\n                    for (let y = 0; y < m; y++) {\n                        if (x !== i && y !== j && grid[x][y] !== 0) {\n                            productWithoutCurrent = (productWithoutCurrent * grid[x][y]) % mod;\n                        }\n                    }\n                }\n                p[i][j] = productWithoutCurrent;\n            } else if (zeroCount === 0) { // No zeros in grid\n                p[i][j] = totalProduct;\n                for (let x = 0; x < n; x++) {\n                    for (let y = 0; y < m; y++) {\n                        if (x === i && y === j) {\n                            p[i][j] = (p[i][j] * modInverse(grid[x][y], mod)) % mod;\n                        }\n                    }\n                }\n            } else { // If there's exactly one zero in the grid, and it's not the current element\n                p[i][j] = 0;\n            }\n        }\n    }\n\n    return p;\n};\n\n/**\n * Calculates the modular inverse of a number a under modulo m\n * @param {number} a - The number\n * @param {number} m - The modulo\n * @return {number} - The modular inverse\n */\nfunction modInverse(a, m) {\n    // Extended Euclidean Algorithm to find modular inverse\n    let m0 = m, t, q;\n    let x0 = 0, x1 = 1;\n\n    if (m === 1) return 0;\n\n    while (a > 1) {\n        // q is quotient\n        q = Math.floor(a / m);\n        t = m;\n\n        // m is remainder now, process same as Euclid's algo\n        m = a % m, a = t;\n        t = x0;\n\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n\n    // Make x1 positive\n    if (x1 < 0) x1 += m0;\n\n    return x1;\n}"
}