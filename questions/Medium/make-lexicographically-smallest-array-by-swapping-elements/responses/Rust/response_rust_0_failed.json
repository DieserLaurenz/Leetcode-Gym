{
    "status_code": 11,
    "lang": "rust",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 9208000,
    "question_id": "3219",
    "elapsed_time": 2012,
    "compare_result": "0111001110101011001110100100000110011111111111001110010011101001001000011111011100000011010111110111111010011110111000001110001111101100111110011100010011001111101111110110110110000010101101011101110111010111101111011111111111111111111111111111101111111111111111111111111101111111111111011111110111111111111111111111111110111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110000000000000000",
    "code_output": "[1,5,3,8,9]",
    "std_output": "",
    "last_testcase": "[1,5,3,9,8]\n2",
    "expected_output": "[1,3,5,8,9]",
    "task_finish_time": 1707556436930,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 414,
    "total_testcases": 523,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Rust",
    "submission_id": "1171277978",
    "input_formatted": "[1,5,3,9,8], 2",
    "input": "[1,5,3,9,8]\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "impl Solution {\n    pub fn lexicographically_smallest_array(nums: Vec<i32>, limit: i32) -> Vec<i32> {\n        let mut nums = nums;\n        let n = nums.len();\n        let mut graph = vec![vec![]; n];\n        \n        for i in 0..n {\n            for j in i + 1..n {\n                if (nums[i] - nums[j]).abs() <= limit {\n                    graph[i].push(j);\n                    graph[j].push(i);\n                }\n            }\n        }\n        \n        let mut visited = vec![false; n];\n        let mut component = Vec::new();\n        \n        for i in 0..n {\n            if !visited[i] {\n                component.clear();\n                dfs(i, &graph, &mut visited, &mut component);\n                \n                let mut values: Vec<i32> = component.iter().map(|&i| nums[i]).collect();\n                values.sort_unstable();\n                for (idx, &comp_idx) in component.iter().enumerate() {\n                    nums[comp_idx] = values[idx];\n                }\n            }\n        }\n        \n        nums\n    }\n}\n\nfn dfs(node: usize, graph: &Vec<Vec<usize>>, visited: &mut Vec<bool>, component: &mut Vec<usize>) {\n    visited[node] = true;\n    component.push(node);\n    for &next in &graph[node] {\n        if !visited[next] {\n            dfs(next, graph, visited, component);\n        }\n    }\n}"
}