{
    "status_code": 11,
    "lang": "racket",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 126984000,
    "question_id": "2867",
    "elapsed_time": 5062,
    "compare_result": "0000000000000000000000000000100000000000010000100000000000000000000000000000010000000000100000000000010000000000000000100001000000000000000000000000001000000000010101000001000000000000000000000000000100000000000000000000000100000000000000010001000000000100000000000000000000001000000000000000000000010000000000000000000010000000000000010010000000010100000100000000000010000000000000000000000000000000000000000000000001100010000000000000100000000000000000000000000000001000000000000001000100000000000001000000000000000000000000000000000000000000000000000",
    "code_output": "0",
    "std_output": "",
    "last_testcase": "[0,1,0,0,1]",
    "expected_output": "3",
    "task_finish_time": 1708237797068,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 35,
    "total_testcases": 553,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1178614423",
    "input_formatted": "[0,1,0,0,1]",
    "input": "[0,1,0,0,1]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "(define/contract (number-of-good-subarray-splits nums)\n  (-> (listof exact-integer?) exact-integer?)\n  \n  (let ([mod 1000000007])\n    (define ones-count (count (lambda (x) (= x 1)) nums))\n    (if (= ones-count 0) 0\n        (let loop ([nums nums] [prev 0] [result 0] [ones-left ones-count])\n          (if (null? nums)\n              result\n              (let ([current (if (= (car nums) 1) (+ 1 prev) prev)])\n                (if (= (car nums) 1)\n                    (loop (cdr nums) 0 (+ result (* current (if (= ones-left 1) 1 (modulo (- ones-left 1) mod))) (modulo result mod)) (- ones-left 1))\n                    (loop (cdr nums) (+ 1 current) result ones-left)))))))\n  \n  (let ([mod 1000000007])\n    (define (aux nums ones)\n      (if (= ones 0)\n          0\n          (let loop ([i 0] [prev-ones 0] [ways 0])\n            (if (= i (length nums))\n                ways\n                (let ([current (list-ref nums i)])\n                  (if (= current 1)\n                      (let ([new-ways (if (> ones prev-ones 1) \n                                          (+ ways (* (+ prev-ones 1) (- ones prev-ones 1))) \n                                          ways)])\n                        (loop (+ i 1) (+ prev-ones 1) (modulo new-ways mod)))\n                      (loop (+ i 1) prev-ones ways)))))))\n    (aux nums (count (lambda (x) (= x 1)) nums))))"
}