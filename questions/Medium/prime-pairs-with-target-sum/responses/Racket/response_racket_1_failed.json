{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "in-range: arity mismatch;",
    "full_runtime_error": "in-range: arity mismatch;\n the expected number of arguments does not match the given number\n  given: 4\n  context...:\n   solution.rkt:1:0: find-prime-pairs\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:28:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 100196000,
    "question_id": "2873",
    "elapsed_time": 262,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "10",
    "expected_output": "[[3,7],[5,5]]",
    "task_finish_time": 1708103916532,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 554,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1177140915",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (find-prime-pairs n)\n  (-> exact-integer? (listof (listof exact-integer?)))\n\n  (define (sieve-of-eratosthenes n)\n    (let ((is-prime (make-vector (+ n 1) #t)))\n      (vector-set! is-prime 0 #f)\n      (vector-set! is-prime 1 #f)\n      (for ([i (in-range 2 (sqrt n) + 1)])\n        (when (vector-ref is-prime i)\n          (for ([j (in-range (* i i) (+ n 1) i)])\n            (vector-set! is-prime j #f))))\n      is-prime))\n\n  (define (is-prime? x primes)\n    (vector-ref primes x))\n\n  (let* ((primes (sieve-of-eratosthenes n))\n         (result '()))\n    (for ([x (in-range 2 (/ n 2) + 1)])\n      (let ((y (- n x)))\n        (when (and (is-prime? x primes) (is-prime? y primes))\n          (set! result (cons (list x y) result)))))\n    (reverse result)))"
}