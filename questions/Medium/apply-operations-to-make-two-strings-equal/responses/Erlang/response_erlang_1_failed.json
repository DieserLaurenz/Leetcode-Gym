{
    "status_code": 11,
    "lang": "erlang",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 58792000,
    "question_id": "3033",
    "elapsed_time": 5141,
    "compare_result": "000010111000011000111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "\"1100011000\"\n\"0101001010\"\n2",
    "expected_output": "4",
    "task_finish_time": 1706740560321,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 9,
    "total_testcases": 729,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Erlang",
    "submission_id": "1162426800",
    "input_formatted": "\"1100011000\", \"0101001010\", 2",
    "input": "\"1100011000\"\n\"0101001010\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "-spec min_operations(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), X :: integer()) -> integer().\nmin_operations(S1, S2, X) ->\n    min_operations(binary_to_list(S1), binary_to_list(S2), X, 0, false).\n\nmin_operations([], [], _, Cost, _) ->\n    %% End of both strings, return the cost\n    Cost;\nmin_operations([H1 | T1], [H2 | T2], X, Cost, Carry) when H1 /= H2, X > 1, not Carry ->\n    %% If different and X is more than 1, prefer adjacent flip for next step if possible\n    min_operations(T1, T2, X, Cost + 1, true); %% Carry the flip to next\nmin_operations([_ | T1], [_ | T2], X, Cost, true) ->\n    %% If carried, we've already paid for the flip, just proceed\n    min_operations(T1, T2, X, Cost, false);\nmin_operations(List1, List2, X, Cost, Carry) ->\n    %% Check for direct mismatch that can't be solved with a carry\n    case direct_mismatch(List1, List2) of\n        ok ->\n            %% If there's a direct mismatch, but we have a carry, use it and proceed\n            if Carry ->\n                min_operations(List1, List2, X, Cost, false);\n            true ->\n                %% No carry, must use X cost if applicable\n                if X =< 1 ->\n                    %% If X is 1 or less, use it directly\n                    min_operations(List1, List2, 1, Cost + X, false);\n                true ->\n                    %% Otherwise, it's impossible\n                    -1\n                end\n            end;\n        error ->\n            -1; %% Impossible to match\n        continue ->\n            %% Continue if no direct mismatch found\n            min_operations(tl(List1), tl(List2), X, Cost + (if Carry -> 0; true -> 1 end), false)\n    end.\n\ndirect_mismatch([H1, H1Next | _], [H2, H2Next | _]) when H1 == H2, H1Next /= H2Next ->\n    %% Direct mismatch that can't be immediately solved, check if carry is possible\n    ok;\ndirect_mismatch([], []) ->\n    continue;\ndirect_mismatch(_, _) ->\n    error."
}