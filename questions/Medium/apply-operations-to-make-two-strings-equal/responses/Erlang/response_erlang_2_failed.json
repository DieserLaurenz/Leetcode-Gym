{
    "status_code": 15,
    "lang": "erlang",
    "run_success": false,
    "runtime_error": "Line 15: exception error: undef",
    "full_runtime_error": "Line 15: exception error: undef\n[{lists,drop,[1,\"1100011000\"],[]},\n {solution,min_operations,4,[{file,\"solution.erl\"},{line,15}]},\n {solution,consume_test_cases,2,[{file,\"solution.erl\"},{line,57}]},\n {solution,driver,0,[{file,\"solution.erl\"},{line,41}]},\n {solution,start,0,[{file,\"solution.erl\"},{line,74}]},\n {init,start_em,1,[]},\n {init,do_boot,3,[]}]",
    "status_runtime": "N/A",
    "memory": 59504000,
    "question_id": "3033",
    "elapsed_time": 1409,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"1100011000\"\n\"0101001010\"\n2",
    "expected_output": "4",
    "task_finish_time": 1706740618831,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 729,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Erlang",
    "submission_id": "1162427222",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "-spec min_operations(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), X :: integer()) -> integer().\nmin_operations(S1, S2, X) ->\n    min_operations(binary_to_list(S1), binary_to_list(S2), X, 0).\n\nmin_operations([], [], _, Cost) ->\n    Cost;\nmin_operations([H1 | T1] = L1, [H2 | T2] = L2, X, Cost) ->\n    case H1 == H2 of\n        true ->\n            min_operations(T1, T2, X, Cost);\n        false ->\n            case next_diff(L1, L2, 1) of\n                {ok, Steps} when Steps > 0, X > 1 ->\n                    %% If next difference is further than 1 step away and X is cost-effective for flipping\n                    min_operations(skip(L1, Steps), skip(L2, Steps), X, Cost + 1);\n                {ok, Steps} when Steps == 1 ->\n                    %% Next difference is adjacent, flip adjacent at cost 1\n                    min_operations(skip(L1, Steps), skip(L2, Steps), X, Cost + 1);\n                _ ->\n                    %% If no more differences or not cost-effective to flip, check if done or return -1\n                    case (T1 == T2) of\n                        true -> Cost;\n                        false -> -1\n                    end\n            end\n    end.\n\nnext_diff([H1 | T1], [H2 | T2], Steps) ->\n    case H1 == H2 of\n        true -> next_diff(T1, T2, Steps + 1);\n        false -> {ok, Steps}\n    end;\nnext_diff([], [], _) ->\n    {done, 0}.\n\nskip(List, N) ->\n    lists:drop(N, List)."
}