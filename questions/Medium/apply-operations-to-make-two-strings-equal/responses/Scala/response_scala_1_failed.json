{
    "status_code": 11,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 54852000,
    "question_id": "3033",
    "elapsed_time": 514,
    "compare_result": "010110011110011000101000010100001011110111111110100001101111101011010111100111001101110011010110100111011010001001100100101101010011100000110010111000111111011010011110110010111011000001001101011010000011011110101011010000000101111101100111000001100000011101011110101100001010101100111101111111011101010011100001101011011111100111111011100110010100101111010111000000010100000011111110110000100000101011001000111111001110001001111001101111000110001000001001111100101111110101110000110001110111101001011111010000100010010111001111001011011000001011111010100100001011010011110001011100001010010011110010010111110010111100010100111001001111100101100001101111110111001111111101100100111101111111100011110001110110110110110001010110100",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "\"1100011000\"\n\"0101001010\"\n2",
    "expected_output": "4",
    "task_finish_time": 1706732871738,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 397,
    "total_testcases": 729,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Scala",
    "submission_id": "1162358606",
    "input_formatted": "\"1100011000\", \"0101001010\", 2",
    "input": "\"1100011000\"\n\"0101001010\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "object Solution {\n    def minOperations(s1: String, s2: String, x: Int): Int = {\n        var mismatches = 0\n        var i = 0\n        val n = s1.length\n        // Count mismatches and groups of mismatches\n        var isolatedMismatches = 0\n        while (i < n) {\n            if (s1(i) != s2(i)) {\n                mismatches += 1\n                if (i == n - 1 || s1(i + 1) == s2(i + 1)) {\n                    isolatedMismatches += 1 // Count isolated mismatches\n                }\n                // Skip adjacent mismatches\n                while (i < n - 1 && s1(i) != s2(i + 1)) {\n                    i += 1\n                }\n            }\n            i += 1\n        }\n        \n        // If mismatches are odd and isolated mismatches exist, it's impossible to match strings\n        if (isolatedMismatches > 0 && x > 1) return -1\n\n        // Calculate the cost of flipping\n        var cost = 0\n        if (x <= 2) {\n            cost = mismatches // Cheaper or equal to perform adjacent flips\n        } else {\n            // For x > 2, it depends on the configuration of mismatches\n            cost = Math.min(mismatches, isolatedMismatches * x)\n        }\n        \n        cost\n    }\n}"
}