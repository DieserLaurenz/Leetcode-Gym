{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 8956000,
    "question_id": "3033",
    "elapsed_time": 18,
    "compare_result": "111110111111111100101010010110011111111111111111101001101111111011011111101111011101110011111110101111111111001001100100101101011111111000110011111001111111111011111110110011111011010101001101011010001011011110101011110000100111111101110111010101100010011101011110101100101011101101111101111111011101011111100101101011011111101111111111100111010100111111010111000001110101111111111111110000110001101011001000111111001110111111111111101111111110001100001001111101111111110101110010110101110111111011111111010000100010010111001111001011011001001011111010100100001011010011110001011100001010010011110010010111110010111100010100111001001111100101100001101111110111001111111101100100111101111111100011110001110110110110110001010110100",
    "code_output": "7",
    "std_output": "",
    "last_testcase": "\"00101101100010\"\n\"00001010001111\"\n30",
    "expected_output": "8",
    "task_finish_time": 1706722329393,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 478,
    "total_testcases": 729,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1162216256",
    "input_formatted": "\"00101101100010\", \"00001010001111\", 30",
    "input": "\"00101101100010\"\n\"00001010001111\"\n30",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\npublic:\n    int minOperations(string s1, string s2, int x) {\n        int n = s1.length();\n        int mismatch = 0;\n\n        // Calculate mismatches\n        for (int i = 0; i < n; ++i) {\n            if (s1[i] != s2[i]) {\n                ++mismatch;\n            }\n        }\n\n        // If mismatches are odd, return -1\n        if (mismatch % 2 != 0) return -1;\n\n        // Calculate the number of mismatch pairs\n        int mismatchPairs = mismatch / 2;\n        int adjMismatchPairs = 0;\n\n        // Count adjacent mismatch pairs\n        for (int i = 0; i < n - 1; ) {\n            if (s1[i] != s2[i] && s1[i + 1] != s2[i + 1]) {\n                if (s1[i] != s1[i + 1]) {\n                    adjMismatchPairs++;\n                    i += 2; // Skip the next bit as it's part of the counted pair\n                } else {\n                    i++; // Move to the next bit and check again\n                }\n            } else {\n                i++;\n            }\n        }\n\n        int minCost = 0;\n        // First, flip as many adjacent mismatch pairs as possible\n        minCost += adjMismatchPairs;\n        mismatchPairs -= adjMismatchPairs;\n\n        // For the remaining mismatch pairs, decide based on the cost x\n        if (x <= 2) {\n            // If the cost x is less than or equal to 2, use the first operation\n            minCost += mismatchPairs * x;\n        } else {\n            // If x is greater than 2, it's cheaper to flip them as adjacent pairs (if possible) or consider them as separate operations\n            minCost += mismatchPairs * 2; // Since we can't directly flip non-adjacent pairs, we may need to flip an extra correct bit for each pair, hence *2\n        }\n\n        return minCost;\n    }\n};"
}