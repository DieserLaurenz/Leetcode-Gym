{
    "status_code": 11,
    "lang": "javascript",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 51716000,
    "question_id": "3033",
    "elapsed_time": 76,
    "compare_result": "010110011110001000101000010100001011110111111110100001101110101010000011101001011101100011000110100010011010001001100100101101010011111000110010010000101111001001011110110010010010000101001101001000000011011010101010010000000101011100110011000001000000011001001000101100001010001000001001101011011001010001100000101011010011001011110111100010010100001111010111000000110101001010101110100000010001100001001000111111000110001101110011101011000100001000000001101101101101110101100000000001000111110000011110000000100000000011001011000010000000001011100010100000000000010010010001000000000000000001100000000101000000000000000000001000001101000000100000000001000110000010111101100000110100101011000000110001000110100110100000000110000",
    "code_output": "0",
    "std_output": "",
    "last_testcase": "\"1100011000\"\n\"0101001010\"\n2",
    "expected_output": "4",
    "task_finish_time": 1706731194547,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 276,
    "total_testcases": 729,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "JavaScript",
    "submission_id": "1162340953",
    "input_formatted": "\"1100011000\", \"0101001010\", 2",
    "input": "\"1100011000\"\n\"0101001010\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "/**\n * @param {string} s1\n * @param {string} s2\n * @param {number} x\n * @return {number}\n */\nvar minOperations = function(s1, s2, x) {\n    let mismatchCount = 0;\n    let pairs = 0; // Count of adjacent pairs that differ\n    \n    // Count mismatches and identify adjacent mismatch pairs\n    for (let i = 0; i < s1.length; i++) {\n        if (s1[i] !== s2[i]) {\n            mismatchCount++;\n            // Check if this mismatch forms an adjacent pair with the previous bit\n            if (i > 0 && s1[i-1] !== s2[i-1] && s1[i-1] !== s1[i]) {\n                pairs++;\n                // Skip next bit to avoid double counting\n                i++;\n            }\n        }\n    }\n\n    // If there are an odd number of mismatches, it's impossible to make the strings equal\n    if (mismatchCount % 2 !== 0) {\n        return -1;\n    }\n\n    let operationsCost = 0;\n    // Use the second operation for each identified pair\n    operationsCost += pairs;\n\n    // Calculate the remaining mismatches after accounting for pairs\n    let remainingMismatches = (mismatchCount / 2) - pairs;\n    \n    // For remaining mismatches, decide the operation based on cost x\n    if (x > 1) {\n        // If cost of flipping any two bits (operation 1) is more than flipping adjacent bits\n        // (operation 2), use operation 2 for remaining mismatches. \n        // This is already accounted for by including pairs in the operationsCost.\n    } else {\n        // If flipping any two bits is cheaper or equal, use operation 1 for each remaining mismatch\n        operationsCost += remainingMismatches * x;\n    }\n\n    return operationsCost;\n};"
}