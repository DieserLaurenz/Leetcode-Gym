{
    "status_code": 11,
    "lang": "java",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 42472000,
    "display_runtime": "1",
    "question_id": "3033",
    "elapsed_time": 182,
    "compare_result": "110110010110001000100000000000001011110100111111100001101110111011000011100011010101100010110010100101011010001000100100100101000111111000010010011000001110011011011110110010110010000101001101011000000011011010101010000000000001110101100111000001100000010001001110100100001010101100001001001011011100000011000000101011011010001111110010100010010000101111010111000000000100000010000110110000000000001001001000010011001000000001011010100111000000000000001001001000101011110101000000110000010110100001011110010000000000000111001011000001000000001001100010000100001010000000010000001000001010010000110000010011100000011100010000100001000010000101000001001000110011001101100100000000011000000000000011000001000000110000010000010110100",
    "code_output": "12",
    "std_output": "",
    "last_testcase": "\"101101\"\n\"000000\"\n6",
    "expected_output": "4",
    "task_finish_time": 1706722390056,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 259,
    "total_testcases": 729,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Java",
    "submission_id": "1162217215",
    "input_formatted": "\"101101\", \"000000\", 6",
    "input": "\"101101\"\n\"000000\"\n6",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "class Solution {\n    public int minOperations(String s1, String s2, int x) {\n        int n = s1.length();\n        int diffs = 0; // To count the total number of differing positions\n        int pairs = 0; // To count consecutive differing pairs\n        \n        // Step 1: Calculate differences and consecutive differences\n        for (int i = 0; i < n; ++i) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                diffs++; // Increment for each difference\n                if (i > 0 && s1.charAt(i - 1) != s2.charAt(i - 1) && s1.charAt(i) != s1.charAt(i - 1)) {\n                    pairs++; // Increment for each consecutive pair\n                    diffs--; // Adjust diffs because this pair is handled as a consecutive flip\n                }\n            }\n        }\n        \n        // Step 4: Check if it's possible to make s1 equal to s2\n        if (diffs % 2 != 0) return -1; // Impossible if odd number of differences\n        \n        int cost = pairs; // Cost of flipping consecutive pairs\n        diffs -= 2 * pairs; // Adjust the number of diffs after handling pairs\n        \n        // Step 3: Handle non-consecutive differences\n        // Each operation flips two bits, so we divide the remaining diffs by 2\n        // Use the operation with cost x if it's cheaper than consecutive flips\n        if (x < 2) {\n            cost += diffs; // If x >= 2, flipping individually is cheaper\n        } else {\n            cost += (diffs / 2) * x; // Use the operation with cost x\n        }\n        \n        return cost;\n    }\n}"
}