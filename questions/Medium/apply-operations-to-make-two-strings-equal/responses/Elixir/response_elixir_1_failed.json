{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 72604000,
    "question_id": "3033",
    "elapsed_time": 774,
    "compare_result": "010110000110001000110000000100001011110111101110110001101100101001011001111101011101100010010100101111001110001000101110101101010011011001110010111100111111011001001110110011101011000100001101011010100010011110101011000110000101111100101111000001100000011101000101100100001010001100011101011111011101010111000000011011111111100111110111000100010100101111011011000000100101001010010110100001110101001011001000111111001110001101001011100010010101001011000001111001101101110101011001110100101110110101001100010000100010000111001011000001010000001000111010000000001001010011010000001100000000000011100000010111110010110100010100011001001001100101100001100111100111001111111101000100101101011011000000110001110110100110100000010110101",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "\"1100011000\"\n\"0101001010\"\n2",
    "expected_output": "4",
    "task_finish_time": 1706740904426,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 349,
    "total_testcases": 729,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1162429490",
    "input_formatted": "\"1100011000\", \"0101001010\", 2",
    "input": "\"1100011000\"\n\"0101001010\"\n2",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec min_operations(s1 :: String.t, s2 :: String.t, x :: integer) :: integer\n  def min_operations(s1, s2, x) do\n    {cost, _} = Enum.reduce(0..String.length(s1)-1, {0, s1}, fn i, {acc_cost, acc_s1} ->\n      if acc_s1 |> String.at(i) != s2 |> String.at(i) do\n        if i < String.length(s1) - 1 and acc_s1 |> String.at(i+1) != s2 |> String.at(i+1) do\n          # Flip adjacent characters if they both differ from s2\n          {acc_cost + 1, flip_adjacent(acc_s1, i)}\n        else\n          # If x is 1, flip single character; otherwise, check if direct flip is possible\n          if x == 1 do\n            {acc_cost + x, flip_single(acc_s1, i)}\n          else\n            {-1, acc_s1} # Return -1 if making s1 equal to s2 is not possible under the given constraints\n          end\n        end\n      else\n        {acc_cost, acc_s1}\n      end\n    end)\n\n    if cost == -1, do: -1, else: cost\n  end\n\n  defp flip_single(s, i) do\n    String.slice(s, 0, i) <>\n    (s |> String.at(i) |> flip_char) <>\n    String.slice(s, i+1, String.length(s)-i-1)\n  end\n\n  defp flip_adjacent(s, i) do\n    pre = String.slice(s, 0, i)\n    a = s |> String.at(i) |> flip_char\n    b = s |> String.at(i+1) |> flip_char\n    post = String.slice(s, i+2, String.length(s)-i-2)\n\n    pre <> a <> b <> post\n  end\n\n  defp flip_char(\"0\"), do: \"1\"\n  defp flip_char(\"1\"), do: \"0\"\nend"
}