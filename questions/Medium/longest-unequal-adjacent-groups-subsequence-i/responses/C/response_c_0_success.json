{
    "status_code": 10,
    "lang": "c",
    "run_success": true,
    "status_runtime": "6 ms",
    "memory": 6580000,
    "question_id": "3143",
    "elapsed_time": 18,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1707525879258,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 384,
    "total_testcases": 384,
    "runtime_percentile": 33.33339999999999,
    "status_memory": "6.6 MB",
    "memory_percentile": 66.66669999999999,
    "pretty_lang": "C",
    "submission_id": "1171033858",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** getWordsInLongestSubsequence(int n, char** words, int wordsSize, int* groups, int groupsSize, int* returnSize) {\n    *returnSize = 0;\n    if (n == 0 || wordsSize == 0 || groupsSize == 0) return NULL;\n\n    int i, j = 0, maxLen = 0;\n    // First, find the length of the longest subsequence\n    for (i = 1; i < n; i++) {\n        if (groups[i] != groups[i-1]) maxLen++;\n    }\n    maxLen++; // Include the first element\n\n    char** result = (char**)malloc(maxLen * sizeof(char*));\n    result[j++] = words[0]; // Include the first word by default\n    int lastGroup = groups[0];\n    for (i = 1; i < n; i++) {\n        if (groups[i] != lastGroup) {\n            lastGroup = groups[i];\n            result[j++] = words[i];\n        }\n    }\n    *returnSize = j;\n    return result;\n}"
}