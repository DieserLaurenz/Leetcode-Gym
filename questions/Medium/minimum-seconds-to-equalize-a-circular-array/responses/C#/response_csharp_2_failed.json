{
    "status_code": 11,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 85648000,
    "question_id": "2920",
    "elapsed_time": 403,
    "compare_result": "101111111111111111111111111111111111111111111111111111111111111111111111111110111111111110001111110101111111100000000000001100000000100000000000000000000000000000001000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011",
    "code_output": "3",
    "std_output": "",
    "last_testcase": "[2,1,3,3,2]",
    "expected_output": "2",
    "task_finish_time": 1707960368291,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 110,
    "total_testcases": 579,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C#",
    "submission_id": "1175587721",
    "input_formatted": "[2,1,3,3,2]",
    "input": "[2,1,3,3,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public int MinimumSeconds(IList<int> nums) {\n        int n = nums.Count;\n        if (n == 1) return 0; // If there's only one element, no time is needed.\n        \n        // Convert list to array for faster access\n        int[] arr = new int[n];\n        nums.CopyTo(arr, 0);\n\n        // Initial pass to check if all elements are already equal\n        bool allEqual = true;\n        for (int i = 1; i < n; i++) {\n            if (arr[i] != arr[0]) {\n                allEqual = false;\n                break;\n            }\n        }\n        if (allEqual) return 0; // If all elements are equal, no time is needed.\n\n        // Use BFS to simulate the process\n        int[] depth = new int[n];\n        Queue<int> q = new Queue<int>();\n\n        // Mark all numbers with their initial positions and set their depths\n        for (int i = 0; i < n; i++) {\n            q.Enqueue(i);\n            depth[i] = 1;\n        }\n\n        int maxDepth = 0;\n        while (q.Count > 0) {\n            int current = q.Dequeue();\n            // Neighbors are the previous and next elements in the circular array\n            int[] neighbors = { (current - 1 + n) % n, (current + 1) % n };\n            foreach (int neighbor in neighbors) {\n                // If the neighbor has a different value, it's a potential candidate for change\n                if (arr[current] != arr[neighbor]) {\n                    arr[neighbor] = arr[current]; // Simulate changing the value\n                    depth[neighbor] = depth[current] + 1; // Increase the depth since a change was made\n                    maxDepth = Math.Max(maxDepth, depth[neighbor]); // Update max depth if necessary\n                    q.Enqueue(neighbor); // Add neighbor to queue for further processing\n                }\n            }\n        }\n\n        return maxDepth - 1; // Subtract 1 because initial depth was set to 1 instead of 0\n    }\n}"
}