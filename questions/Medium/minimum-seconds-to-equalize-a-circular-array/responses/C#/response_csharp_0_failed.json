{
    "status_code": 11,
    "lang": "csharp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 78412000,
    "question_id": "2920",
    "elapsed_time": 409,
    "compare_result": "011111111111111111111111111111111111111110000000100000000000001000001000111111101101111111011111101101111111100001001000000000110100000000100110111111111011010101000111111100110011110101011100000101010011111000001011000100000010000000010000000011111000000010001001011100000100010000000110000001100000000001001001000000000000101000110110101000000000100000010010110000100001001110000110010010110111100010001001110110010111011111000100010000111000110100011001010000010100101001101100000000001110001010011010000100010100000000000000000000000000010000000000000000000000000000000000011",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "[1,2,1,2]",
    "expected_output": "1",
    "task_finish_time": 1707960305701,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 227,
    "total_testcases": 579,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C#",
    "submission_id": "1175587237",
    "input_formatted": "[1,2,1,2]",
    "input": "[1,2,1,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "public class Solution {\n    public int MinimumSeconds(IList<int> nums) {\n        int n = nums.Count;\n        if (n <= 1) return 0;\n\n        // Create a map to track the frequency of each number\n        Dictionary<int, int> freq = new Dictionary<int, int>();\n        foreach (int num in nums) {\n            if (!freq.ContainsKey(num)) freq[num] = 0;\n            freq[num]++;\n        }\n\n        // Edge case: If all elements are the same\n        if (freq.Count == 1) return 0;\n\n        // Calculate prefix and suffix arrays to store the maximum length of\n        // continuous segments with the same number, from the start and end respectively\n        int[] prefix = new int[n];\n        int[] suffix = new int[n];\n        prefix[0] = suffix[n - 1] = 1;\n\n        for (int i = 1; i < n; i++) {\n            prefix[i] = (nums[i] == nums[i - 1]) ? prefix[i - 1] + 1 : 1;\n            suffix[n - i - 1] = (nums[n - i - 1] == nums[n - i]) ? suffix[n - i] + 1 : 1;\n        }\n\n        // The strategy is to find the maximum length of a continuous segment\n        // with the same number that either starts at the beginning or ends at the end.\n        // This segment will spread to the rest of the array in minimum steps.\n        int maxLength = Math.Max(prefix[n - 1], suffix[0]); // For cases where the segment wraps around\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i] == nums[i + 1]) {\n                // Combine prefix and suffix if adjacent numbers are the same\n                int combinedLength = prefix[i] + suffix[i + 1];\n                maxLength = Math.Max(maxLength, combinedLength);\n            }\n        }\n\n        // Calculate minimum seconds\n        // Since the segment can double in size every second, it's a logarithmic growth\n        return (int)Math.Ceiling(Math.Log(n / (double)maxLength, 2));\n    }\n}"
}