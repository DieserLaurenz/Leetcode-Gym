{
    "status_code": 11,
    "lang": "javascript",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 75556000,
    "question_id": "2920",
    "elapsed_time": 150,
    "compare_result": "001111111111111111111111111111111111111111111111111111111101010111110101111111101101111111011111101101111111111010110110010011000010011110000000000000000000100010110000000000001100101000100011111000101100000100100000111011011001000001100011100000000100000101000000100000100011001100110001011000011101101100100010001010100100000010000001010010111011010110101000000001010000100000100000100100001000010001110000001000000000100000011001100010000110000000000000000001101000010000000000001000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000011",
    "code_output": "2",
    "std_output": "",
    "last_testcase": "[1,2,1,2]",
    "expected_output": "1",
    "task_finish_time": 1707960472500,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 213,
    "total_testcases": 579,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "JavaScript",
    "submission_id": "1175588497",
    "input_formatted": "[1,2,1,2]",
    "input": "[1,2,1,2]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minimumSeconds = function(nums) {\n    if (new Set(nums).size === 1) return 0; // All elements are already equal.\n\n    // Create a map to store the frequency of consecutive equal numbers.\n    const map = new Map();\n\n    // Count the maximum streak of consecutive numbers or their neighbors being equal.\n    let maxStreak = 1;\n    nums.forEach((num, i) => {\n        // Check if the current number is equal to the previous or next number.\n        const nextNum = nums[(i + 1) % nums.length];\n        const prevNum = nums[(i - 1 + nums.length) % nums.length];\n        \n        if (num === nextNum || num === prevNum) {\n            // If equal, increase the streak for this number.\n            map.set(num, (map.get(num) || 0) + 1);\n            maxStreak = Math.max(maxStreak, map.get(num));\n        } else {\n            // If not equal, check if this unique number's streak can be merged with its neighbors.\n            const mergedStreak = (map.get(prevNum) || 0) + (map.get(nextNum) || 0) + 1;\n            maxStreak = Math.max(maxStreak, mergedStreak);\n        }\n    });\n\n    // Calculate the minimum seconds based on the maxStreak.\n    let seconds = 0;\n    while (maxStreak < nums.length) {\n        maxStreak *= 3; // Each second, each element can influence up to 3 positions.\n        seconds++;\n    }\n\n    return seconds;\n};"
}