{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 41052000,
    "question_id": "2920",
    "elapsed_time": 4011,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111000001010010000001110000011010100000001100001001101100000000100000000000000010000000000000100000000000001100000000111110010000110000000100001000101001001001000000110111100110001101000001000110000101001010010010111000000000000010001000000001001000110000001000100101000010010000000000000010001000010000000001000000110000001100000000100011000000110110100101001000000000001100000000000001000000000000101001100000010100000100100010001101100000001000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "[3,19,8,12]",
    "expected_output": "2",
    "task_finish_time": 1707951371419,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 180,
    "total_testcases": 579,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1175526136",
    "input_formatted": "[3,19,8,12]",
    "input": "[3,19,8,12]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumSeconds(vector<int>& nums) {\n        // The task requires a different approach to calculate the minimum seconds.\n        // Specifically, we need to find the longest sequence where elements are not equal to the target value\n        // after applying the operation, which requires understanding the pattern of replacements.\n\n        if (isUniform(nums)) return 0; // All elements are already equal.\n\n        // Convert the problem into finding the maximum distance between equal elements.\n        int maxGap = 1;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                if (nums[i] == nums[j]) {\n                    maxGap = max(maxGap, j - i);\n                    break; // Once a match is found, move to the next element in nums.\n                }\n            }\n        }\n\n        // The formula to calculate the minimum seconds is derived from the observation\n        // that the process of equalization effectively reduces the maximum gap between similar elements\n        // in each step. This formula captures the essence of spreading the most frequent element\n        // or any element, to its neighboring positions, thereby equalizing the array.\n        return (maxGap + 1) / 2;\n    }\n\nprivate:\n    bool isUniform(const vector<int>& nums) {\n        // Check if all elements in the array are equal.\n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] != nums[0]) return false;\n        }\n        return true;\n    }\n};"
}