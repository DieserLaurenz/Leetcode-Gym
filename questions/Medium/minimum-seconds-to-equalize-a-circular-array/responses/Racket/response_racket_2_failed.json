{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "equal?: arity mismatch;",
    "full_runtime_error": "equal?: arity mismatch;\n the expected number of arguments does not match the given number\n  expected: 2\n  given: 4\n  context...:\n   solution.rkt:1:0: minimum-seconds\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:30:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 100264000,
    "question_id": "2920",
    "elapsed_time": 256,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[1,2,1,2]",
    "expected_output": "1",
    "task_finish_time": 1707962113332,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 579,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1175600688",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (minimum-seconds nums)\n  (-> (listof exact-integer?) exact-integer?)\n  \n  (define (max-consecutive-items lst)\n    (let loop ((lst lst) (max-count 0) (current-count 1) (last-item (if (null? lst) 0 (car lst))))\n      (if (null? lst)\n          max-count\n          (let ((current-item (car lst)))\n            (if (equal? last-item current-item)\n                (loop (cdr lst) max-count (+ current-count 1) current-item)\n                (loop (cdr lst) (max max-count current-count) 1 current-item))))))\n  \n  (define (rotate-list lst)\n    (append (cdr lst) (list (car lst))))\n  \n  (define (all-the-same? lst)\n    (apply equal? (car lst) (cdr lst)))\n  \n  (if (all-the-same? nums)\n      0\n      (let loop ((nums nums) (seconds 0))\n        (let ((rotated-nums (rotate-list nums)))\n          (if (or (all-the-same? rotated-nums) (> seconds (length nums)))\n              seconds\n              (loop rotated-nums (+ seconds 1)))))))"
}