{
    "acRate": 71.94725124165096,
    "difficulty": "Medium",
    "freqBar": null,
    "questionId": "2807",
    "frontendQuestionId": "2721",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Execute Asynchronous Functions in Parallel",
    "titleSlug": "execute-asynchronous-functions-in-parallel",
    "topicTags": [],
    "hasSolution": true,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * @param {Array<Function>} functions\n * @return {Promise<any>}\n */\nvar promiseAll = function(functions) {\n    \n};\n\n/**\n * const promise = promiseAll([() => new Promise(res => res(42))])\n * promise.then(console.log); // [42]\n */"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "type Fn<T> = () => Promise<T>\n\nfunction promiseAll<T>(functions: Fn<T>[]): Promise<T[]> {\n    \n};\n\n/**\n * const promise = promiseAll([() => new Promise(res => res(42))])\n * promise.then(console.log); // [42]\n */"
        }
    ],
    "content": "Given an array ofasynchronous functionsfunctions, return a new promise promise. Each function in the array accepts no argumentsand returns a promise. All the promises should be executed in parallel.\npromise resolves:\n\nWhen all the promises returned fromfunctionswere resolved successfully in parallel.The resolvedvalue ofpromise should be an array of all the resolved values of promises in the same order as they were in thefunctions. The promise should resolve when all the asynchronous functions in the array have completed execution in parallel.\n\npromise rejects:\n\nWhen anyof the promisesreturned fromfunctionswere rejected.promise should alsorejectwith the reason of the first rejection.\n\nPlease solve it without using the built-inPromise.allfunction.\n\nExample 1:\n\nInput: functions = [\n () => new Promise(resolve => setTimeout(() => resolve(5), 200))\n]\nOutput: {\"t\": 200, \"resolved\": [5]}\nExplanation: \npromiseAll(functions).then(console.log); // [5]\n\nThe single function was resolved at 200ms with a value of 5.\n\nExample 2:\n\nInput: functions = [\n    () => new Promise(resolve => setTimeout(() => resolve(1), 200)), \n    () => new Promise((resolve, reject) => setTimeout(() => reject(\"Error\"), 100))\n]\nOutput: {\"t\": 100, \"rejected\": \"Error\"}\nExplanation: Since one of the promises rejected, the returned promise also rejected with the same error at the same time.\n\nExample 3:\n\nInput: functions = [\n    () => new Promise(resolve => setTimeout(() => resolve(4), 50)), \n    () => new Promise(resolve => setTimeout(() => resolve(10), 150)), \n    () => new Promise(resolve => setTimeout(() => resolve(16), 100))\n]\nOutput: {\"t\": 150, \"resolved\": [4, 10, 16]}\nExplanation: All the promises resolved with a value. The returned promise resolved when the last promise resolved.\n\n\nConstraints:\n\nfunctionsis an array of functions that returns promises\n1 <= functions.length <= 10\n\n"
}