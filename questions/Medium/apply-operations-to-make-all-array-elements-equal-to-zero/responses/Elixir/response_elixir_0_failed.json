{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 196912000,
    "question_id": "2878",
    "elapsed_time": 6019,
    "compare_result": "010011011110011101110010000111001110011101000101110101101010011011111111011101011001001111011010001110001011011010100011011011011101110000101111110111111100001011111011010111111010010011111110110110011101011111101111101110010110011001101111111010011010101100111100101011010111100011110101011111000001011011001010011111100110110001101011010011111000111101111101110110110110000011111111111010101001100110101001101001110101001100011110101111110101011100111100001111111111101111111101011011111011111111110010011101001111100111011010010101100110010111011110111011011101011010001101101100101110111111111011001010001101001011011111111111100000111010011010111111010110100011111100111110001001011000011010101110110101110011001101110010100111011111110111100111110000011000110101010101010001011000101110100101001100110111011111100011110101010001111011101111011111101011100100111011111110001100110101110011101100111101111100111101101100011011110011101100011001011101100001001100010101111110010111010110111011110111111001111111101100000000",
    "code_output": "false",
    "std_output": "",
    "last_testcase": "[2,2,3,1,1,0]\n3",
    "expected_output": "true",
    "task_finish_time": 1706722033319,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 635,
    "total_testcases": 1026,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1162211313",
    "input_formatted": "[2,2,3,1,1,0], 3",
    "input": "[2,2,3,1,1,0]\n3",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec check_array(nums :: [integer], k :: integer) :: boolean\n  def check_array(nums, k) do\n    # Initialize the current sum of adjustments to 0\n    current_sum = 0\n\n    # Iterate through the array with indexes\n    nums\n    |> Enum.with_index()\n    |> Enum.reduce_while({current_sum, true}, fn {num, idx}, {acc_sum, _} ->\n      # Apply adjustments made so far\n      adjusted_num = num - acc_sum\n\n      if adjusted_num < 0 do\n        # If any adjusted number is negative, it's not possible to equalize to 0\n        {:halt, {acc_sum, false}}\n      else\n        # Calculate the new sum of adjustments if needed\n        new_sum = if adjusted_num > 0 and idx <= length(nums) - k, do: acc_sum + adjusted_num, else: acc_sum\n\n        # Continue if the end of the array has not been reached, else halt\n        if idx < length(nums) - k, do: {:cont, {new_sum, true}}, else: {:halt, {new_sum, true}}\n      end\n    end)\n    |> case do\n      {_, true} -> true\n      _ -> false\n    end\n  end\nend"
}