{
    "status_code": 10,
    "lang": "swift",
    "run_success": true,
    "status_runtime": "1157 ms",
    "memory": 19776000,
    "question_id": "2878",
    "elapsed_time": 1177,
    "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
    "code_output": "",
    "std_output": "",
    "last_testcase": "",
    "expected_output": "",
    "task_finish_time": 1706720858348,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 1026,
    "total_testcases": 1026,
    "runtime_percentile": 100,
    "status_memory": "19.8 MB",
    "memory_percentile": 100,
    "pretty_lang": "Swift",
    "submission_id": "1162192419",
    "status_msg": "Accepted",
    "state": "SUCCESS",
    "code": "class Solution {\n    func checkArray(_ nums: [Int], _ k: Int) -> Bool {\n        var nums = nums // Make a mutable copy of nums to work with\n        let n = nums.count\n        var extraDecrements = Array(repeating: 0, count: n) // Track extra decrements needed at each position\n        var currentDecrement = 0 // Track the total decrement applied up to the current position\n        \n        for i in 0..<n {\n            nums[i] += currentDecrement // Apply all previous decrements to the current position\n            if nums[i] < 0 { // If the number is negative after applying decrements, it's impossible to make all elements 0\n                return false\n            }\n            let decrementNeeded = nums[i] // The decrement needed at this position to make it 0\n            if i + k <= n { // Check if a subarray starting at this position can be formed\n                currentDecrement -= decrementNeeded // Apply the decrement to future positions\n                if i + k < n { // If the end of the subarray is within bounds, schedule an increment at the end\n                    extraDecrements[i + k] += decrementNeeded\n                }\n            } else if nums[i] > 0 { // If a subarray cannot be formed and the number is positive, it's impossible to make all elements 0\n                return false\n            }\n            if i < n - 1 {\n                currentDecrement += extraDecrements[i + 1] // Update the total decrement with any scheduled increments\n            }\n        }\n        \n        return true\n    }\n}"
}