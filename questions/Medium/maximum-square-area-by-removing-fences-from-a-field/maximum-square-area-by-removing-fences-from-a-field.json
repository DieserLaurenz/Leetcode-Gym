{
    "acRate": 21.599804305283758,
    "difficulty": "Medium",
    "freqBar": null,
    "frontendQuestionId": "2975",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Maximum Square Area by Removing Fences From a Field",
    "titleSlug": "maximum-square-area-by-removing-fences-from-a-field",
    "topicTags": [
        {
            "name": "Array",
            "id": "VG9waWNUYWdOb2RlOjU=",
            "slug": "array"
        },
        {
            "name": "Hash Table",
            "id": "VG9waWNUYWdOb2RlOjY=",
            "slug": "hash-table"
        },
        {
            "name": "Enumeration",
            "id": "VG9waWNUYWdOb2RlOjYxMDY2",
            "slug": "enumeration"
        }
    ],
    "hasSolution": false,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Solution { public:     int maximizeSquareArea(int m, int n, vector<int>& hFences, vector<int>& vFences) {              } };"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {     public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {              } }"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Solution(object):     def maximizeSquareArea(self, m, n, hFences, vFences):         \"\"\"         :type m: int         :type n: int         :type hFences: List[int]         :type vFences: List[int]         :rtype: int         \"\"\"         "
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Solution:     def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:         "
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "int maximizeSquareArea(int m, int n, int* hFences, int hFencesSize, int* vFences, int vFencesSize) {      }"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Solution {     public int MaximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {              } }"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * @param {number} m  * @param {number} n  * @param {number[]} hFences  * @param {number[]} vFences  * @return {number}  */ var maximizeSquareArea = function(m, n, hFences, vFences) {      };"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "function maximizeSquareArea(m: number, n: number, hFences: number[], vFences: number[]): number {      };"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Solution {      /**      * @param Integer $m      * @param Integer $n      * @param Integer[] $hFences      * @param Integer[] $vFences      * @return Integer      */     function maximizeSquareArea($m, $n, $hFences, $vFences) {              } }"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Solution {     func maximizeSquareArea(_ m: Int, _ n: Int, _ hFences: [Int], _ vFences: [Int]) -> Int {              } }"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Solution {     fun maximizeSquareArea(m: Int, n: Int, hFences: IntArray, vFences: IntArray): Int {              } }"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Solution {   int maximizeSquareArea(int m, int n, List<int> hFences, List<int> vFences) {        } }"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "func maximizeSquareArea(m int, n int, hFences []int, vFences []int) int {      }"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# @param {Integer} m # @param {Integer} n # @param {Integer[]} h_fences # @param {Integer[]} v_fences # @return {Integer} def maximize_square_area(m, n, h_fences, v_fences)      end"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "object Solution {     def maximizeSquareArea(m: Int, n: Int, hFences: Array[Int], vFences: Array[Int]): Int = {              } }"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "impl Solution {     pub fn maximize_square_area(m: i32, n: i32, h_fences: Vec<i32>, v_fences: Vec<i32>) -> i32 {              } }"
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define/contract (maximize-square-area m n hFences vFences)   (-> exact-integer? exact-integer? (listof exact-integer?) (listof exact-integer?) exact-integer?)   )"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec maximize_square_area(M :: integer(), N :: integer(), HFences :: [integer()], VFences :: [integer()]) -> integer(). maximize_square_area(M, N, HFences, VFences) ->   ."
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Solution do   @spec maximize_square_area(m :: integer, n :: integer, h_fences :: [integer], v_fences :: [integer]) :: integer   def maximize_square_area(m, n, h_fences, v_fences) do        end end"
        }
    ],
    "content": "There is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively. Horizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]). Return the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field. Since the answer may be large, return it modulo 109 + 7. Note: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.  Example 1:   Input: m = 4, n = 3, hFences = [2,3], vFences = [2] Output: 4 Explanation: Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4.  Example 2:   Input: m = 6, n = 7, hFences = [2], vFences = [4] Output: -1 Explanation: It can be proved that there is no way to create a square field by removing fences.   Constraints:  3 <= m, n <= 109 1 <= hFences.length, vFences.length <= 600 1 < hFences[i] < m 1 < vFences[i] < n hFences and vFences are unique.  "
}