{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "Line 1: Char 19: minimum-beautiful-substrings: broke its own contract",
    "full_runtime_error": "Line 1: Char 19: minimum-beautiful-substrings: broke its own contract\n  promised: exact-integer?\n  produced: 2.0\n  in: the range of\n      (-> string? exact-integer?)\n  contract from:\n      (function minimum-beautiful-substrings)\n  blaming: (function minimum-beautiful-substrings)\n   (assuming the contract is correct)\n  context...:\n   /usr/share/racket/collects/racket/contract/private/blame.rkt:346:0: raise-blame-error\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:379:33\n   solution.rkt:39:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 100852000,
    "question_id": "2883",
    "elapsed_time": 360,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"1011\"",
    "expected_output": "2",
    "task_finish_time": 1708093730869,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 561,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1177007150",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (minimum-beautiful-substrings s)\n  (-> string? exact-integer?)\n  \n  (define (is-power-of-5? n)\n    (cond\n      [(= n 1) #t]\n      [(or (< n 1) (not (zero? (modulo n 5)))) #f]\n      [else (is-power-of-5? (/ n 5))]))\n\n  (define (binary-to-decimal b)\n    (let loop ((b b) (acc 0) (pow 0))\n      (if (string=? b \"\")\n          acc\n          (loop (substring b 0 (- (string-length b) 1))\n                (+ acc (* (string->number (substring b (- (string-length b) 1))) (expt 2 pow)))\n                (+ pow 1)))))\n\n  (define (dfs idx)\n    (if (= idx (string-length s))\n        0\n        (let loop ((i (+ idx 1)) (min-substr +inf.0))\n          (if (> i (string-length s))\n              min-substr\n              (let ((sub (substring s idx i)))\n                (if (and (not (string-prefix? \"0\" sub))\n                         (is-power-of-5? (binary-to-decimal sub)))\n                    (let ((res (dfs i)))\n                      (if (= res +inf.0)\n                          (loop (+ i 1) min-substr)\n                          (loop (+ i 1) (min min-substr (+ 1 res)))))\n                    (loop (+ i 1) min-substr)))))))\n\n  (let ((result (dfs 0)))\n    (if (= result +inf.0) -1 result)))"
}