{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "=: contract violation",
    "full_runtime_error": "=: contract violation\n  expected: number?\n  given: #\\1\n  context...:\n   solution.rkt:16:12: loop\n   solution.rkt:1:0: minimum-beautiful-substrings\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:379:33\n   solution.rkt:33:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 100148000,
    "question_id": "2883",
    "elapsed_time": 293,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "\"1011\"",
    "expected_output": "2",
    "task_finish_time": 1708093773578,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 561,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1177007667",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (minimum-beautiful-substrings s)\n  (-> string? exact-integer?)\n  \n  (define (is-power-of-5 n)\n    (and (> n 0) (or (= n 1) (and (= (modulo n 5) 0) (is-power-of-5 (/ n 5))))))\n\n  (define (binary-to-decimal bin)\n    (let loop ([i (- (string-length bin) 1)] [result 0] [pow 0])\n      (if (< i 0)\n          result\n          (loop (- i 1) (+ result (* (if (= (string-ref bin i) #\\1) 1 0) (expt 2 pow))) (+ pow 1)))))\n\n  (define (dp i)\n    (if (= i (string-length s)) 0\n        (if (not (equal? (substring s i (+ i 1)) \"0\"))\n            (let loop ([j (+ i 1)] [min-substr +inf.0])\n              (if (> j (string-length s)) min-substr\n                  (let* ([sub (substring s i j)]\n                         [num (binary-to-decimal sub)])\n                    (if (is-power-of-5 num)\n                        (let ([next (dp j)])\n                          (if (= next +inf.0) (loop (+ j 1) min-substr)\n                              (loop (+ j 1) (min min-substr (+ 1 next)))))\n                        (loop (+ j 1) min-substr)))))\n            +inf.0)))\n\n  (let ([result (dp 0)])\n    (if (= result +inf.0) -1 (exact->inexact result))))"
}