{
    "status_code": 15,
    "lang": "racket",
    "run_success": false,
    "runtime_error": "list-ref: index too large for list",
    "full_runtime_error": "list-ref: index too large for list\n  index: 0\n  in: '()\n  context...:\n   solution.rkt:13:0: partition\n   solution.rkt:1:0: min-processing-time\n   /usr/share/racket/collects/racket/contract/private/arrow-higher-order.rkt:375:33\n   solution.rkt:28:2\n   body of (submod \"solution.rkt\" main)",
    "status_runtime": "N/A",
    "memory": 99976000,
    "question_id": "3151",
    "elapsed_time": 232,
    "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[8,10]\n[2,2,3,1,8,7,4,5]",
    "expected_output": "16",
    "task_finish_time": 1707950979133,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 716,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1175523662",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "(define/contract (min-processing-time processorTime tasks)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  (let* ([n (length processorTime)]\n         [sorted-processorTime (sort processorTime <)]\n         [sorted-tasks (sort tasks >)]\n         [tasks-per-processor (partition sorted-tasks n)]\n         [completion-times (map (lambda (proc-time tasks)\n                                  (+ proc-time (apply max tasks)))\n                                sorted-processorTime\n                                tasks-per-processor)])\n    (apply max completion-times)))\n\n(define (partition lst n)\n  (if (null? lst)\n      (make-list n '())\n      (let loop ([lst lst] [result '()] [i 0])\n        (if (null? lst)\n            (map reverse result)\n            (loop (cdr lst)\n                  (append (take result i)\n                          (list (cons (car lst) (list-ref result i)))\n                          (drop result (+ 1 i)))\n                  (if (= i (- n 1)) 0 (+ i 1)))))))"
}