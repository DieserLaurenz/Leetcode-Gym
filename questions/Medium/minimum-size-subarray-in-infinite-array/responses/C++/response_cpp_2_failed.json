{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 89472000,
    "question_id": "3141",
    "elapsed_time": 272,
    "compare_result": "1110111111010011100111101010100111101101111100010111111111001011111110101101100010100101111110111111111110011111000101101000110111011100011101000110100011101100110101001011001101101100101101101011001001010100100010010100110101111101111000011111001110110011100111101010111111000001100110101001011110111010010000011100010101100111110100011101110110110010101001011010111111101101110110110111000101000110100111010111011110011111100111010100011011100011011101111110100010100000101010111010110111001110101101111111111111111111111011111101101",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "[2,1,5,7,7,1,6,3]\n39",
    "expected_output": "9",
    "task_finish_time": 1707971225981,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 329,
    "total_testcases": 535,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1175682344",
    "input_formatted": "[2,1,5,7,7,1,6,3], 39",
    "input": "[2,1,5,7,7,1,6,3]\n39",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSizeSubarray(vector<int>& nums, int target) {\n        int n = nums.size();\n        long long fullSum = 0;\n        for (int num : nums) fullSum += num;\n\n        if (fullSum < target) return -1;\n\n        int result = INT_MAX;\n        unordered_map<long long, int> prefixSumIndex;\n        long long prefixSum = 0;\n\n        prefixSumIndex[0] = -1; // Handle case where sum starts from index 0\n        for (int i = 0; i < n * 2; ++i) {\n            prefixSum += nums[i % n];\n            if (prefixSumIndex.count(prefixSum - target)) {\n                result = min(result, i - prefixSumIndex[prefixSum - target]);\n            }\n            // For a valid subarray in a circular manner, we stop once we've added twice the elements\n            if (i < n) {\n                prefixSumIndex[prefixSum] = i;\n            }\n\n            // If the sum of the entire array is enough, we don't need to go further\n            if (fullSum >= target && i >= n) {\n                long long extraSumNeeded = target - (prefixSum - fullSum);\n                if (prefixSumIndex.count(extraSumNeeded)) {\n                    result = min(result, n + (i % n) - prefixSumIndex[extraSumNeeded]);\n                }\n            }\n        }\n\n        return result == INT_MAX ? -1 : result;\n    }\n};"
}