{
    "status_code": 11,
    "lang": "scala",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 78056000,
    "question_id": "3141",
    "elapsed_time": 1043,
    "compare_result": "1110111111010011101111111010100111101101111100010111111111001011111110111101100010101101111110111111111110011111100111101101110111011100011111000110101011111100111101001011001101101100101101101011101001011100100010011100110101111101111001011111001110110011100111101010111111100001100110101111011110111010110010011110011101110111110100011101110110110010101001011110111111101101110110110111000101010110100111010111111110011111101111010101011011100011111101111110100010100001101010111010110111001110101101111111111111111111111011110111100",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "[2,1,5,7,7,1,6,3]\n39",
    "expected_output": "9",
    "task_finish_time": 1707981883646,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 359,
    "total_testcases": 535,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Scala",
    "submission_id": "1175812446",
    "input_formatted": "[2,1,5,7,7,1,6,3], 39",
    "input": "[2,1,5,7,7,1,6,3]\n39",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "object Solution {\n    def minSizeSubarray(nums: Array[Int], target: Int): Int = {\n        var minSize = Int.MaxValue\n        val prefixSums = new Array[Int](nums.length * 2)\n        var sum = 0\n\n        for (i <- nums.indices) {\n            sum += nums(i)\n            prefixSums(i) = sum\n        }\n\n        if (sum < target) return -1\n\n        for (i <- nums.indices) {\n            prefixSums(i + nums.length) = sum + prefixSums(i)\n        }\n\n        for (i <- nums.indices) {\n            var left = i\n            var right = i + nums.length\n            while (left <= right) {\n                val mid = left + (right - left) / 2\n                val currentSum = if (i > 0) prefixSums(mid) - prefixSums(i - 1) else prefixSums(mid)\n                if (currentSum == target) {\n                    minSize = Math.min(minSize, mid - i + 1)\n                    right = mid - 1\n                } else if (currentSum < target) {\n                    left = mid + 1\n                } else {\n                    right = mid - 1\n                }\n            }\n        }\n\n        if (minSize == Int.MaxValue) -1 else minSize % nums.length\n    }\n}"
}