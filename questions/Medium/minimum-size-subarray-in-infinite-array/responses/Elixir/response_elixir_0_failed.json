{
    "status_code": 11,
    "lang": "elixir",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 140060000,
    "question_id": "3141",
    "elapsed_time": 6018,
    "compare_result": "0000110010000000100011000000000001101000001000010110010000001001010100011101000000000000011100100100111110000010000100100001010100010000010000000110000010001000000001000000001001101100000100000000001001010100000010000000010001011000100000001001001110100011100000100000100010000001000010000001000110110010000010010000000101000000000000001000110110110000100001010010000111100001000010110110000000000100100111000011001000001011100010010001000010000001001000010110000010000000100000000010010111000110000101000000110000000100010010010000000",
    "code_output": "-1",
    "std_output": "",
    "last_testcase": "[1,2,3]\n5",
    "expected_output": "2",
    "task_finish_time": 1707982408116,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 144,
    "total_testcases": 535,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Elixir",
    "submission_id": "1175818244",
    "input_formatted": "[1,2,3], 5",
    "input": "[1,2,3]\n5",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "defmodule Solution do\n  @spec min_size_subarray(nums :: [integer], target :: integer) :: integer\n  def min_size_subarray(nums, target) do\n    nums_length = length(nums)\n    extended_nums = nums ++ nums\n    min_length = Enum.reduce(0..(nums_length*2-1), {0, nums_length + 1}, fn i, {sum, min_len} ->\n      new_sum = sum + Enum.at(extended_nums, i)\n      {new_sum, j} = Enum.reduce(0..i, {new_sum, 0}, fn k, {s, j} ->\n        if s - Enum.at(extended_nums, k) >= target, do: {s - Enum.at(extended_nums, k), j + 1}, else: {s, j}\n      end)\n      if j > 0 and j < min_len, do: {target, j}, else: {sum, min_len}\n    end)\n    |> elem(1)\n    if min_length > nums_length, do: -1, else: min_length\n  end\nend"
}