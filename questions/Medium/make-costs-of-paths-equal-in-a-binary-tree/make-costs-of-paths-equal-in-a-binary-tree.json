{
    "acRate": 58.539363766770734,
    "difficulty": "Medium",
    "freqBar": null,
    "frontendQuestionId": "2673",
    "isFavor": false,
    "paidOnly": false,
    "status": null,
    "title": "Make Costs of Paths Equal in a Binary Tree",
    "titleSlug": "make-costs-of-paths-equal-in-a-binary-tree",
    "topicTags": [
        {
            "name": "Array",
            "id": "VG9waWNUYWdOb2RlOjU=",
            "slug": "array"
        },
        {
            "name": "Dynamic Programming",
            "id": "VG9waWNUYWdOb2RlOjEz",
            "slug": "dynamic-programming"
        },
        {
            "name": "Greedy",
            "id": "VG9waWNUYWdOb2RlOjE3",
            "slug": "greedy"
        },
        {
            "name": "Tree",
            "id": "VG9waWNUYWdOb2RlOjIw",
            "slug": "tree"
        },
        {
            "name": "Binary Tree",
            "id": "VG9waWNUYWdOb2RlOjYxMDU3",
            "slug": "binary-tree"
        }
    ],
    "hasSolution": false,
    "hasVideoSolution": false,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Solution { public:     int minIncrements(int n, vector<int>& cost) {              } };"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {     public int minIncrements(int n, int[] cost) {              } }"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Solution(object):     def minIncrements(self, n, cost):         \"\"\"         :type n: int         :type cost: List[int]         :rtype: int         \"\"\"         "
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Solution:     def minIncrements(self, n: int, cost: List[int]) -> int:         "
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "int minIncrements(int n, int* cost, int costSize){  }"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Solution {     public int MinIncrements(int n, int[] cost) {              } }"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**  * @param {number} n  * @param {number[]} cost  * @return {number}  */ var minIncrements = function(n, cost) {      };"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "function minIncrements(n: number, cost: number[]): number {  };"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Solution {      /**      * @param Integer $n      * @param Integer[] $cost      * @return Integer      */     function minIncrements($n, $cost) {              } }"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Solution {     func minIncrements(_ n: Int, _ cost: [Int]) -> Int {              } }"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Solution {     fun minIncrements(n: Int, cost: IntArray): Int {              } }"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Solution {   int minIncrements(int n, List<int> cost) {    } }"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "func minIncrements(n int, cost []int) int {      }"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# @param {Integer} n # @param {Integer[]} cost # @return {Integer} def min_increments(n, cost)      end"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "object Solution {     def minIncrements(n: Int, cost: Array[Int]): Int = {              } }"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "impl Solution {     pub fn min_increments(n: i32, cost: Vec<i32>) -> i32 {              } }"
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define/contract (min-increments n cost)   (-> exact-integer? (listof exact-integer?) exact-integer?)    )"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec min_increments(N :: integer(), Cost :: [integer()]) -> integer(). min_increments(N, Cost) ->   ."
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Solution do   @spec min_increments(n :: integer, cost :: [integer]) :: integer   def min_increments(n, cost) do    end end"
        }
    ],
    "content": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1. Each node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times. Return the minimum number of increments you need to make the cost of paths from the root to each leaf node equal. Note:  A perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children. The cost of a path is the sum of costs of nodes in the path.   Example 1:   Input: n = 7, cost = [1,5,2,2,3,3,1] Output: 6 Explanation: We can do the following increments: - Increase the cost of node 4 one time. - Increase the cost of node 3 three times. - Increase the cost of node 7 two times. Each path from the root to a leaf will have a total cost of 9. The total increments we did is 1 + 3 + 2 = 6. It can be shown that this is the minimum answer we can achieve.  Example 2:   Input: n = 3, cost = [5,3,3] Output: 0 Explanation: The two paths already have equal total costs, so no increments are needed.   Constraints:  3 <= n <= 105 n + 1 is a power of 2 cost.length == n 1 <= cost[i] <= 104  "
}