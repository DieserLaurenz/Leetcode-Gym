{
    "status_code": 11,
    "lang": "racket",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 127288000,
    "question_id": "3235",
    "elapsed_time": 1236,
    "compare_result": "00110001100100001010010001000000010000011000100000110001001111000101100000000000001100010000001000100100001000000101100100110000101000000100000001010000010110000011001010100001000000100010100010001000001000010010000010100000001000000110000000100000000000111000000000000000001000000000000000000010100000000001000000000010000000000010000000000000010010100001000000000000100100000000000000000000000000000000000000000000001000100000000000000000000000010000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111110000000000000",
    "code_output": "30",
    "std_output": "",
    "last_testcase": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "expected_output": "28",
    "task_finish_time": 1707753581473,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 108,
    "total_testcases": 581,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Racket",
    "submission_id": "1173303816",
    "input_formatted": "\"abcd\", \"acbe\", [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], [2,5,5,1,2,20]",
    "input": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "(define/contract (minimum-cost source target original changed cost)\n  (-> string? string? (listof char?) (listof char?) (listof exact-integer?) exact-integer?)\n  (letrec ([n (string-length source)]\n           [cost-map (make-hash)]\n           [update-cost-map (lambda (i)\n                              (let ([o (list-ref original i)]\n                                    [c (list-ref changed i)]\n                                    [co (list-ref cost i)])\n                                (hash-update! cost-map (cons o c) (lambda (old) (min old co)) co)))]\n           [fill-cost-map (lambda ()\n                            (for ([i (in-range (length original))])\n                              (update-cost-map i)))]\n           [get-cost (lambda (from to)\n                       (hash-ref cost-map (cons from to) #f))]\n           [transform (lambda (i acc)\n                        (if (= i n)\n                            acc\n                            (let* ([s (string-ref source i)]\n                                   [t (string-ref target i)]\n                                   [operation-cost (if (char=? s t) 0 (get-cost s t))])\n                              (if (or (not operation-cost) (< operation-cost 0))\n                                  -1\n                                  (transform (+ i 1) (+ acc (if (char=? s t) 0 operation-cost)))))))])\n    (begin\n      (fill-cost-map)\n      (transform 0 0))))"
}