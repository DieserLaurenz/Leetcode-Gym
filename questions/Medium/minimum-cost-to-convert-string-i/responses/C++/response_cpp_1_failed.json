{
    "status_code": 11,
    "lang": "cpp",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 95988000,
    "question_id": "3235",
    "elapsed_time": 263,
    "compare_result": "01110011101101111010111001001101010010111111101101110001101111010111101000010000101101011100011101100100001000100101110100110000111110001101110001010000010110000011011010110001000110110010100011001010001000111010101010100000001100111111010101100100100010111000000000000000001000000000001000000010100000000001000000000010000000001010000000000000010010100001000000000100100100100000000000000000000000000000000000000000001000100000000000000000000000010000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111110000000000000",
    "code_output": "30",
    "std_output": "",
    "last_testcase": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "expected_output": "28",
    "task_finish_time": 1707742552732,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 174,
    "total_testcases": 581,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "C++",
    "submission_id": "1173160242",
    "input_formatted": "\"abcd\", \"acbe\", [\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"], [\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"], [2,5,5,1,2,20]",
    "input": "\"abcd\"\n\"acbe\"\n[\"a\",\"b\",\"c\",\"c\",\"e\",\"d\"]\n[\"b\",\"c\",\"b\",\"e\",\"b\",\"e\"]\n[2,5,5,1,2,20]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {\n        // Create a map of maps to hold the minimum cost of direct conversions\n        unordered_map<char, unordered_map<char, int>> minCostDirectConversion;\n\n        // Populate the map with the minimum cost for each direct conversion\n        for (int i = 0; i < original.size(); ++i) {\n            if (minCostDirectConversion[original[i]].find(changed[i]) == minCostDirectConversion[original[i]].end() || minCostDirectConversion[original[i]][changed[i]] > cost[i]) {\n                minCostDirectConversion[original[i]][changed[i]] = cost[i];\n            }\n        }\n\n        long long totalCost = 0;\n        for (int i = 0; i < source.length(); ++i) {\n            if (source[i] == target[i]) continue; // No cost if characters are already equal\n\n            // If direct conversion is possible and is the cheapest option\n            if (minCostDirectConversion[source[i]].find(target[i]) != minCostDirectConversion[source[i]].end()) {\n                totalCost += minCostDirectConversion[source[i]][target[i]];\n            } else {\n                // If direct conversion is not possible, check for indirect conversions\n                long long minCost = LONG_LONG_MAX;\n                for (auto &kv : minCostDirectConversion[source[i]]) {\n                    char intermediateChar = kv.first;\n                    int costToIntermediate = kv.second;\n\n                    if (minCostDirectConversion[intermediateChar].find(target[i]) != minCostDirectConversion[intermediateChar].end()) {\n                        int totalIntermediateCost = costToIntermediate + minCostDirectConversion[intermediateChar][target[i]];\n                        minCost = min(minCost, (long long)totalIntermediateCost);\n                    }\n                }\n\n                if (minCost == LONG_LONG_MAX) return -1; // Conversion impossible\n                totalCost += minCost;\n            }\n        }\n\n        return totalCost;\n    }\n};"
}