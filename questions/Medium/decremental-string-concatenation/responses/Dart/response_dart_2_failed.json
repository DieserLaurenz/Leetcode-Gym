{
    "status_code": 15,
    "lang": "dart",
    "run_success": false,
    "runtime_error": "Line 37: Char 28: Error: The getter 'Math' isn't defined for the class 'Solution'.",
    "full_runtime_error": "Line 37: Char 28: Error: The getter 'Math' isn't defined for the class 'Solution'.\nTry correcting the name to the name of an existing getter, or defining a getter or field named 'Math'.\n          dp[mask][last] = Math.min(dp[mask][last], dp[prevMask][prev] + words[last].length - overlapCache[prev][last]);\n                           ^^^^\nLine 45: Char 13: Error: The getter 'Math' isn't defined for the class 'Solution'.\nTry correcting the name to the name of an existing getter, or defining a getter or field named 'Math'.\n      ans = Math.min(ans, dp[(1 << n) - 1][i]);\n            ^^^^",
    "status_runtime": "N/A",
    "memory": 146760000,
    "question_id": "2854",
    "elapsed_time": 433,
    "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "",
    "std_output": "",
    "last_testcase": "[\"aa\",\"ab\",\"bc\"]",
    "expected_output": "4",
    "task_finish_time": 1707158611619,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 0,
    "total_testcases": 1332,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Dart",
    "submission_id": "1167093099",
    "status_msg": "Runtime Error",
    "state": "SUCCESS",
    "code": "class Solution {\n  int minimizeConcatenatedLength(List<String> words) {\n    // Helper function to calculate the overlap between two words\n    int overlap(String a, String b) {\n      for (int i = 0; i < a.length; i++) {\n        if (b.startsWith(a.substring(i))) {\n          return a.length - i;\n        }\n      }\n      return 0;\n    }\n\n    int n = words.length;\n    // dp[mask][i] represents the minimum concatenated length ending with word i\n    List<List<int>> dp = List.generate(1 << n, (_) => List.filled(n, 100000));\n    List<List<int>> overlapCache = List.generate(n, (_) => List.filled(n, 0));\n\n    // Precompute overlaps to optimize\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (i != j) overlapCache[i][j] = overlap(words[i], words[j]);\n      }\n    }\n\n    // Base case: single word masks\n    for (int i = 0; i < n; i++) {\n      dp[1 << i][i] = words[i].length;\n    }\n\n    // Fill DP table\n    for (int mask = 1; mask < (1 << n); mask++) {\n      for (int last = 0; last < n; last++) {\n        if ((mask & (1 << last)) == 0) continue; // Last is not in the current mask\n        for (int prev = 0; prev < n; prev++) {\n          if ((mask & (1 << prev)) == 0 || last == prev) continue; // Prev is not in the mask or same as last\n          int prevMask = mask ^ (1 << last);\n          dp[mask][last] = Math.min(dp[mask][last], dp[prevMask][prev] + words[last].length - overlapCache[prev][last]);\n        }\n      }\n    }\n\n    // Find minimum among all combinations ending with any word\n    int ans = 100000;\n    for (int i = 0; i < n; i++) {\n      ans = Math.min(ans, dp[(1 << n) - 1][i]);\n    }\n\n    return ans;\n  }\n}"
}