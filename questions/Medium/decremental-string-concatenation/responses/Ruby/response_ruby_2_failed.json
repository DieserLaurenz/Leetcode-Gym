{
    "status_code": 11,
    "lang": "ruby",
    "run_success": true,
    "status_runtime": "N/A",
    "memory": 215804000,
    "question_id": "2854",
    "elapsed_time": 3307,
    "compare_result": "100000100000000001010001101110011111100000001000000011100110000000100010100000011101011100000000100110000000001000101001010010000000110000001000011010101000000100011110000010010000100000000100011100000000011001000000000000001001000000000100000000000000100010000111000000000000001000000000000000000000000000001000000000001010000000000000000001000000000000000010000000000001000000000000000000000010000000000000000000010100000000000000011000000000000000000000001000000000100001001000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000001000000000000000000010000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000010000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "code_output": "1",
    "std_output": "",
    "last_testcase": "[\"ab\",\"b\"]",
    "expected_output": "2",
    "task_finish_time": 1707158925039,
    "task_name": "judger.judgetask.Judge",
    "finished": true,
    "total_correct": 96,
    "total_testcases": 1332,
    "runtime_percentile": null,
    "status_memory": "N/A",
    "memory_percentile": null,
    "pretty_lang": "Ruby",
    "submission_id": "1167097644",
    "input_formatted": "[\"ab\",\"b\"]",
    "input": "[\"ab\",\"b\"]",
    "status_msg": "Wrong Answer",
    "state": "SUCCESS",
    "code": "# @param {String[]} words\n# @return {Integer}\ndef minimize_concatenated_length(words)\n  # Dynamic programming solution to find the minimum length of concatenated words\n  # with the ability to perform the join operation in any order.\n  \n  # Sort words by their first character to potentially optimize concatenation\n  words.sort_by! { |word| word[0] }\n\n  # memoization table to store the minimum length for a given set of words\n  memo = {}\n\n  # Helper method to recursively find the minimum concatenated length\n  # words: array of words, used: bitmask representing words already used in concatenation\n  find_min = lambda do |used|\n    return 0 if used == (1 << words.length) - 1 # Base case: all words used\n    return memo[used] if memo.key?(used) # Return cached result if exists\n\n    min_length = Float::INFINITY\n    words.length.times do |i|\n      next if used & (1 << i) != 0 # Skip if word i is already used\n\n      # Calculate the length if word i is used next\n      new_used = used | (1 << i)\n      words.length.times do |j|\n        next if new_used & (1 << j) == 0 # Skip if word j is not yet used\n\n        # Calculate the length considering the join operation between words i and j\n        extra_length = if words[i][-1] == words[j][0]\n                         words[i].length - 1\n                       else\n                         words[i].length\n                       end\n        current_length = find_min.call(new_used) + extra_length\n        min_length = [min_length, current_length].min\n      end\n    end\n\n    memo[used] = min_length # Cache the result\n  end\n\n  # Start recursion with no words used\n  find_min.call(0)\nend"
}