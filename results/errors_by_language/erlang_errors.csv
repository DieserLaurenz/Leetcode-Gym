Language,Error Type,Message,File Path,Code
erlang,compile_error,"Line 4: Char 64: syntax error before: '|'
%    4|                             [unicode:characters_to_list(Word)] |> hd() |> hd()
%     |                                                                ^
Line 1: Char 2: spec for undefined function is_acronym/2
%    1| -spec is_acronym(Words :: [unicode:unicode_binary()], S :: unicode:unicode_binary()) -> boolean().
%     |  ^
Line 24: Char 13: function is_acronym/2 undefined
%   24|       Ret = is_acronym(Param_1, Param_2),
%     |             ^",../questions/Easy\check-if-a-string-is-an-acronym-of-words\responses\Erlang\response_erlang_1_failed.json,"-spec is_acronym(Words :: [unicode:unicode_binary()], S :: unicode:unicode_binary()) -> boolean().
is_acronym(Words, S) ->
    Acronym = lists:map(fun(Word) -> 
                            [unicode:characters_to_list(Word)] |> hd() |> hd()
                        end, Words),
    string:equal(lists:flatten(Acronym), unicode:characters_to_list(S))."
erlang,compile_error,"Line 9: Char 9: call to local/imported function is_symmetric/1 is illegal in guard
%    9|         is_symmetric(Current) ->
%     |         ^",../questions/Easy\count-symmetric-integers\responses\Erlang\response_erlang_0_failed.json,"-spec count_symmetric_integers(Low :: integer(), High :: integer()) -> integer().
count_symmetric_integers(Low, High) ->
    count_symmetric_integers(Low, High, 0).

count_symmetric_integers(Current, High, Count) when Current > High ->
    Count;
count_symmetric_integers(Current, High, Count) ->
    if
        is_symmetric(Current) ->
            count_symmetric_integers(Current + 1, High, Count + 1);
        true ->
            count_symmetric_integers(Current + 1, High, Count)
    end.

is_symmetric(Number) ->
    Digits = integer_to_list(Number),
    Length = length(Digits),
    if
        Length rem 2 =/= 0 ->
            false;
        true ->
            {FirstHalf, SecondHalf} = lists:split(Length div 2, Digits),
            sum_digits(FirstHalf) =:= sum_digits(SecondHalf)
    end.

sum_digits(Digits) ->
    lists:foldl(fun(Digit, Acc) -> Acc + digit_to_int(Digit) end, 0, Digits).

digit_to_int(DigitChar) ->
    erlang:byte(DigitChar) - 48."
erlang,compile_error,"Line 29: Char 13: call to local/imported function is_strictly_increasing/1 is illegal in guard
%   29|         not is_strictly_increasing(remove_subarray(Start, End, Nums)) ->
%     |             ^
Line 29: Char 36: call to local/imported function remove_subarray/3 is illegal in guard
%   29|         not is_strictly_increasing(remove_subarray(Start, End, Nums)) ->
%     |                                    ^",../questions/Easy\count-the-number-of-incremovable-subarrays-i\responses\Erlang\response_erlang_0_failed.json,"-spec is_strictly_increasing(Nums :: [integer()]) -> boolean().
is_strictly_increasing([]) -> true;
is_strictly_increasing([_]) -> true;
is_strictly_increasing([First, Second | Rest]) ->
    First < Second andalso is_strictly_increasing([Second | Rest]).

-spec remove_subarray(Start :: integer(), End :: integer(), Nums :: [integer()]) -> [integer()].
remove_subarray(Start, End, Nums) ->
    {Left, Right} = lists:split(End, Nums),
    {L, _} = lists:split(Start, Left),
    L ++ tl(Right).

-spec incremovable_subarray_count(Nums :: [integer()]) -> integer().
incremovable_subarray_count(Nums) ->
    Length = length(Nums),
    incremovable_subarray_count(Nums, Length, 0).

-spec incremovable_subarray_count(Nums :: [integer()], Length :: integer(), Count :: integer()) -> integer().
incremovable_subarray_count(Nums, Length, Count) ->
    incremovable_subarray_count(Nums, Length, Count, 0, 0).

-spec incremovable_subarray_count(Nums :: [integer()], Length :: integer(), Count :: integer(), Start :: integer(), End :: integer()) -> integer().
incremovable_subarray_count(_, Length, Count, Start, End) when Start =:= Length ->
    Count;
incremovable_subarray_count(Nums, Length, Count, Start, End) when End =:= Length ->
    incremovable_subarray_count(Nums, Length, Count, Start + 1, Start + 1);
incremovable_subarray_count(Nums, Length, Count, Start, End) ->
    NewCount = if
        not is_strictly_increasing(remove_subarray(Start, End, Nums)) ->
            Count + 1;
        true ->
            Count
    end,
    incremovable_subarray_count(Nums, Length, NewCount, Start, End + 1)."
erlang,compile_error,"Line 30: Char 13: call to local/imported function is_strictly_increasing/1 is illegal in guard
%   30|         not is_strictly_increasing(RemovedArray) ->
%     |             ^",../questions/Easy\count-the-number-of-incremovable-subarrays-i\responses\Erlang\response_erlang_1_failed.json,"-spec is_strictly_increasing(Nums :: [integer()]) -> boolean().
is_strictly_increasing([]) -> true;
is_strictly_increasing([_]) -> true;
is_strictly_increasing([First, Second | Rest]) ->
    First < Second andalso is_strictly_increasing([Second | Rest]).

-spec remove_subarray(Start :: integer(), End :: integer(), Nums :: [integer()]) -> [integer()].
remove_subarray(Start, End, Nums) ->
    {Left, Right} = lists:split(End, Nums),
    {L, _} = lists:split(Start, Left),
    L ++ tl(Right).

-spec incremovable_subarray_count(Nums :: [integer()]) -> integer().
incremovable_subarray_count(Nums) ->
    Length = length(Nums),
    incremovable_subarray_count(Nums, Length, 0).

-spec incremovable_subarray_count(Nums :: [integer()], Length :: integer(), Count :: integer()) -> integer().
incremovable_subarray_count(Nums, Length, Count) ->
    incremovable_subarray_count(Nums, Length, Count, 0, 0).

-spec incremovable_subarray_count(Nums :: [integer()], Length :: integer(), Count :: integer(), Start :: integer(), End :: integer()) -> integer().
incremovable_subarray_count(_, Length, Count, Start, _) when Start =:= Length ->
    Count;
incremovable_subarray_count(Nums, Length, Count, Start, End) when End =:= Length ->
    incremovable_subarray_count(Nums, Length, Count, Start + 1, Start + 1);
incremovable_subarray_count(Nums, Length, Count, Start, End) ->
    RemovedArray = remove_subarray(Start, End, Nums),
    NewCount = if
        not is_strictly_increasing(RemovedArray) ->
            Count + 1;
        true ->
            Count
    end,
    incremovable_subarray_count(Nums, Length, NewCount, Start, End + 1)."
erlang,compile_error,"Line 7: Char 1: head mismatch
%    7| distribute_candies(N, Limit, Child, Count) when N > 0, Child < 3 ->
%     | ^
Line 3: Char 5: function distribute_candies/4 undefined
%    3|     distribute_candies(N, Limit, 0, 0).
%     |     ^",../questions/Easy\distribute-candies-among-children-i\responses\Erlang\response_erlang_1_failed.json,"-spec distribute_candies(N :: integer(), Limit :: integer()) -> integer().
distribute_candies(N, Limit) ->
    distribute_candies(N, Limit, 0, 0).

distribute_candies(0, _, Count) ->
    Count + 1;
distribute_candies(N, Limit, Child, Count) when N > 0, Child < 3 ->
    % Count ways for each possible candy number for the current child
    NewCount = lists:foldl(fun(Candies, Acc) ->
                               distribute_candies(N - Candies, Limit, Child + 1, Acc)
                           end, Count, lists:seq(0, min(N, Limit))),
    NewCount;
distribute_candies(_, _, 3, Count) ->
    % If all children have been considered, return the current count
    Count."
erlang,compile_error,"Line 11: Char 8: illegal guard expression
%   11|     if lists:member(H, List) ->
%     |        ^",../questions/Easy\find-common-elements-between-two-arrays\responses\Erlang\response_erlang_0_failed.json,"-spec find_intersection_values(Nums1 :: [integer()], Nums2 :: [integer()]) -> [integer()].
find_intersection_values(Nums1, Nums2) ->
    UniqueNums1 = lists:usort(Nums1),
    UniqueNums2 = lists:usort(Nums2),
    Count1 = count_intersection(UniqueNums1, Nums2),
    Count2 = count_intersection(UniqueNums2, Nums1),
    [Count1, Count2].

count_intersection([], _) -> 0;
count_intersection([H|T], List) ->
    if lists:member(H, List) ->
        1 + count_intersection(T, List);
    true ->
        count_intersection(T, List)
    end."
erlang,compile_error,"Line 5: Char 1: syntax error before: CountPairs
%    5| CountPairs([], Count) ->
%     | ^
Line 3: Char 5: variable 'CountPairs' is unbound
%    3|     CountPairs(Words, 0).
%     |     ^",../questions/Easy\find-maximum-number-of-string-pairs\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_number_of_string_pairs(Words :: [unicode:unicode_binary()]) -> integer().
maximum_number_of_string_pairs(Words) ->
    CountPairs(Words, 0).

CountPairs([], Count) -> 
    Count;
CountPairs([Word|Rest], Count) ->
    ReversedWord = lists:reverse(binary_to_list(Word)),
    case lists:member(ReversedWord, Rest) of
        true ->
            FilteredRest = lists:delete(ReversedWord, Rest),
            CountPairs(FilteredRest, Count + 1);
        false ->
            CountPairs(Rest, Count)
    end."
erlang,compile_error,"Line 11: Char 21: variable 'CountPairs' is unbound
%   11|                     CountPairs(Rest, Count + 1);
%     |                     ^
Line 13: Char 21: variable 'CountPairs' is unbound
%   13|                     CountPairs(Rest, Count)
%     |                     ^",../questions/Easy\find-maximum-number-of-string-pairs\responses\Erlang\response_erlang_1_failed.json,"-spec maximum_number_of_string_pairs(Words :: [unicode:unicode_binary()]) -> integer().
maximum_number_of_string_pairs(Words) ->
    CountPairs = fun
        ([], Count) -> 
            Count;
        ([Word|Rest], Count) ->
            ReversedWord = lists:reverse(binary_to_list(Word)),
            case lists:member(ReversedWord, Rest) of
                true ->
                    FilteredRest = lists:delete(ReversedWord, Rest),
                    CountPairs(Rest, Count + 1);
                false ->
                    CountPairs(Rest, Count)
            end
    end,
    CountPairs(Words, 0)."
erlang,compile_error,"Line 6: Char 12: syntax error before: 'rem'
%    6|     Next = rem(Current + K * Multiplier - 1, N) + 1,
%     |            ^
Line 3: Char 5: function circular_game_losers/5 undefined
%    3|     circular_game_losers(N, K, 1, 0, []).
%     |     ^",../questions/Easy\find-the-losers-of-the-circular-game\responses\Erlang\response_erlang_1_failed.json,"-spec circular_game_losers(N :: integer(), K :: integer()) -> [integer()].
circular_game_losers(N, K) ->
    circular_game_losers(N, K, 1, 0, []).

circular_game_losers(N, K, Current, Multiplier, Received) ->
    Next = rem(Current + K * Multiplier - 1, N) + 1,
    if 
        lists:member(Next, Received) ->
            % Find friends who never received the ball
            [X || X <- lists:seq(1, N), not lists:member(X, Received)];
        true ->
            % Continue the game
            circular_game_losers(N, K, Next, Multiplier + 1, [Next | Received])
    end."
erlang,compile_error,"Line 8: Char 12: syntax error before: 'rem'
%    8|     Next = rem((Current + K * Multiplier - 1), N) + 1,
%     |            ^
Line 3: Char 5: function circular_game_losers/5 undefined
%    3|     circular_game_losers(N, K, 1, 1, []).
%     |     ^",../questions/Easy\find-the-losers-of-the-circular-game\responses\Erlang\response_erlang_2_failed.json,"-spec circular_game_losers(N :: integer(), K :: integer()) -> [integer()].
circular_game_losers(N, K) ->
    circular_game_losers(N, K, 1, 1, []).

circular_game_losers(_N, _K, _Current, _Multiplier, Received) when length(Received) == 2 ->
    [Friend || Friend <- lists:seq(1, length(Received)), not lists:member(Friend, Received)];
circular_game_losers(N, K, Current, Multiplier, Received) ->
    Next = rem((Current + K * Multiplier - 1), N) + 1,
    NewReceived = case lists:member(Next, Received) of
        false -> [Next | Received];
        true -> Received
    end,
    circular_game_losers(N, K, Next, Multiplier + 1, NewReceived)."
erlang,compile_error,"Line 10: Char 5: head mismatch
%   10|     FindLongestSubarray(_, [], _, MaxLength, _) ->
%     |     ^
Line 1: Char 2: spec for undefined function longest_alternating_subarray/2
%    1| -spec longest_alternating_subarray(Nums :: [integer()], Threshold :: integer()) -> integer().
%     |  ^
Line 34: Char 13: function longest_alternating_subarray/2 undefined
%   34|       Ret = longest_alternating_subarray(Param_1, Param_2),
%     |             ^",../questions/Easy\longest-even-odd-subarray-with-threshold\responses\Erlang\response_erlang_2_failed.json,"-spec longest_alternating_subarray(Nums :: [integer()], Threshold :: integer()) -> integer().
longest_alternating_subarray(Nums, Threshold) ->
    FindLongestSubarray = fun(FindLongestSubarray, [H | T], CurrentLength, MaxLength, LastMod) ->
        if
            H =< Threshold, H rem 2 /= LastMod ->
                FindLongestSubarray(FindLongestSubarray, T, CurrentLength + 1, max(CurrentLength + 1, MaxLength), H rem 2);
            true ->
                FindLongestSubarray(FindLongestSubarray, T, 0, MaxLength, 2) % 2 is never a valid mod, so it resets the search
        end;
    FindLongestSubarray(_, [], _, MaxLength, _) ->
        MaxLength
    end,
    FilteredNums = [N || N <- Nums, N =< Threshold, N rem 2 == 0],
    lists:foldl(fun(N, Acc) -> 
                    max(Acc, FindLongestSubarray(FindLongestSubarray, Nums -- [N], 1, 1, N rem 2))
                end, 0, FilteredNums)."
erlang,compile_error,"Line 16: Char 19: syntax error before: 'bxor'
%   16|             XOR = bxor(H, H1),
%     |                   ^
Line 23: Char 1: syntax error before: 'bxor'
%   23| bxor(X, Y) -> X bxor Y.
%     | ^
Line 8: Char 14: function find_max_xor_for_head/4 undefined
%    8|     NewMax = find_max_xor_for_head(H, T, H, Max),
%     |              ^",../questions/Easy\maximum-strong-pair-xor-i\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_strong_pair_xor(Nums :: [integer()]) -> integer().
maximum_strong_pair_xor(Nums) ->
    MaxXor = find_max_xor(Nums, 0),
    MaxXor.

find_max_xor([], Max) -> Max;
find_max_xor([H|T], Max) ->
    NewMax = find_max_xor_for_head(H, T, H, Max),
    find_max_xor(T, NewMax).

find_max_xor_for_head(_, [], _, Max) -> Max;
find_max_xor_for_head(H, [H1|T1], Head, Max) ->
    % Check if it's a strong pair
    if
        abs(H - H1) =< min(H, H1) ->
            XOR = bxor(H, H1),
            NewMax = max(XOR, Max),
            find_max_xor_for_head(H, T1, Head, NewMax);
        true ->
            find_max_xor_for_head(H, T1, Head, Max)
    end.

bxor(X, Y) -> X bxor Y."
erlang,compile_error,"Line 7: Char 33: illegal guard expression
%    7|                       Num =< K, lists:member(Num, Collected) -> {Count + 1, Collected};
%     |                                 ^",../questions/Easy\minimum-operations-to-collect-elements\responses\Erlang\response_erlang_0_failed.json,"-spec min_operations(Nums :: [integer()], K :: integer()) -> integer().
min_operations(Nums, K) ->
    ReverseNums = lists:reverse(Nums),
    Collect = fun(Collector, {Count, Collected}) ->
                  [Num|_] = Collector,
                  if
                      Num =< K, lists:member(Num, Collected) -> {Count + 1, Collected};
                      Num =< K -> {Count + 1, [Num|Collected]};
                      true -> {Count + 1, Collected}
                  end
              end,
    {Ops, _} = lists:foldl(Collect, {0, []}, ReverseNums),
    % Find the operation count when all needed elements are collected
    FindOps = fun(_, {OpsCount, Collected}) when length(Collected) == K -> {OpsCount, done};
                 (Op, {OpsCount, _}) when Op > Ops -> {Ops, done};
                 (Op, Acc) -> Collect(lists:nth(Op, ReverseNums), Acc)
              end,
    {FinalOps, _} = lists:foldl(FindOps, {0, []}, lists:seq(1, length(ReverseNums))),
    FinalOps."
erlang,compile_error,"Line 6: Char 61: variable 'K' is unbound
%    6| min_ops([], _K, Collected, Count) when length(Collected) == K ->
%     |                                                             ^
Line 10: Char 31: illegal guard expression
%   10|         Head =< K andalso not lists:member(Head, Collected) ->
%     |                               ^",../questions/Easy\minimum-operations-to-collect-elements\responses\Erlang\response_erlang_1_failed.json,"-spec min_operations(Nums :: [integer()], K :: integer()) -> integer().
min_operations(Nums, K) ->
    ReverseNums = lists:reverse(Nums),
    min_ops(ReverseNums, K, [], 0).

min_ops([], _K, Collected, Count) when length(Collected) == K ->
    Count;
min_ops([Head|Tail], K, Collected, Count) ->
    if
        Head =< K andalso not lists:member(Head, Collected) ->
            min_ops(Tail, K, [Head|Collected], Count + 1);
        true ->
            min_ops(Tail, K, Collected, Count + 1)
    end."
erlang,compile_error,"Line 15: Char 24: illegal guard expression
%   15|         Head =< K, not maps:is_key(Head, Collected) ->
%     |                        ^",../questions/Easy\minimum-operations-to-collect-elements\responses\Erlang\response_erlang_2_failed.json,"-spec min_operations(Nums :: [integer()], K :: integer()) -> integer().
min_operations(Nums, K) ->
    % Reverse the list to simulate removing elements from the end
    ReverseNums = lists:reverse(Nums),
    % Initialize the loop with the reversed list, target K, an empty set for collected numbers, and 0 operations
    loop(ReverseNums, K, #{}, 0).

% Helper function to loop through the numbers
loop([], _K, Collected, Count) ->
    % If we've iterated through all numbers, return the count
    Count;
loop([Head | Tail], K, Collected, Count) ->
    % Check if the head is within our target range and not already collected
    if
        Head =< K, not maps:is_key(Head, Collected) ->
            % If not collected and within range, add to collected and increment count
            loop(Tail, K, Collected#{Head => true}, Count + 1);
        true ->
            % If already collected or not within range, just increment count
            loop(Tail, K, Collected, Count + 1)
    end,
    % Once we have collected all numbers from 1 to K, we can stop and return the count
    % This check is outside the loop to ensure we iterate the minimum necessary times
    case maps:size(Collected) of
        Size when Size >= K -> Count;
        _ -> loop(Tail, K, Collected, Count + 1)
    end."
erlang,compile_error,"Line 21: Char 46: syntax error before: '::'
%   21|             find_shifts(lists:last(Original) :: lists:droplast(Original), Sorted, N - 1, Shifts + 1, true)
%     |                                              ^
Line 4: Char 14: function find_shifts/5 undefined
%    4|     Shifts = find_shifts(Nums, Sorted, length(Nums), 0, false),
%     |              ^",../questions/Easy\minimum-right-shifts-to-sort-the-array\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_right_shifts(Nums :: [integer()]) -> integer().
minimum_right_shifts(Nums) ->
    Sorted = lists:sort(Nums),
    Shifts = find_shifts(Nums, Sorted, length(Nums), 0, false),
    case Shifts of
        false -> -1; % More than one descending order, cannot sort
        _ -> Shifts
    end.

find_shifts(_, _, 0, Shifts, _) ->
    Shifts; % Base case, return accumulated shifts
find_shifts(Original, Sorted, N, Shifts, Descending) ->
    OHead = hd(Original),
    SHead = hd(Sorted),
    if
        OHead == SHead ->
            find_shifts(tl(Original), tl(Sorted), N - 1, Shifts, Descending);
        Descending ->
            false; % Found another descending order, cannot sort
        true ->
            find_shifts(lists:last(Original) :: lists:droplast(Original), Sorted, N - 1, Shifts + 1, true)
    end."
erlang,compile_error,"Line 19: Char 29: syntax error before: mod
%   19|     Next = lists:nth((Index mod Len) + 1, Nums),
%     |                             ^
Line 10: Char 13: function check_for_break/3 undefined
%   10|             check_for_break(Nums, 1, length(Nums))
%     |             ^",../questions/Easy\minimum-right-shifts-to-sort-the-array\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_right_shifts(Nums :: [integer()]) -> integer().
minimum_right_shifts(Nums) ->
    %% Check if the list is already sorted
    Sorted = lists:sort(Nums),
    if 
        Nums == Sorted ->
            0; % Already sorted, no shifts needed
        true ->
            %% Check for the index where the list ""breaks""
            check_for_break(Nums, 1, length(Nums))
    end.

%% Helper function to find the ""break"" point in the list
check_for_break(_Nums, Index, Len) when Index == Len ->
    -1; % Reached the end, meaning more than one break or not sortable
check_for_break(Nums, Index, Len) ->
    %% Find the point where a number is smaller than its predecessor
    Prev = lists:nth(Index, Nums),
    Next = lists:nth((Index mod Len) + 1, Nums),
    if
        Prev > Next ->
            %% Found the break, calculate shifts needed to sort
            %% The break index indicates how many shifts are needed to make the list sorted
            if is_sorted_after_shift(Nums, Index, Len) ->
                Len - Index;
            true ->
                -1 % Not sortable with shifts
        true ->
            check_for_break(Nums, Index + 1, Len)
    end.

%% Helper function to check if the list can be sorted after the found break
is_sorted_after_shift(Nums, BreakIndex, Len) ->
    Shifted = rotate_list(Nums, Len - BreakIndex),
    lists:sort(Nums) == Shifted.

%% Rotate the list to simulate the right shifts
rotate_list(List, Shifts) ->
    {Left, Right} = lists:split(length(List) - Shifts, List),
    Right ++ Left."
erlang,compile_error,"Line 8: Char 51: syntax error before: '>'
%    8|             NewS = binary:part(S, {0, Position}) <> binary:part(S, Position + 2),
%     |                                                   ^
Line 3: Char 5: function min_length/2 undefined
%    3|     min_length(S, 0).
%     |     ^",../questions/Easy\minimum-string-length-after-removing-substrings\responses\Erlang\response_erlang_0_failed.json,"-spec min_length(S :: unicode:unicode_binary()) -> integer().
min_length(S) ->
    min_length(S, 0).

min_length(S, Acc) ->
    case erlang:binary_match(S, <<""AB"">>) of
        {Position, _Length} ->
            NewS = binary:part(S, {0, Position}) <> binary:part(S, Position + 2),
            min_length(NewS, Acc);
        nomatch ->
            case erlang:binary_match(S, <<""CD"">>) of
                {Position, _Length} ->
                    NewS = binary:part(S, {0, Position}) <> binary:part(S, Position + 2),
                    min_length(NewS, Acc);
                nomatch ->
                    byte_size(S)
            end
    end."
erlang,compile_error,"Line 20: Char 33: syntax error before: '('
%   20|             NewS = <<binary:part(S, 0, Position), binary:part(S, Position + Length)>>,
%     |                                 ^
Line 12: Char 5: function reduce_string/3 undefined
%   12|     reduce_string(S, Patterns, Changed).
%     |     ^",../questions/Easy\minimum-string-length-after-removing-substrings\responses\Erlang\response_erlang_1_failed.json,"-spec min_length(S :: unicode:unicode_binary()) -> integer().
min_length(S) ->
    case reduce_string(S, false) of
        {Reduced, true} ->
            min_length(Reduced); % Continue reducing if a replacement was made
        {Reduced, false} ->
            byte_size(Reduced) % No more replacements, return size
    end.

reduce_string(S, Changed) ->
    Patterns = [<<""AB"">>, <<""CD"">>], % Patterns to search for and remove
    reduce_string(S, Patterns, Changed).

reduce_string(S, [], Changed) ->
    {S, Changed}; % No patterns left, return current state
reduce_string(S, [Pattern | Rest], Changed) ->
    case binary:match(S, Pattern) of
        {Position, Length} ->
            % Remove the found pattern and mark that we've made a change
            NewS = <<binary:part(S, 0, Position), binary:part(S, Position + Length)>>,
            reduce_string(NewS, [Pattern | Rest], true); % Check again for the same pattern
        nomatch ->
            % Pattern not found, move to the next pattern
            reduce_string(S, Rest, Changed)
    end."
erlang,compile_error,"Line 7: Char 59: syntax error before: J
%    7|                                   TripletSums = [X + Nums#J + Y || X <- lists:seq(1, J-1), Y <- lists:seq(J+1, length(Nums)),
%     |                                                           ^
Line 1: Char 2: spec for undefined function minimum_sum/1
%    1| -spec minimum_sum(Nums :: [integer()]) -> integer().
%     |  ^
Line 34: Char 13: function minimum_sum/1 undefined
%   34|       Ret = minimum_sum(Param_1),
%     |             ^",../questions/Easy\minimum-sum-of-mountain-triplets-i\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_sum(Nums :: [integer()]) -> integer().
minimum_sum(Nums) ->
    {MinSum, _} = lists:foldl(fun(J, {Acc, LeftMin}) ->
                                  {NewLeftMin, RightMin} = lists:foldl(fun(X, {LM, RM}) -> 
                                                                            {min(LM, X), min(X, RM)}
                                                                        end, {LeftMin, 50}, lists:sublist(Nums, J)),
                                  TripletSums = [X + Nums#J + Y || X <- lists:seq(1, J-1), Y <- lists:seq(J+1, length(Nums)), 
                                                  X < Nums#J, Y < Nums#J, Nums#X < Nums#J, Nums#Y < Nums#J, X < Y],
                                  MinTripletSum = case TripletSums of
                                                      [] -> Acc;
                                                      _ -> min(Acc, lists:min(TripletSums))
                                                  end,
                                  {MinTripletSum, NewLeftMin}
                              end, {50, 50}, lists:seq(2, length(Nums) - 1)),
    if
        MinSum == 50 -> -1;
        true -> MinSum
    end."
erlang,compile_error,"Line 23: Char 44: illegal guard expression
%   23| find_left_min(Nums, J, I, Min) when I > 0, lists:nth(I, Nums) < lists:nth(J, Nums) ->
%     |                                            ^
Line 23: Char 65: illegal guard expression
%   23| find_left_min(Nums, J, I, Min) when I > 0, lists:nth(I, Nums) < lists:nth(J, Nums) ->
%     |                                                                 ^
Line 30: Char 38: illegal guard expression
%   30| find_right_min(Nums, J, K, Min) when lists:nth(K, Nums) < lists:nth(J, Nums) ->
%     |                                      ^
Line 30: Char 59: illegal guard expression
%   30| find_right_min(Nums, J, K, Min) when lists:nth(K, Nums) < lists:nth(J, Nums) ->
%     |                                                           ^",../questions/Easy\minimum-sum-of-mountain-triplets-i\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_sum(Nums :: [integer()]) -> integer().
minimum_sum(Nums) ->
    MinSum = find_min_sum(Nums, length(Nums), -1),
    MinSum.

find_min_sum(_Nums, 2, MinSum) ->
    MinSum;
find_min_sum(Nums, N, MinSum) ->
    J = N - 1,
    LeftMin = find_left_min(Nums, J, J - 1, hd(Nums)),
    RightMin = find_right_min(Nums, J, J + 1, hd(Nums)),
    CurrentMin = if LeftMin /= -1, RightMin /= -1 -> LeftMin + lists:nth(J, Nums) + RightMin;
                     true -> -1
                 end,
    NewMinSum = if MinSum == -1 -> CurrentMin;
                    CurrentMin == -1 -> MinSum;
                    true -> min(MinSum, CurrentMin)
                end,
    find_min_sum(Nums, J, NewMinSum).

find_left_min(_Nums, _J, 1, Min) ->
    Min;
find_left_min(Nums, J, I, Min) when I > 0, lists:nth(I, Nums) < lists:nth(J, Nums) ->
    find_left_min(Nums, J, I - 1, lists:nth(I, Nums));
find_left_min(Nums, J, I, _Min) ->
    find_left_min(Nums, J, I - 1, -1).

find_right_min(Nums, J, K, Min) when K > length(Nums) ->
    Min;
find_right_min(Nums, J, K, Min) when lists:nth(K, Nums) < lists:nth(J, Nums) ->
    find_right_min(Nums, J, K + 1, lists:nth(K, Nums));
find_right_min(Nums, J, K, _Min) ->
    find_right_min(Nums, J, K + 1, -1)."
erlang,compile_error,"Line 15: Char 61: illegal guard expression
%   15|     {LeftMin, _} = lists:foldl(fun(X, {Min, Flag}) when X < lists:nth(Index, Nums) -> {min(X, Min), true};
%     |                                                             ^
Line 18: Char 70: illegal guard expression
%   18|     {RightMin, RightFlag} = lists:foldl(fun(X, {Min, Flag}) when X < lists:nth(Index, Nums) -> {min(X, Min), true};
%     |                                                                      ^
Line 21: Char 79: illegal guard expression
%   21|     NewMin = if LeftMin =/= 999999, RightMin =/= 999999, RightFlag, LeftMin < lists:nth(Index, Nums), RightMin < lists:nth(Index, Nums) ->
%     |                                                                               ^
Line 21: Char 114: illegal guard expression
%   21|     NewMin = if LeftMin =/= 999999, RightMin =/= 999999, RightFlag, LeftMin < lists:nth(Index, Nums), RightMin < lists:nth(Index, Nums) ->
%     |                                                                                                                  ^",../questions/Easy\minimum-sum-of-mountain-triplets-i\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_sum(Nums :: [integer()]) -> integer().
minimum_sum(Nums) ->
    MinimumSum = find_minimum_sum(Nums, -1),
    case MinimumSum of
        999999 -> -1; % Indicates no valid mountain was found
        _ -> MinimumSum
    end.

find_minimum_sum(Nums, CurrentMin) ->
    find_minimum_sum(Nums, CurrentMin, 2, length(Nums) - 1).

find_minimum_sum(_Nums, CurrentMin, _, 1) ->
    CurrentMin;
find_minimum_sum(Nums, CurrentMin, Index, Length) when Index =< Length ->
    {LeftMin, _} = lists:foldl(fun(X, {Min, Flag}) when X < lists:nth(Index, Nums) -> {min(X, Min), true}; 
                                      (_, Acc) -> Acc 
                               end, {999999, false}, lists:sublist(Nums, Index - 1)),
    {RightMin, RightFlag} = lists:foldl(fun(X, {Min, Flag}) when X < lists:nth(Index, Nums) -> {min(X, Min), true}; 
                                        (_, Acc) -> Acc 
                                end, {999999, false}, lists:sublist(Nums, Index + 1, Length - Index)),
    NewMin = if LeftMin =/= 999999, RightMin =/= 999999, RightFlag, LeftMin < lists:nth(Index, Nums), RightMin < lists:nth(Index, Nums) -> 
                  min(CurrentMin, LeftMin + lists:nth(Index, Nums) + RightMin);
              true -> 
                  CurrentMin
             end,
    find_minimum_sum(Nums, NewMin, Index + 1, Length);
find_minimum_sum(_Nums, CurrentMin, _, _) ->
    CurrentMin."
erlang,compile_error,"Line 4: Char 25: variable 'Gcd' is unbound
%    4|               (G, H) -> Gcd(H, G rem H)
%     |                         ^
Line 7: Char 29: variable 'FirstDigit' is unbound
%    7|                      (N) -> FirstDigit(N div 10)
%     |                             ^",../questions/Easy\number-of-beautiful-pairs\responses\Erlang\response_erlang_0_failed.json,"-spec count_beautiful_pairs(Nums :: [integer()]) -> integer().
count_beautiful_pairs(Nums) ->
    Gcd = fun(G, 0) -> G;
              (G, H) -> Gcd(H, G rem H)
          end,
    FirstDigit = fun(N) when N < 10 -> N;
                     (N) -> FirstDigit(N div 10)
                 end,
    Coprime = fun(A, B) -> Gcd(A, B) == 1 end,
    CountPairs = fun CountPairs(Left, [_|Right], Acc) when Left =/= [] ->
                        [{I, J} || I <- Left, J <- Right, Coprime(FirstDigit(I), J rem 10)];
                     CountPairs([], _, Acc) ->
                        Acc
                 end,
    lists:flatten([CountPairs(lists:sublist(Nums, 1, I), lists:sublist(Nums, I + 1), []) || I <- lists:seq(1, length(Nums) - 1)]),
    length(lists:flatten([CountPairs(lists:sublist(Nums, 1, I), lists:sublist(Nums, I + 1), []) || I <- lists:seq(1, length(Nums) - 1)]))."
erlang,compile_error,"Line 18: Char 64: illegal guard expression
%   18|                                                             if Coprime(FirstD, LastDigit) -> CountAcc + 1;
%     |                                                                ^",../questions/Easy\number-of-beautiful-pairs\responses\Erlang\response_erlang_1_failed.json,"-spec count_beautiful_pairs(Nums :: [integer()]) -> integer().
count_beautiful_pairs(Nums) ->
    Gcd = fun Gcd(A, 0) -> A;
                Gcd(A, B) -> Gcd(B, A rem B)
          end,
    FirstDigit = fun(N) -> 
                    FirstDigitInner = fun FirstDigitInner(M) when M < 10 -> M;
                                       FirstDigitInner(M) -> FirstDigitInner(M div 10)
                                     end,
                    FirstDigitInner(N)
                 end,
    Coprime = fun(A, B) -> Gcd(A, B) == 1 end,
    CountBeautifulPairs = fun CountBeautifulPairs([], Acc) -> Acc;
                                CountBeautifulPairs([H|T], Acc) ->
                                    LastDigit = H rem 10,
                                    Count = lists:foldl(fun(X, CountAcc) ->
                                                            FirstD = FirstDigit(X),
                                                            if Coprime(FirstD, LastDigit) -> CountAcc + 1;
                                                               true -> CountAcc
                                                            end
                                                        end, 0, T),
                                    CountBeautifulPairs(T, Acc + Count)
                          end,
    CountBeautifulPairs(Nums, 0)."
erlang,compile_error,"Line 5: Char 27: variable 'Gcd' is unbound
%    5|                 (A, B) -> Gcd(B, A rem B)
%     |                           ^
Line 10: Char 30: variable 'FirstDigit' is unbound
%   10|                         _ -> FirstDigit(N div 10)
%     |                              ^
Line 22: Char 36: illegal guard expression
%   22|                                 if Coprime(First, Last) -> Acc + 1;
%     |                                    ^",../questions/Easy\number-of-beautiful-pairs\responses\Erlang\response_erlang_2_failed.json,"-spec count_beautiful_pairs(Nums :: [integer()]) -> integer().
count_beautiful_pairs(Nums) ->
    Gcd = fun(A, B) when A == 0 -> B;
                (A, B) when B == 0 -> A;
                (A, B) -> Gcd(B, A rem B)
          end,
    FirstDigit = fun(N) ->
                    case N of
                        _ when N < 10 -> N;
                        _ -> FirstDigit(N div 10)
                    end
                 end,
    Coprime = fun(A, B) -> Gcd(A, B) == 1 end,
    CountPairs = 0,
    Lists = lists:map(fun(N) -> {FirstDigit(N), N rem 10} end, Nums),
    count_beautiful_pairs(Lists, Lists, Coprime, CountPairs).

count_beautiful_pairs([], _, _, Count) -> Count;
count_beautiful_pairs([_], _, _, Count) -> Count;
count_beautiful_pairs([{First, _} = H | T], AllNums, Coprime, Count) ->
    NewCount = lists:foldl(fun({_, Last}, Acc) ->
                                if Coprime(First, Last) -> Acc + 1;
                                   true -> Acc
                                end
                           end, Count, T),
    count_beautiful_pairs(T, AllNums, Coprime, NewCount)."
erlang,compile_error,"Line 10: Char 13: syntax error before: '>'
%   10|     <<48>> <> remove_trailing_zeros(Rest, true);
%     |             ^
Line 3: Char 5: function remove_trailing_zeros/2 undefined
%    3|     remove_trailing_zeros(Num, false).
%     |     ^",../questions/Easy\remove-trailing-zeros-from-a-string\responses\Erlang\response_erlang_1_failed.json,"-spec remove_trailing_zeros(Num :: unicode:unicode_binary()) -> unicode:unicode_binary().
remove_trailing_zeros(Num) ->
    remove_trailing_zeros(Num, false).

remove_trailing_zeros(<<>>, _HasNonZero) ->
    <<>>;
remove_trailing_zeros(<<48, Rest/binary>>, false) -> % '0' with no non-zero found yet
    remove_trailing_zeros(Rest, false);
remove_trailing_zeros(<<48, Rest/binary>>, true) -> % '0' but a non-zero has been found
    <<48>> <> remove_trailing_zeros(Rest, true);
remove_trailing_zeros(<<Char, Rest/binary>>, _) when Char =/= 48 -> % non-zero
    <<Char>> <> remove_trailing_zeros(Rest, true)."
erlang,compile_error,"Line 22: Char 9: illegal guard expression
%   22|         lists:member(X, Nums) ->
%     |         ^",../questions/Easy\smallest-missing-integer-greater-than-sequential-prefix-sum\responses\Erlang\response_erlang_0_failed.json,"-spec missing_integer(Nums :: [integer()]) -> integer().
missing_integer(Nums) ->
    SeqLen = 1, % Start with the first element as the initial sequential prefix
    Sum = lists:nth(1, Nums), % Initial sum is the first element
    {FinalSeqLen, FinalSum} = find_longest_seq_prefix(Nums, SeqLen, Sum, 2),
    find_missing_integer(Nums, FinalSum + 1).

find_longest_seq_prefix(_Nums, SeqLen, Sum, Index) when Index > length(_Nums) -> 
    {SeqLen, Sum}; % End of list reached
find_longest_seq_prefix(Nums, SeqLen, Sum, Index) ->
    Prev = lists:nth(Index - 1, Nums),
    Curr = lists:nth(Index, Nums),
    if
        Curr == Prev + 1 ->
            find_longest_seq_prefix(Nums, SeqLen + 1, Sum + Curr, Index + 1);
        true ->
            {SeqLen, Sum}
    end.

find_missing_integer(Nums, X) ->
    if
        lists:member(X, Nums) ->
            find_missing_integer(Nums, X + 1);
        true ->
            X
    end."
erlang,compile_error,"Line 3: Char 25: neither size nor unit must be given for segments of type utf8/utf16/utf32
%    3|     SeparatorBinary = <<Separator:8/utf8>>,
%     |                         ^",../questions/Easy\split-strings-by-separator\responses\Erlang\response_erlang_0_failed.json,"-spec split_words_by_separator(Words :: [unicode:unicode_binary()], Separator :: char()) -> [unicode:unicode_binary()].
split_words_by_separator(Words, Separator) ->
    SeparatorBinary = <<Separator:8/utf8>>,
    lists:append(lists:map(fun(Word) -> binary:split(Word, SeparatorBinary, [global, {trim, true}]) end, Words))."
erlang,compile_error,"Line 5: Char 10: syntax error before: '->'
%    5| driver() ->
%     |          ^
Line 1: Char 2: spec for undefined function sum_indices_with_k_set_bits/2
%    1| -spec sum_indices_with_k_set_bits(Nums :: [integer()], K :: integer()) -> integer().
%     |  ^
Line 22: Char 13: function sum_indices_with_k_set_bits/2 undefined
%   22|       Ret = sum_indices_with_k_set_bits(Param_1, Param_2),
%     |             ^
Line 39: Char 19: function driver/0 undefined
%   39|   OK = case catch(driver()) of
%     |                   ^",../questions/Easy\sum-of-values-at-indices-with-k-set-bits\responses\Erlang\response_erlang_0_failed.json,"-spec sum_indices_with_k_set_bits(Nums :: [integer()], K :: integer()) -> integer().
sum_indices_with_k_set_bits(Nums, K) ->
    % List comprehension to iterate over the indices and values, summing those values where the index has K set bits
    lists:sum([Val || {Idx, Val} <- lists:zip(lists:seq(0, length(Nums) - 1), Nums), K == length([1 || <<B:1>> <= <<Idx:32>> , B == 1])]),"
erlang,compile_error,"Line 5: Char 38: syntax error before: 1
%    5|     max_freq(Sorted, K, 0, 1, Sorted#1, 1).
%     |                                      ^
Line 1: Char 2: spec for undefined function max_frequency_score/2
%    1| -spec max_frequency_score(Nums :: [integer()], K :: integer()) -> integer().
%     |  ^
Line 31: Char 13: function max_frequency_score/2 undefined
%   31|       Ret = max_frequency_score(Param_1, Param_2),
%     |             ^",../questions/Hard\apply-operations-to-maximize-frequency-score\responses\Erlang\response_erlang_0_failed.json,"-spec max_frequency_score(Nums :: [integer()], K :: integer()) -> integer().
max_frequency_score(Nums, K) ->
    Sorted = lists:sort(Nums),
    Length = length(Sorted),
    max_freq(Sorted, K, 0, 1, Sorted#1, 1).

max_freq([H|T], K, Left, Right, Current, Max) when Right =< length([H|T]) ->
    case K >= (H - Current) * (Right - Left) of
        true -> max_freq(T, K - (H - Current) * (Right - Left), Left, Right + 1, H, max(Right - Left + 1, Max));
        false -> max_freq(T, K, Left + 1, Right, Current, Max)
    end;
max_freq([], _K, _Left, _Right, _Current, Max) ->
    Max."
erlang,compile_error,"Line 37: Char 8: call to local/imported function is_prime/1 is illegal in guard
%   37|     if is_prime(Next) -> Next;
%     |        ^",../questions/Hard\apply-operations-to-maximize-score\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_score(Nums :: [integer()], K :: integer()) -> integer().
maximum_score(Nums, K) ->
    PrimeScores = lists:map(fun(X) -> {prime_score(X), X} end, Nums),
    Sorted = lists:sort(fun({PS1, X1}, {PS2, X2}) ->
                            PS1 > PS2 or (PS1 == PS2 andalso X1 > X2)
                        end, PrimeScores),
    Modulo = 1000000007,
    MaxScore = lists:foldl(fun({_, X}, Acc) -> (Acc * X) rem Modulo end, 1, lists:sublist(Sorted, 1, K)),
    MaxScore.

prime_score(1) -> 0;
prime_score(N) -> prime_score(N, 2, 0).

prime_score(1, _, Acc) -> Acc;
prime_score(N, Factor, Acc) when N rem Factor == 0 ->
    NewAcc = case is_prime(Factor) of
                 true -> Acc + 1;
                 false -> Acc
             end,
    prime_score(N div Factor, Factor, NewAcc);
prime_score(N, Factor, Acc) ->
    prime_score(N, next_prime(Factor), Acc).

is_prime(2) -> true;
is_prime(N) when N rem 2 == 0 -> false;
is_prime(N) -> is_prime(N, 3).

is_prime(N, Factor) when Factor * Factor > N -> true;
is_prime(N, Factor) ->
    if N rem Factor == 0 -> false;
       true -> is_prime(N, Factor + 2)
    end.

next_prime(2) -> 3;
next_prime(N) ->
    Next = N + 1,
    if is_prime(Next) -> Next;
       true -> next_prime(Next + 1)
    end."
erlang,compile_error,"Line 18: Char 72: function init/1 undefined
%   18|                                        lists:map(fun(C) -> C - $a end, init(S))))
%     |                                                                        ^",../questions/Hard\count-complete-substrings\responses\Erlang\response_erlang_0_failed.json,"-spec count_complete_substrings(Word :: unicode:unicode_binary(), K :: integer()) -> integer().
count_complete_substrings(Word, K) ->
    CountSubstrings = fun(S, Acc) ->
        {Counts, Valid} = lists:foldl(fun(C, {Map, V}) ->
            NewCount = maps:get(C, Map, 0) + 1,
            NewMap = maps:put(C, NewCount, Map),
            case NewCount == K of
                true -> {NewMap, V andalso maps:size(NewMap) == 1 andalso maps:all(fun(_, Val) -> Val == K end, NewMap)};
                false -> {NewMap, false}
            end
        end, {#{}, true}, S),
        if Valid -> Acc + 1; true -> Acc end
    end,
    Substrs = [lists:sublist(Word, Start, Len) || Start <- lists:seq(1, length(Word)), Len <- lists:seq(1, length(Word) - Start + 1)],
    FilteredSubstrs = lists:filter(fun(S) -> 
        AdjValid = lists:all(fun({A, B}) -> abs(A - B) =< 2 end, 
                             lists:zip(lists:map(fun(C) -> C - $a end, tl(S)), 
                                       lists:map(fun(C) -> C - $a end, init(S))))
    end, Substrs),
    lists:foldl(CountSubstrings, 0, FilteredSubstrs)."
erlang,compile_error,"Line 11: Char 9: call to local/imported function is_good_integer/3 is illegal in guard
%   11|         is_good_integer(N, Min_sum, Max_sum) ->
%     |         ^",../questions/Hard\count-of-integers\responses\Erlang\response_erlang_2_failed.json,"-spec count(Num1 :: unicode:unicode_binary(), Num2 :: unicode:unicode_binary(), Min_sum :: integer(), Max_sum :: integer()) -> integer().
count(Num1, Num2, Min_sum, Max_sum) ->
    N1 = binary_to_integer(Num1),
    N2 = binary_to_integer(Num2),
    find_good_integers(N1, N2, Min_sum, Max_sum, 0).

find_good_integers(N1, N2, Min_sum, Max_sum, Count) when N1 > N2 -> 
    Count;
find_good_integers(N, N2, Min_sum, Max_sum, Count) ->
    if
        is_good_integer(N, Min_sum, Max_sum) ->
            NewCount = (Count + 1) rem 1000000007;
        true ->
            NewCount = Count
    end,
    find_good_integers(N + 1, N2, Min_sum, Max_sum, NewCount).

is_good_integer(N, Min_sum, Max_sum) ->
    Sum = digit_sum(N),
    Sum >= Min_sum andalso Sum =< Max_sum.

digit_sum(0) -> 0;
digit_sum(N) -> 
    N rem 10 + digit_sum(N div 10)."
erlang,compile_error,"Line 10: Char 6: syntax error before: '::'
%   10|     )::{_, _, Result}.
%     |      ^
Line 1: Char 2: spec for undefined function number_of_good_partitions/1
%    1| -spec number_of_good_partitions(Nums :: [integer()]) -> integer().
%     |  ^
Line 26: Char 13: function number_of_good_partitions/1 undefined
%   26|       Ret = number_of_good_partitions(Param_1),
%     |             ^",../questions/Hard\count-the-number-of-good-partitions\responses\Erlang\response_erlang_2_failed.json,"-spec number_of_good_partitions(Nums :: [integer()]) -> integer().
number_of_good_partitions(Nums) ->
    Mod = 1000000007,
    lists:foldr(
        fun(X, {Prev, Map, Res}) ->
            {X, [{X, 1} | Map], (Res + Prev) rem Mod}
        end,
        {none, [], 0},
        Nums
    )::{_, _, Result}."
erlang,compile_error,"Line 26: Char 49: call to local/imported function is_incremovable/3 is illegal in guard
%   26|                                              if is_incremovable(Nums, I, J) -> AccJ + 1;
%     |                                                 ^",../questions/Hard\count-the-number-of-incremovable-subarrays-ii\responses\Erlang\response_erlang_1_failed.json,"-spec incremovable_subarray_count(Nums :: [integer()]) -> integer().
incremovable_subarray_count(Nums) ->
    lists:foldl(fun(X, {Prev, Count}) ->
                    if
                        X > Prev ->
                            {X, Count + 1};
                        true ->
                            {X, Count}
                    end
                end, {0, 0}, [0|Nums]).

-spec is_incremovable(Nums :: [integer()], Start :: integer(), End :: integer()) -> boolean().
is_incremovable(Nums, Start, End) ->
    Prev = if Start == 1 -> -1; true -> lists:nth(Start - 1, Nums) end,
    Next = if End == length(Nums) -> infinity; true -> lists:nth(End + 1, Nums) end,
    Prev < Next.

-spec count_incremovables(Nums :: [integer()]) -> integer().
count_incremovables(Nums) ->
    count_incremovables(Nums, 1, length(Nums), 0).

-spec count_incremovables(Nums :: [integer()], Start :: integer(), End :: integer(), Acc :: integer()) -> integer().
count_incremovables(Nums, Start, End, Acc) when Start =< End ->
    NewAcc = lists:foldl(fun(I, AccIn) ->
                             lists:foldl(fun(J, AccJ) ->
                                             if is_incremovable(Nums, I, J) -> AccJ + 1;
                                                true -> AccJ
                                             end
                                         end, AccIn, lists:seq(I, End))
                         end, Acc, lists:seq(Start, End)),
    count_incremovables(Nums, Start + 1, End, NewAcc);
count_incremovables(_, _, _, Acc) ->
    Acc.

-spec main(Nums :: [integer()]) -> integer().
main(Nums) ->
    count_incremovables(Nums)."
erlang,compile_error,"Line 16: Char 13: variable 'Incremovable' is unbound
%   16|             Incremovable(T, Acc + NewAcc)
%     |             ^",../questions/Hard\count-the-number-of-incremovable-subarrays-ii\responses\Erlang\response_erlang_2_failed.json,"-spec incremovable_subarray_count(Nums :: [integer()]) -> integer().
incremovable_subarray_count(Nums) ->
    Incremovable = fun
        ([], Acc) -> Acc;
        ([_ | T] = List, Acc) ->
            {NewAcc, _} = lists:foldl(
                fun(X, {A, Prev}) ->
                    case X > Prev of
                        true -> {A + 1, X};
                        false -> {A, X}
                    end
                end,
                {0, hd(List)},
                T
            ),
            Incremovable(T, Acc + NewAcc)
    end,
    TotalLength = length(Nums),
    TotalSubarrays = TotalLength * (TotalLength + 1) div 2,
    NonIncremovable = Incremovable(Nums, 0),
    TotalSubarrays - NonIncremovable."
erlang,compile_error,"Line 10: Char 54: illegal guard expression
%   10|                         Val >= Start, Val =< Finish, integer_to_list(Val) -- lists:seq($0, $0 + Limit) == [] ->
%     |                                                      ^
Line 10: Char 75: illegal guard expression
%   10|                         Val >= Start, Val =< Finish, integer_to_list(Val) -- lists:seq($0, $0 + Limit) == [] ->
%     |                                                                           ^
Line 10: Char 78: illegal guard expression
%   10|                         Val >= Start, Val =< Finish, integer_to_list(Val) -- lists:seq($0, $0 + Limit) == [] ->
%     |                                                                              ^
Line 11: Char 29: variable 'Count' is unbound
%   11|                             Count(Num + 1, Acc + 1);
%     |                             ^
Line 13: Char 29: variable 'Count' is unbound
%   13|                             Count(Num + 1, Acc)
%     |                             ^",../questions/Hard\count-the-number-of-powerful-integers\responses\Erlang\response_erlang_0_failed.json,"-spec number_of_powerful_int(Start :: integer(), Finish :: integer(), Limit :: integer(), S :: unicode:unicode_binary()) -> integer().
number_of_powerful_int(Start, Finish, Limit, S) ->
    Suffix = binary_to_integer(S),
    SuffixLength = byte_size(S),
    MaxPrefix = trunc((Finish - Suffix) / math:pow(10, SuffixLength)),
    Count = fun(Num, Acc) when Num > MaxPrefix -> Acc;
                (Num, Acc) ->
                    Val = Num * trunc(math:pow(10, SuffixLength)) + Suffix,
                    if 
                        Val >= Start, Val =< Finish, integer_to_list(Val) -- lists:seq($0, $0 + Limit) == [] -> 
                            Count(Num + 1, Acc + 1);
                        true -> 
                            Count(Num + 1, Acc)
                    end
            end,
    Count(0, 0)."
erlang,compile_error,"Line 11: Char 34: variable 'Start' is unbound
%   11|         end, infinity, lists:seq(Start, Idx - 1)),
%     |                                  ^",../questions/Hard\divide-an-array-into-subarrays-with-minimum-cost-ii\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_cost(Nums :: [integer()], K :: integer(), Dist :: integer()) -> integer().
minimum_cost(Nums, K, Dist) ->
    N = length(Nums),
    DP = lists:duplicate(N + 1, infinity),
    DP1 = lists:update_at(1, 0, DP),
    {_, Result} = lists:foldl(fun(X, {Idx, DP_Current}) ->
        MinCost = lists:foldl(fun(I, Min) ->
            Start = max(1, Idx - Dist),
            Cost = lists:nth(I, DP_Current) + lists:nth(Idx, Nums),
            min(Min, Cost)
        end, infinity, lists:seq(Start, Idx - 1)),
        DP_Next = lists:update_at(Idx + 1, MinCost, DP_Current),
        {Idx + 1, DP_Next}
    end, {1, DP1}, lists:seq(2, N)),
    lists:nth(N - K + 2, Result)."
erlang,compile_error,"Line 9: Char 9: call to local/imported function is_good_subset/1 is illegal in guard
%    9|         is_good_subset(Subset) ->
%     |         ^",../questions/Hard\find-a-good-subset-of-the-matrix\responses\Erlang\response_erlang_2_failed.json,"-spec good_subsetof_binary_matrix(Grid :: [[integer()]]) -> [integer()].
good_subsetof_binary_matrix(Grid) ->
    find_good_subsets(Grid, lists:seq(0, length(Grid) - 1)).

find_good_subsets(_, []) -> [];
find_good_subsets(Grid, [H|T]) ->
    Subset = [lists:nth(Index + 1, Grid) || Index <- [H|T]],
    if
        is_good_subset(Subset) ->
            [H|T]; % Return the current subset if it's good
        true ->
            NextTry = find_good_subsets(Grid, T),
            % Try adding more rows to see if a good subset can be found
            if
                NextTry == [] ->
                    find_good_subsets(Grid, T); % Skip the current head and try the next
                true ->
                    NextTry
            end
    end.

is_good_subset(Subset) ->
    Transposed = transpose(Subset),
    lists:all(fun(Column) ->
                  Sum = lists:sum(Column),
                  Sum =< length(Subset) div 2
              end, Transposed).

transpose([]) -> [];
transpose([[]|_]) -> [];
transpose([H|T]) ->
    [ [Head|Tail] || Head <- H, Tail <- transpose(T)]."
erlang,compile_error,"Line 11: Char 72: syntax error before: '=='
%   11|                            SList >= lists:nthtail(I, SList) -- Pattern == Pattern]
%     |                                                                        ^
Line 1: Char 2: spec for undefined function beautiful_indices/4
%    1| -spec beautiful_indices(S :: unicode:unicode_binary(), A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), K :: integer()) -> [integer()].
%     |  ^
Line 40: Char 13: function beautiful_indices/4 undefined
%   40|       Ret = beautiful_indices(Param_1, Param_2, Param_3, Param_4),
%     |             ^",../questions/Hard\find-beautiful-indices-in-the-given-array-ii\responses\Erlang\response_erlang_2_failed.json,"-spec beautiful_indices(S :: unicode:unicode_binary(), A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), K :: integer()) -> [integer()].
beautiful_indices(S, A, B, K) ->
    SList = binary_to_list(S),
    AList = binary_to_list(A),
    BList = binary_to_list(B),
    SL = length(SList),
    AL = length(AList),
    BL = length(BList),
    FindIndices = fun(Pattern, Max) ->
                      [I || I <- lists:seq(0, Max - 1),
                           SList >= lists:nthtail(I, SList) -- Pattern == Pattern]
                  end,
    AIndices = FindIndices(AList, SL - AL + 1),
    BIndices = FindIndices(BList, SL - BL + 1),
    IsBeautiful = fun(I) ->
                       lists:any(fun(J) -> abs(I - J) =< K end, BIndices)
                   end,
    lists:filter(IsBeautiful, AIndices)."
erlang,compile_error,"Line 10: Char 81: syntax error before: B
%   10|     case lists:any(fun(X) -> X > lists:nth(A + 1, MaxRight) andalso X > Heights#B end, lists:sublist(Heights, B + 1)) of
%     |                                                                                 ^
Line 6: Char 9: function find_meeting_building/4 undefined
%    6|         find_meeting_building(A, B, Heights, MaxRightRev)
%     |         ^",../questions/Hard\find-building-where-alice-and-bob-can-meet\responses\Erlang\response_erlang_1_failed.json,"-spec leftmost_building_queries(Heights :: [integer()], Queries :: [[integer()]]) -> [integer()].
leftmost_building_queries(Heights, Queries) ->
    MaxRight = lists:foldl(fun(H, Acc) -> [max(H, hd(Acc)) | Acc] end, [0], Heights),
    MaxRightRev = lists:reverse(MaxRight),
    lists:map(fun([A, B]) ->
        find_meeting_building(A, B, Heights, MaxRightRev)
    end, Queries).

find_meeting_building(A, B, Heights, MaxRight) when A =< B ->
    case lists:any(fun(X) -> X > lists:nth(A + 1, MaxRight) andalso X > Heights#B end, lists:sublist(Heights, B + 1)) of
        true -> B;
        false -> -1
    end;
find_meeting_building(A, B, Heights, MaxRight) ->
    case lists:any(fun(X) -> X > lists:nth(B + 1, MaxRight) andalso X > Heights#A end, lists:sublist(Heights, A + 1)) of
        true -> A;
        false -> -1
    end."
erlang,compile_error,"Line 6: Char 85: syntax error before: Idx
%    6|     MeetCandidates = [Idx || Idx <- lists:seq(max(A,B)+1, length(Heights)), Heights#Idx > max(Heights#A, Heights#B)],
%     |                                                                                     ^
Line 3: Char 29: function find_meet/3 undefined
%    3|     lists:map(fun({A,B}) -> find_meet(A, B, Heights) end, Queries).
%     |                             ^",../questions/Hard\find-building-where-alice-and-bob-can-meet\responses\Erlang\response_erlang_2_failed.json,"-spec leftmost_building_queries(Heights :: [integer()], Queries :: [[integer()]]) -> [integer()].
leftmost_building_queries(Heights, Queries) ->
    lists:map(fun({A,B}) -> find_meet(A, B, Heights) end, Queries).

find_meet(A, B, Heights) ->
    MeetCandidates = [Idx || Idx <- lists:seq(max(A,B)+1, length(Heights)), Heights#Idx > max(Heights#A, Heights#B)],
    case MeetCandidates of
        [] -> -1;
        [FirstMeet|_] -> FirstMeet
    end."
erlang,compile_error,"Line 12: Char 1: function find_maximum_length/1 already defined
%   12| find_maximum_length([H | T]) ->
%     | ^",../questions/Hard\find-maximum-non-decreasing-array-length\responses\Erlang\response_erlang_1_failed.json,"-spec find_maximum_length(Nums :: [integer()]) -> integer().
find_maximum_length(Nums) ->
    lists:foldl(fun(X, {Prev, Len, MaxLen}) ->
                        if
                            X >= Prev ->
                                {X, Len + 1, max(Len + 1, MaxLen)};
                            true ->
                                {X, 1, MaxLen}
                        end
                end, {hd(Nums), 1, 1}, tl(Nums)).

find_maximum_length([H | T]) ->
    {_, _, MaxLen} = find_maximum_length([H | T]),
    MaxLen."
erlang,compile_error,"Line 11: Char 5: syntax error before: 'end'
%   11|     end.
%     |     ^
Line 1: Char 2: spec for undefined function find_maximum_length/1
%    1| -spec find_maximum_length(Nums :: [integer()]) -> integer().
%     |  ^
Line 14: Char 22: function find_maximum_length/1 undefined
%   14|     {_, _, MaxLen} = find_maximum_length(Nums),
%     |                      ^
Line 31: Char 13: function find_maximum_length/1 undefined
%   31|       Ret = find_maximum_length(Param_1),
%     |             ^",../questions/Hard\find-maximum-non-decreasing-array-length\responses\Erlang\response_erlang_2_failed.json,"-spec find_maximum_length(Nums :: [integer()]) -> integer().
find_maximum_length(Nums) ->
    lists:foldl(fun(X, {Prev, Len, MaxLen}) ->
                        if
                            X >= Prev ->
                                {X, Len + 1, max(Len + 1, MaxLen)};
                            true ->
                                {X, 1, MaxLen}
                        end
                end, {hd(Nums), 1, 1}, tl(Nums))
    end.

find_maximum_length_corrected(Nums) ->
    {_, _, MaxLen} = find_maximum_length(Nums),
    MaxLen."
erlang,compile_error,"Line 15: Char 36: illegal guard expression
%   15| bfs(Queue, Visited, Graph, N) when sets:size(Visited) == N -> true;
%     |                                    ^
Line 22: Char 50: illegal guard expression
%   22|                                               if sets:is_element(Neighbor, V) ->
%     |                                                  ^",../questions/Hard\greatest-common-divisor-traversal\responses\Erlang\response_erlang_0_failed.json,"-spec gcd(Integer1 :: integer(), Integer2 :: integer()) -> integer().
gcd(A, 0) -> A;
gcd(A, B) -> gcd(B, A rem B).

-spec connected(Nodes :: [{integer(), integer()}], N :: integer()) -> boolean().
connected(Edges, N) ->
  Graph = lists:foldl(fun({A, B}, Acc) ->
                        maps:update_with(A, fun(L) -> [B|L] end, [B], Acc)
                      end, #{}, Edges),
  Visited = sets:from_list([lists:nth(1, Edges)]),
  Queue = queue:from_list([lists:nth(1, Edges)]),
  bfs(Queue, Visited, Graph, N).

-spec bfs(Queue :: queue:queue(), Visited :: sets:set(), Graph :: map(), N :: integer()) -> boolean().
bfs(Queue, Visited, Graph, N) when sets:size(Visited) == N -> true;
bfs(Queue, Visited, Graph, N) ->
  case queue:out(Queue) of
    {{empty, _}, _} -> false;
    {{value, Node}, RestQueue} ->
      Neighbors = maps:get(Node, Graph, []),
      {NewQueue, NewVisited} = lists:foldl(fun(Neighbor, {Q, V}) ->
                                              if sets:is_element(Neighbor, V) ->
                                                {Q, V};
                                              true ->
                                                {queue:in(Neighbor, Q), sets:add_element(Neighbor, V)}
                                              end
                                            end, {RestQueue, Visited}, Neighbors),
      bfs(NewQueue, NewVisited, Graph, N)
  end.

-spec can_traverse_all_pairs(Nums :: [integer()]) -> boolean().
can_traverse_all_pairs(Nums) ->
  N = length(Nums),
  Indices = lists:seq(0, N - 1),
  Pairs = [[I, J] || I <- Indices, J <- Indices, I < J, gcd(lists:nth(I + 1, Nums), lists:nth(J + 1, Nums)) > 1],
  Edges = lists:map(fun([A, B]) -> {A + 1, B + 1} end, Pairs),
  connected(Edges, N)."
erlang,compile_error,"Line 13: Char 112: syntax error before: '::'
%   13| -spec group_nodes(Edges :: [{integer(), integer()}], Groups :: map(), GroupNums :: map(), GroupId :: integer() :: map()) when is_map(Groups), is_map(GroupNums) -> map().
%     |                                                                                                                ^
Line 21: Char 54: syntax error before: ','
%   21|                                             {ok, IdI}, {error, _} ->
%     |                                                      ^
Line 10: Char 14: function group_nodes/3 undefined
%   10|     Groups = group_nodes(Edges, maps:new(), maps:new()),
%     |              ^",../questions/Hard\greatest-common-divisor-traversal\responses\Erlang\response_erlang_1_failed.json,"-spec gcd(Integer1 :: integer(), Integer2 :: integer()) -> integer().
gcd(A, 0) -> A;
gcd(A, B) -> gcd(B, A rem B).

-spec can_traverse_all_pairs(Nums :: [integer()]) -> boolean().
can_traverse_all_pairs(Nums) ->
    Edges = [{I, J} || I <- lists:seq(0, length(Nums) - 1),
                      J <- lists:seq(0, length(Nums) - 1),
                      I < J, gcd(lists:nth(I + 1, Nums), lists:nth(J + 1, Nums)) > 1],
    Groups = group_nodes(Edges, maps:new(), maps:new()),
    length(Groups) == 1.

-spec group_nodes(Edges :: [{integer(), integer()}], Groups :: map(), GroupNums :: map(), GroupId :: integer() :: map()) when is_map(Groups), is_map(GroupNums) -> map().
group_nodes([], Groups, _) -> Groups;
group_nodes([{I, J} | T], Groups, GroupNums) ->
    {GroupsUpdated, GroupNumsUpdated} = case {maps:find(I, GroupNums), maps:find(J, GroupNums)} of
                                            {error, error} ->
                                                NewGroupId = map_size(Groups) + 1,
                                                {maps:update_with(NewGroupId, fun(L) -> lists:usort([I, J | L]) end, [I, J], Groups),
                                                 maps:put(I, NewGroupId, maps:put(J, NewGroupId, GroupNums))};
                                            {ok, IdI}, {error, _} ->
                                                {maps:update_with(IdI, fun(L) -> lists:usort([J | L]) end, [J], Groups),
                                                 maps:put(J, IdI, GroupNums)};
                                            {error, _}, {ok, IdJ} ->
                                                {maps:update_with(IdJ, fun(L) -> lists:usort([I | L]) end, [I], Groups),
                                                 maps:put(I, IdJ, GroupNums)};
                                            {ok, IdI}, {ok, IdJ} when IdI == IdJ ->
                                                {Groups, GroupNums};
                                            {ok, IdI}, {ok, IdJ} ->
                                                GroupI = maps:get(IdI, Groups),
                                                GroupJ = maps:get(IdJ, Groups),
                                                NewGroup = lists:usort(GroupI ++ GroupJ),
                                                GroupsTemp = maps:remove(IdJ, maps:put(IdI, NewGroup, Groups)),
                                                GroupNumsTemp = lists:foldl(fun(E, Acc) -> maps:put(E, IdI, Acc) end, GroupNums, NewGroup),
                                                {GroupsTemp, GroupNumsTemp}
                                        end,
    group_nodes(T, GroupsUpdated, GroupNumsUpdated)."
erlang,compile_error,"Line 28: Char 24: call to local/imported function gcd/2 is illegal in guard
%   28|                     if gcd(lists:nth(I + 1, Nums), lists:nth(J + 1, Nums)) > 1 ->
%     |                        ^
Line 28: Char 28: illegal guard expression
%   28|                     if gcd(lists:nth(I + 1, Nums), lists:nth(J + 1, Nums)) > 1 ->
%     |                            ^
Line 28: Char 52: illegal guard expression
%   28|                     if gcd(lists:nth(I + 1, Nums), lists:nth(J + 1, Nums)) > 1 ->
%     |                                                    ^",../questions/Hard\greatest-common-divisor-traversal\responses\Erlang\response_erlang_2_failed.json,"-spec gcd(Integer1 :: integer(), Integer2 :: integer()) -> integer().
gcd(A, 0) -> A;
gcd(A, B) -> gcd(B, A rem B).

-spec find_root(Node :: integer(), Parents :: map()) -> integer().
find_root(Node, Parents) ->
    case maps:get(Node, Parents) of
        Node -> Node;
        Parent -> find_root(Parent, Parents)
    end.

-spec union(Node1 :: integer(), Node2 :: integer(), Parents :: map()) -> map().
union(Node1, Node2, Parents) ->
    Root1 = find_root(Node1, Parents),
    Root2 = find_root(Node2, Parents),
    case Root1 == Root2 of
        true -> Parents;
        false -> Parents#{Root1 => Root2}
    end.

-spec can_traverse_all_pairs(Nums :: [integer()]) -> boolean().
can_traverse_all_pairs(Nums) ->
    InitialParents = lists:foldl(fun(X, Acc) -> Acc#{X => X} end, #{}, lists:seq(0, length(Nums) - 1)),
    FinalParents = lists:foldl(
        fun(I, Acc) ->
            lists:foldl(
                fun(J, Acc1) ->
                    if gcd(lists:nth(I + 1, Nums), lists:nth(J + 1, Nums)) > 1 ->
                        union(I, J, Acc1);
                       true ->
                        Acc1
                    end
                end, Acc, lists:seq(I + 1, length(Nums) - 1))
        end, InitialParents, lists:seq(0, length(Nums) - 2)),
    Roots = lists:usort([find_root(X, FinalParents) || X <- lists:seq(0, length(Nums) - 1)]),
    length(Roots) == 1."
erlang,compile_error,"Line 25: Char 64: illegal character
%   25| prefix_length([H|T], K, Seen, Length) when length(Seen) < K; H  Seen ->
%     |                                                                ^
Line 27: Char 69: illegal character
%   27| prefix_length([H|_], K, Seen, Length) when length(Seen) == K, not H  Seen ->
%     |                                                                     ^
Line 27: Char 71: syntax error before: Seen
%   27| prefix_length([H|_], K, Seen, Length) when length(Seen) == K, not H  Seen ->
%     |                                                                       ^
Line 9: Char 50: variable '_' is unbound
%    9| find_max_partitions(_, _, _, _) when is_function(_, 0) -> 0; % Base case for recursion termination
%     |                                                  ^
Line 21: Char 20: function prefix_length/4 undefined
%   21|     PrefixLength = prefix_length(S, K, [], 0),
%     |                    ^",../questions/Hard\maximize-the-number-of-partitions-after-operations\responses\Erlang\response_erlang_1_failed.json,"-spec max_partitions_after_operations(S :: unicode:unicode_binary(), K :: integer()) -> integer().
max_partitions_after_operations(S, K) ->
    String = unicode:characters_to_list(S),
    MaxPartitions = fun MaxPartitions(S, K, Changed) ->
        find_max_partitions(S, K, Changed, MaxPartitions)
    end,
    MaxPartitions(String, K, false).

find_max_partitions(_, _, _, _) when is_function(_, 0) -> 0; % Base case for recursion termination
find_max_partitions(S, K, Changed, MaxPartitionsFun) ->
    CurrentPartitionCount = count_partitions(S, K, 0),
    if
        Changed -> CurrentPartitionCount;
        true ->
            MaxCountWithChange = lists:max([MaxPartitionsFun(change_char(S, I), K, true) || I <- lists:seq(1, length(S))]),
            max(CurrentPartitionCount, MaxCountWithChange)
    end.

count_partitions([], _, Count) -> Count;
count_partitions(S, K, Count) ->
    PrefixLength = prefix_length(S, K, [], 0),
    count_partitions(lists:nthtail(PrefixLength, S), K, Count + 1).

prefix_length([], _, _, Length) -> Length;
prefix_length([H|T], K, Seen, Length) when length(Seen) < K; H  Seen ->
    prefix_length(T, K, lists:usort([H|Seen]), Length + 1);
prefix_length([H|_], K, Seen, Length) when length(Seen) == K, not H  Seen ->
    Length.

change_char(S, Pos) ->
    [if I == Pos -> $a; true -> C end || {C, I} <- lists:zip(S, lists:seq(1, length(S)))].

max(A, B) when A >= B -> A;
max(_, B) -> B."
erlang,compile_error,"Line 23: Char 32: illegal guard expression
%   23|         length(Seen) == K, not lists:member(H, Seen) ->
%     |                                ^",../questions/Hard\maximize-the-number-of-partitions-after-operations\responses\Erlang\response_erlang_2_failed.json,"-spec max_partitions_after_operations(S :: unicode:unicode_binary(), K :: integer()) -> integer().
max_partitions_after_operations(S, K) ->
    String = unicode:characters_to_list(S),
    MaxPartitions = fun(MaxPartitions, Str, K, Changed) ->
        case Changed of
            true ->
                lists:max([partition_count(change_char(Str, I, C), K) || I <- lists:seq(1, length(Str)), C <- lists:seq($a, $z)]) + 1;
            false ->
                partition_count(Str, K)
        end
    end,
    OriginalCount = MaxPartitions(MaxPartitions, String, K, false),
    WithChangeCount = MaxPartitions(MaxPartitions, String, K, true),
    max(OriginalCount, WithChangeCount).

partition_count(Str, K) ->
    partition_count(Str, K, 0, []).

partition_count([], _, Count, _) ->
    Count;
partition_count([H|T], K, Count, Seen) when length(Seen) =< K ->
    if
        length(Seen) == K, not lists:member(H, Seen) ->
            partition_count(T, K, Count + 1, [H]);
        true ->
            partition_count(T, K, Count, lists:usort([H|Seen]))
    end.

change_char(Str, Pos, Char) ->
    Prefix = lists:sublist(Str, Pos - 1),
    Suffix = lists:nthtail(Pos, Str),
    Prefix ++ [Char] ++ Suffix."
erlang,compile_error,"Line 4: Char 45: syntax error before: '('
%    4|     Next = lists:map(fun(X) -> {X, Receiver#(X+1)} end, lists:seq(0, N-1)),
%     |                                             ^
Line 1: Char 2: spec for undefined function get_max_function_value/2
%    1| -spec get_max_function_value(Receiver :: [integer()], K :: integer()) -> integer().
%     |  ^
Line 36: Char 13: function get_max_function_value/2 undefined
%   36|       Ret = get_max_function_value(Param_1, Param_2),
%     |             ^",../questions/Hard\maximize-value-of-function-in-a-ball-passing-game\responses\Erlang\response_erlang_2_failed.json,"-spec get_max_function_value(Receiver :: [integer()], K :: integer()) -> integer().
get_max_function_value(Receiver, K) ->
    N = length(Receiver),
    Next = lists:map(fun(X) -> {X, Receiver#(X+1)} end, lists:seq(0, N-1)),
    DP = lists:duplicate(N, undefined),
    CalcFun = fun CalcFun(X, 0, _) -> X;
                  CalcFun(X, K, DP) ->
                      case lists:nth(X+1, DP) of
                          undefined ->
                              {_, NextX} = lists:keyfind(X, 1, Next),
                              NewSum = CalcFun(NextX, K-1, DP) + X,
                              DP2 = lists:sublist(DP, X) ++ [NewSum|lists:nthtail(X+1, DP)],
                              NewSum;
                          Sum -> Sum + X
                      end
              end,
    MaxFun = lists:max([CalcFun(X, K-1, DP) || X <- lists:seq(0, N-1)]),
    MaxFun."
erlang,compile_error,"Line 23: Char 1: function find_max/7 already defined
%   23| find_max(Items, [], K, _, CurrentProfit, TotalCategories, MaxElegance) ->
%     | ^",../questions/Hard\maximum-elegance-of-a-k-length-subsequence\responses\Erlang\response_erlang_2_failed.json,"-spec find_maximum_elegance(Items :: [[integer()]], K :: integer()) -> integer().
find_maximum_elegance(Items, K) ->
    MaxProfit = lists:foldl(fun([P, _], Acc) -> P + Acc end, 0, Items),
    Categories = lists:usort([C || [_, C] <- Items]),
    find_max(Items, Categories, K, MaxProfit, 0, length(Categories), 0).

find_max(_, _, 0, _, _, _, Elegance) ->
    Elegance;
find_max(Items, Categories, K, MaxProfit, CurrentProfit, TotalCategories, MaxElegance) when K > TotalCategories orelse CurrentProfit + MaxProfit < MaxElegance ->
    MaxElegance;
find_max(Items, [Category | RestCategories], K, MaxProfit, CurrentProfit, TotalCategories, MaxElegance) ->
    {Selected, Rest} = lists:partition(fun([_, C]) -> C == Category end, Items),
    NewMaxProfit = MaxProfit - lists:foldl(fun([P, _], Acc) -> P + Acc end, 0, Selected),
    EleganceWith = case Selected of
        [] -> MaxElegance;
        _ ->
            BestProfit = find_best_profit(Selected, K, 0, 0),
            Elegance = CurrentProfit + BestProfit + (TotalCategories - length(RestCategories)) * (TotalCategories - length(RestCategories)),
            max(Elegance, MaxElegance)
    end,
    find_max(Rest, RestCategories, K, NewMaxProfit, CurrentProfit, TotalCategories - 1, EleganceWith).

find_max(Items, [], K, _, CurrentProfit, TotalCategories, MaxElegance) ->
    EleganceWithout = CurrentProfit + TotalCategories * TotalCategories,
    max(EleganceWithout, MaxElegance).

find_best_profit(_, 0, Profit, MaxProfit) ->
    max(Profit, MaxProfit);
find_best_profit([], _, Profit, MaxProfit) ->
    max(Profit, MaxProfit);
find_best_profit([[P, _] | T], K, CurrentProfit, MaxProfit) when K > 0 ->
    find_best_profit(T, K - 1, CurrentProfit + P, MaxProfit);
find_best_profit([_ | T], K, CurrentProfit, MaxProfit) ->
    find_best_profit(T, K, CurrentProfit, MaxProfit)."
erlang,compile_error,"Line 12: Char 66: variable 'Idx' is unbound
%   12|                               dict:update_append(Key, [lists:nth(Idx, Nums)], Acc)
%     |                                                                  ^",../questions/Hard\maximum-element-sum-of-a-complete-subset-of-indices\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_sum(Nums :: [integer()]) -> integer().
maximum_sum(Nums) ->
    PrimeFactors = lists:map(fun erlang:prime_factors/1, Nums),
    FactorCounts = [lists:foldl(fun(X, Acc) -> dict:update_counter(X, 1, Acc) end, dict:new(), PF) || PF <- PrimeFactors],
    UniqueFactors = lists:foldl(fun(Dict, Acc) -> dict:merge(fun(_K, V1, V2) -> V1 bor V2 end, Dict, Acc) end, dict:new(), FactorCounts),
    Grouped = lists:foldl(fun(Factors, Acc) -> 
                              Key = dict:fold(fun(K, V, Acc1) -> 
                                                  if V rem 2 == 1 -> [K|Acc1]; 
                                                     true -> Acc1 
                                                  end 
                                              end, [], Factors),
                              dict:update_append(Key, [lists:nth(Idx, Nums)], Acc)
                          end, dict:new(), lists:zip(FactorCounts, lists:seq(1, length(Nums)))),
    MaxSum = dict:fold(fun(_K, Vals, Acc) -> 
                           Sum = lists:sum(Vals),
                           if Sum > Acc -> Sum; true -> Acc end
                       end, 0, Grouped),
    MaxSum."
erlang,compile_error,"Line 8: Char 64: syntax error before: 'xor'
%    8|                                                     erlang:max(xor(X, Y), AccInner);
%     |                                                                ^
Line 1: Char 2: spec for undefined function maximum_strong_pair_xor/1
%    1| -spec maximum_strong_pair_xor(Nums :: [integer()]) -> integer().
%     |  ^
Line 30: Char 13: function maximum_strong_pair_xor/1 undefined
%   30|       Ret = maximum_strong_pair_xor(Param_1),
%     |             ^",../questions/Hard\maximum-strong-pair-xor-ii\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_strong_pair_xor(Nums :: [integer()]) -> integer().
maximum_strong_pair_xor(Nums) ->
    Sorted = lists:usort(Nums),
    MaxXor = lists:foldl(fun(X, Acc) -> 
                            lists:foldl(fun(Y, AccInner) -> 
                                            if 
                                                abs(X - Y) =< min(X, Y) -> 
                                                    erlang:max(xor(X, Y), AccInner);
                                                true -> 
                                                    AccInner
                                            end
                                        end, Acc, Sorted)
                        end, 0, Sorted),
    MaxXor."
erlang,compile_error,"Line 25: Char 1: syntax error before: SemiPalindromeCost
%   25| SemiPalindromeCost(_, 0) -> 0;
%     | ^
Line 23: Char 5: variable 'SemiPalindromeCost' is unbound
%   23|     SemiPalindromeCost(SubStr, (J - I) div 2).
%     |     ^",../questions/Hard\minimum-changes-to-make-k-semi-palindromes\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_changes(S :: unicode:unicode_binary(), K :: integer()) -> integer().
minimum_changes(S, K) ->
    Str = unicode:characters_to_list(S),
    Len = length(Str),
    DP = lists:foldl(fun(_, Acc) -> [lists:duplicate(Len + 1, infinity) | Acc] end, [], lists:seq(0, K)),
    DP1 = lists:keystore(1, 1, DP, 1, 1, lists:duplicate(Len + 1, 0)),
    MinChanges = calculate_min_changes(Str, DP1, K, Len),
    hd(hd(lists:nth(K + 1, MinChanges))).

calculate_min_changes(_, DP, 0, 0) -> DP;
calculate_min_changes(Str, DP, K, Len) when K >= 1, Len >= 1 ->
    NewDP = lists:map(fun(KthList) -> calculate_kth(Str, DP, KthList, K, Len) end, lists:seq(1, K + 1)),
    calculate_min_changes(Str, NewDP, K, Len - 1).

calculate_kth(_, _, KthList, _, Len) when Len < 1 -> KthList;
calculate_kth(Str, DP, KthList, K, Len) ->
    Costs = [calculate_cost(Str, I, Len) + lists:nth(I + 1, hd(lists:nth(K, DP))) || I <- lists:seq(0, Len - 1)],
    MinCost = lists:min(Costs),
    lists:update_nth(Len + 1, fun(_) -> MinCost end, KthList).

calculate_cost(Str, I, J) ->
    SubStr = lists:sublist(Str, I + 1, J - I),
    SemiPalindromeCost(SubStr, (J - I) div 2).

SemiPalindromeCost(_, 0) -> 0;
SemiPalindromeCost(Str, Mid) ->
    {Left, Right} = lists:split(Mid, Str),
    RightRev = lists:reverse(Right),
    lists:foldl(fun({L, R}, Acc) when L =/= R -> Acc + 1; (_, Acc) -> Acc end, 0, lists:zip(Left, RightRev))."
erlang,compile_error,"Line 23: Char 9: illegal guard expression
%   23|         lists:nth(L, Str) == lists:nth(R, Str) ->
%     |         ^
Line 23: Char 30: illegal guard expression
%   23|         lists:nth(L, Str) == lists:nth(R, Str) ->
%     |                              ^",../questions/Hard\minimum-changes-to-make-k-semi-palindromes\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_changes(S :: unicode:unicode_binary(), K :: integer()) -> integer().
minimum_changes(S, K) ->
    Str = unicode:characters_to_list(S),
    {DP, _} = lists:foldl(fun(E, {Acc, Idx}) -> 
                            {[lists:update_nth(Idx, Acc, 0) | Acc], Idx + 1} 
                          end, 
                          {lists:duplicate(length(Str) + 1, infinity), 1}, 
                          lists:seq(1, K)),
    lists:foldl(fun(_, Acc) -> lists:map(fun(Row) -> 
                                           [calculate_cost(Str, 1, length(Str), K, Row, 1) | Row] 
                                         end, Acc) 
                end, 
                DP, lists:seq(1, length(Str))).

calculate_cost(Str, L, R, K, DP, CurrK) when L > R; K < CurrK -> hd(DP);
calculate_cost(Str, L, R, K, [H|T], CurrK) ->
    Min = lists:min([H + semi_palindrome_cost(Str, L, I - 1) || I <- lists:seq(L, R)]),
    [Min | calculate_cost(Str, L + 1, R, K, T, CurrK + 1)].

semi_palindrome_cost(Str, L, R) when L >= R -> 0;
semi_palindrome_cost(Str, L, R) ->
    if
        lists:nth(L, Str) == lists:nth(R, Str) -> 
            semi_palindrome_cost(Str, L + 1, R - 1);
        true -> 
            1 + semi_palindrome_cost(Str, L + 1, R - 1)
    end."
erlang,compile_error,"Line 51: Char 18: syntax error before: '.'
%   51|             error.
%     |                  ^
Line 39: Char 5: function replace_substring_helper/5 undefined
%   39|     replace_substring_helper(SourceList, OrigList, ChangedList, Cost, TargetList).
%     |     ^",../questions/Hard\minimum-cost-to-convert-string-ii\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [unicode:unicode_binary()], Changed :: [unicode:unicode_binary()], Cost :: [integer()]) -> integer().
minimum_cost(Source, Target, Original, Changed, Cost) ->
    Ops = lists:zip(Original, lists:zip(Changed, Cost)),
    MinCost = find_min_cost(Source, Target, Ops, 0),
    case MinCost of
        infinity -> -1;
        _ -> MinCost
    end.

find_min_cost(Source, Target, Ops, AccumulatedCost) when Source == Target ->
    AccumulatedCost;
find_min_cost(_, _, [], _) ->
    infinity;
find_min_cost(Source, Target, Ops, AccumulatedCost) ->
    MinOpCosts = lists:foldl(
        fun({Orig, {Changed, Cost}}, Acc) ->
            case replace_substring(Source, Orig, Changed, Cost, Target) of
                {ok, NewSource, NewCost} ->
                    [{NewSource, AccumulatedCost + NewCost} | Acc];
                error ->
                    Acc
            end
        end, [], Ops),
    case MinOpCosts of
        [] -> infinity;
        _ ->
            lists:foldl(
                fun({NewSource, NewCost}, Acc) ->
                    case find_min_cost(NewSource, Target, Ops, NewCost) of
                        infinity -> Acc;
                        Cost when Cost < Acc; Acc == infinity -> Cost;
                        _ -> Acc
                    end
                end, infinity, MinOpCosts)
    end.

replace_substring(Source, Orig, Changed, Cost, Target) ->
    {SourceList, TargetList, OrigList, ChangedList} = {binary_to_list(Source), binary_to_list(Target), binary_to_list(Orig), binary_to_list(Changed)},
    replace_substring_helper(SourceList, OrigList, ChangedList, Cost, TargetList).

replace_substring_helper(Source, Orig, Changed, Cost, Target) ->
    case lists:prefix(Orig, Source) of
        true ->
            NewSource = Changed ++ lists:nthtail(length(Orig), Source),
            if binary_to_list(list_to_binary(NewSource)) -- Target == [] ->
                {ok, list_to_binary(NewSource), Cost};
               true ->
                error
            end;
        false ->
            error."
erlang,compile_error,"Line 47: Char 107: syntax error before: '.'
%   47|         error -> if Source == [] -> error; true -> find_min_operation(tl(Source), [T|TargetRest], Ops) end.
%     |                                                                                                           ^
Line 14: Char 10: function find_min_operation/3 undefined
%   14|     case find_min_operation(Source, Target, Ops) of
%     |          ^",../questions/Hard\minimum-cost-to-convert-string-ii\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [unicode:unicode_binary()], Changed :: [unicode:unicode_binary()], Cost :: [integer()]) -> integer().
minimum_cost(Source, Target, Original, Changed, Cost) ->
    {SourceList, TargetList} = {binary_to_list(Source), binary_to_list(Target)},
    Ops = lists:zip3(Original, Changed, Cost),
    MinCost = find_min_cost(SourceList, TargetList, Ops, 0),
    case MinCost of
        infinity -> -1;
        _ -> MinCost
    end.

find_min_cost(_, [], _, Cost) ->
    Cost;
find_min_cost(Source, Target, Ops, AccumulatedCost) ->
    case find_min_operation(Source, Target, Ops) of
        {ok, {Cost, SourceAfterOp, TargetAfterOp}} ->
            find_min_cost(SourceAfterOp, TargetAfterOp, Ops, AccumulatedCost + Cost);
        error ->
            infinity
    end.

find_min_operation(Source, [T|TargetRest], Ops) ->
    MinOp = lists:foldl(
        fun({Orig, Changed, Cost}, Acc) ->
            OrigList = binary_to_list(Orig),
            ChangedList = binary_to_list(Changed),
            case {lists:prefix(OrigList, Source), lists:prefix(ChangedList, [T|TargetRest])} of
                {true, true} ->
                    SourceAfterOp = lists:nthtail(length(OrigList), Source),
                    TargetAfterOp = lists:nthtail(length(ChangedList), [T|TargetRest]),
                    case Acc of
                        {ok, {AccCost, _, _}} when Cost < AccCost ->
                            {ok, {Cost, SourceAfterOp, TargetAfterOp}};
                        {ok, _} ->
                            Acc;
                        error ->
                            {ok, {Cost, SourceAfterOp, TargetAfterOp}}
                    end;
                _ ->
                    Acc
            end
        end,
        error,
        Ops
    ),
    case MinOp of
        {ok, _} = Op -> Op;
        error -> if Source == [] -> error; true -> find_min_operation(tl(Source), [T|TargetRest], Ops) end."
erlang,compile_error,"Line 34: Char 16: syntax error before: '.'
%   34|             end.
%     |                ^
Line 4: Char 5: function min_operations/3 undefined
%    4|     min_operations(Counts, Target, 0).
%     |     ^",../questions/Hard\minimum-operations-to-form-subsequence-with-target-sum\responses\Erlang\response_erlang_2_failed.json,"-spec min_operations(Nums :: [integer()], Target :: integer()) -> integer().
min_operations(Nums, Target) ->
    Counts = lists:foldl(fun(X, Acc) -> maps:update_with(X, fun(V) -> V + 1 end, 1, Acc) end, #{}, Nums),
    min_operations(Counts, Target, 0).

min_operations(_, 0, Ops) ->
    Ops;
min_operations(Counts, Target, Ops) when Target rem 2 == 1 ->
    case maps:find(1, Counts) of
        {ok, C} when C > 0 ->
            min_operations(maps:update(1, C - 1, Counts), Target - 1, Ops);
        _ ->
            -1
    end;
min_operations(Counts, Target, Ops) ->
    Power = trunc(math:log2(Target)),
    case maps:find(1 bsl Power, Counts) of
        {ok, C} when C > 0 ->
            min_operations(maps:update(1 bsl Power, C - 1, Counts), Target - (1 bsl Power), Ops);
        _ ->
            NextTarget = Target bsr 1,
            NewCounts = case maps:find(1 bsl (Power + 1), Counts) of
                {ok, C} when C > 0 ->
                    Counts1 = maps:update(1 bsl (Power + 1), C - 1, Counts),
                    maps:update_with(1 bsl Power, fun(V) -> V + 2 end, 2, Counts1);
                _ ->
                    Counts
            end,
            if
                NewCounts == Counts ->
                    -1;
                true ->
                    min_operations(NewCounts, NextTarget, Ops + 1)
            end."
erlang,compile_error,"Line 5: Char 1: syntax error before: CountBeautifulIntegers
%    5| CountBeautifulIntegers(Current, High, K, Count) when Current =< High ->
%     | ^
Line 3: Char 5: variable 'CountBeautifulIntegers' is unbound
%    3|     CountBeautifulIntegers(Low, High, K, 0).
%     |     ^
Line 20: Char 22: ambiguous call of overridden pre R14 auto-imported BIF integer_to_list/1
 - use erlang:integer_to_list/1 or ""-compile({no_auto_import,[integer_to_list/1]})."" to resolve name clash
%   20|             Digits = integer_to_list(Number),
%     |                      ^",../questions/Hard\number-of-beautiful-integers-in-the-range\responses\Erlang\response_erlang_1_failed.json,"-spec number_of_beautiful_integers(Low :: integer(), High :: integer(), K :: integer()) -> integer().
number_of_beautiful_integers(Low, High, K) ->
    CountBeautifulIntegers(Low, High, K, 0).

CountBeautifulIntegers(Current, High, K, Count) when Current =< High ->
    if
        is_beautiful(Current, K) ->
            CountBeautifulIntegers(Current + 1, High, K, Count + 1);
        true ->
            CountBeautifulIntegers(Current + 1, High, K, Count)
    end;
CountBeautifulIntegers(_, _, _, Count) ->
    Count.

is_beautiful(Number, K) ->
    if
        Number rem K =/= 0 ->
            false;
        true ->
            Digits = integer_to_list(Number),
            Even = length([D || D <- Digits, D rem 2 == 0]),
            Odd = length(Digits) - Even,
            Even == Odd
    end.

integer_to_list(Number) ->
    integer_to_list(Number, []).

integer_to_list(0, Acc) ->
    Acc;
integer_to_list(Number, Acc) when Number > 0 ->
    integer_to_list(Number div 10, [(Number rem 10) | Acc])."
erlang,compile_error,"Line 7: Char 9: call to local/imported function is_beautiful/2 is illegal in guard
%    7|         is_beautiful(Current, K) ->
%     |         ^",../questions/Hard\number-of-beautiful-integers-in-the-range\responses\Erlang\response_erlang_2_failed.json,"-spec number_of_beautiful_integers(Low :: integer(), High :: integer(), K :: integer()) -> integer().
number_of_beautiful_integers(Low, High, K) ->
    count_beautiful(Low, High, K, 0).

count_beautiful(Current, High, K, Count) when Current =< High ->
    if
        is_beautiful(Current, K) ->
            count_beautiful(Current + 1, High, K, Count + 1);
        true ->
            count_beautiful(Current + 1, High, K, Count)
    end;
count_beautiful(_, _, _, Count) ->
    Count.

is_beautiful(Number, K) ->
    if
        Number rem K =/= 0 ->
            false;
        true ->
            Digits = integer_to_list_custom(Number),
            Even = length([D || D <- Digits, D rem 2 == 0]),
            Odd = length(Digits) - Even,
            Even == Odd
    end.

integer_to_list_custom(Number) ->
    integer_to_list_custom(Number, []).

integer_to_list_custom(0, Acc) when Acc =/= [] ->
    Acc;
integer_to_list_custom(Number, Acc) ->
    integer_to_list_custom(Number div 10, [Number rem 10 | Acc])."
erlang,compile_error,"Line 11: Char 1: syntax error before: PaidPainterCost
%   11| PaidPainterCost([], _, AccCost) -> AccCost;
%     | ^
Line 9: Char 5: variable 'PaidPainterCost' is unbound
%    9|     PaidPainterCost(Sorted, FreePainterTime, 0).
%     |     ^",../questions/Hard\painting-the-walls\responses\Erlang\response_erlang_2_failed.json,"-spec paint_walls(Cost :: [integer()], Time :: [integer()]) -> integer().
paint_walls(Cost, Time) ->
    Pairs = lists:zip(Cost, Time),
    Sorted = lists:sort(fun({Cost1, Time1}, {Cost2, Time2}) ->
                            Time1 < Time2 or (Time1 == Time2 andalso Cost1 > Cost2)
                        end, Pairs),
    TotalTime = lists:foldl(fun({_, T}, Acc) -> Acc + T end, 0, Sorted),
    FreePainterTime = TotalTime div 2,
    PaidPainterCost(Sorted, FreePainterTime, 0).

PaidPainterCost([], _, AccCost) -> AccCost;
PaidPainterCost([{Cost, Time} | Rest], FreeTimeLeft, AccCost) when FreeTimeLeft >= Time ->
    PaidPainterCost(Rest, FreeTimeLeft - Time, AccCost);
PaidPainterCost([{Cost, _Time} | Rest], FreeTimeLeft, AccCost) when FreeTimeLeft < Time ->
    PaidPainterCost(Rest, FreeTimeLeft, AccCost + Cost)."
erlang,compile_error,"Line 18: Char 1: syntax error before: CanFormPalindrome
%   18| CanFormPalindrome(LeftFreq, RightFreq, TotalFreq) ->
%     | ^
Line 9: Char 19: variable 'CanFormPalindrome' is unbound
%    9|                   CanFormPalindrome(LeftFreq, RightFreq, Frequencies)
%     |                   ^",../questions/Hard\palindrome-rearrangement-queries\responses\Erlang\response_erlang_0_failed.json,"-spec can_make_palindrome_queries(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [boolean()].
can_make_palindrome_queries(S, Queries) ->
    Frequencies = lists:foldl(fun(Char, Acc) ->
                                  maps:update_with(Char, fun(Count) -> Count + 1 end, 1, Acc)
                              end, #{}, binary:bin_to_list(S)),
    lists:map(fun([Ai, Bi, Ci, Di]) ->
                  LeftFreq = substring_frequency(Ai, Bi, S),
                  RightFreq = substring_frequency(Ci, Di, S),
                  CanFormPalindrome(LeftFreq, RightFreq, Frequencies)
              end, Queries).

substring_frequency(A, B, S) ->
    Substring = binary:part(S, {A, B - A + 1}),
    lists:foldl(fun(Char, Acc) ->
                    maps:update_with(Char, fun(Count) -> Count + 1 end, 1, Acc)
                end, #{}, binary:bin_to_list(Substring)).

CanFormPalindrome(LeftFreq, RightFreq, TotalFreq) ->
    %% Calculate the frequency difference between left and right substrings and the rest of the string
    DeltaFreq = maps:fold(fun(Char, Count, Acc) ->
                              LCount = maps:get(Char, LeftFreq, 0),
                              RCount = maps:get(Char, RightFreq, 0),
                              TCount = maps:get(Char, TotalFreq),
                              NewCount = abs(TCount - LCount - RCount),
                              Acc#{Char => NewCount}
                          end, #{}, TotalFreq),
    %% Count how many characters have odd frequencies in the delta frequency map
    OddCount = maps:fold(fun(_, Count, Acc) when Count rem 2 == 1 -> Acc + 1;
                             (_, _, Acc) -> Acc
                         end, 0, DeltaFreq),
    %% It's possible to form a palindrome if the odd count is less than or equal to 2
    OddCount =< 2."
erlang,compile_error,"Line 8: Char 42: syntax error before: oralso
%    8|                   QueryResult rem 2 == 0 oralso QueryResult == 1
%     |                                          ^
Line 1: Char 2: spec for undefined function can_make_palindrome_queries/2
%    1| -spec can_make_palindrome_queries(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [boolean()].
%     |  ^
Line 53: Char 13: function can_make_palindrome_queries/2 undefined
%   53|       Ret = can_make_palindrome_queries(Param_1, Param_2),
%     |             ^",../questions/Hard\palindrome-rearrangement-queries\responses\Erlang\response_erlang_2_failed.json,"-spec can_make_palindrome_queries(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [boolean()].
can_make_palindrome_queries(S, Queries) ->
    SList = binary:bin_to_list(S),
    Len = length(SList) div 2,
    PrefixSum = prefix_sum(SList, Len),
    lists:map(fun([Ai, Bi, Ci, Di]) -> 
                  QueryResult = query_result(PrefixSum, Ai, Bi, Ci - Len, Di - Len),
                  QueryResult rem 2 == 0 oralso QueryResult == 1
              end, Queries).

prefix_sum(SList, Len) ->
    Freq = lists:foldl(fun(Char, Acc) ->
                           maps:update_with(Char, fun(C) -> C + 1 end, 1, Acc)
                       end, #{}, lists:sublist(SList, Len)),
    lists:foldl(fun(Char, [H|T]) -> 
                    Updated = maps:update_with(Char, fun(C) -> C - 1 end, -1, H),
                    [Updated | [H|T]]
                end, [Freq], lists:reverse(lists:nthtail(Len, SList))).

query_result(PrefixSum, Ai, Bi, Ci, Di) ->
    Left = maps:fold(fun(Char, Count, Acc) -> 
                         if Count > 0 -> Acc + Count; true -> Acc end 
                     end, 0, lists:nth(Ai + 1, PrefixSum)),
    Right = maps:fold(fun(Char, Count, Acc) -> 
                          if Count > 0 -> Acc + Count; true -> Acc end 
                      end, 0, lists:nth(Ci + 1, PrefixSum)),
    Middle = if Bi < Ci -> 
                 maps:fold(fun(Char, Count, Acc) -> 
                               Delta = maps:get(Char, lists:nth(Di + 1, PrefixSum), 0) - maps:get(Char, lists:nth(Bi + 1, PrefixSum), 0),
                               if Delta > 0 -> Acc + Delta; true -> Acc end 
                           end, 0, lists:nth(Ci, PrefixSum));
             true -> 
                 0 
             end,
    Left + Right - Middle."
erlang,compile_error,"Line 9: Char 9: call to local/imported function is_rotation/2 is illegal in guard
%    9|         is_rotation(S, T) andalso K >= 1 ->
%     |         ^",../questions/Hard\string-transformation\responses\Erlang\response_erlang_2_failed.json,"-spec number_of_ways(S :: unicode:unicode_binary(), T :: unicode:unicode_binary(), K :: integer()) -> integer().
number_of_ways(S, T, K) ->
    Mod = 1000000007,
    if
        S == T andalso K rem 2 == 0 ->
            (pow(2, K, Mod) - 2) rem Mod;
        S == T andalso K rem 2 == 1 ->
            2;
        is_rotation(S, T) andalso K >= 1 ->
            if
                K rem 2 == 1 ->
                    2;
                true ->
                    (pow(2, K - 1, Mod) - 2) rem Mod
            end;
        true ->
            0
    end.

is_rotation(S, T) ->
    ST = S ++ S,
    lists:substring(ST, 1, byte_size(S) * 2) =:= T ++ T.

pow(_, 0, _) -> 1;
pow(Base, Exp, Mod) ->
    case Exp rem 2 of
        0 ->
            Half = pow(Base, Exp div 2, Mod),
            (Half * Half) rem Mod;
        1 ->
            (Base * pow(Base, Exp - 1, Mod)) rem Mod
    end."
erlang,compile_error,"Line 17: Char 51: syntax error before: '|'
%   17|                 end, {hd(Sorted), 0}, tl(Sorted)) |> element(2).
%     |                                                   ^
Line 6: Char 38: function imbalance_window/2 undefined
%    6|     lists:foldl(fun(_, Acc) -> Acc + imbalance_window(Size, Nums) end, 0, lists:seq(1, length(Nums) - Size + 1)),
%     |                                      ^",../questions/Hard\sum-of-imbalance-numbers-of-all-subarrays\responses\Erlang\response_erlang_0_failed.json,"-spec sum_imbalance_numbers(Nums :: [integer()]) -> integer().
sum_imbalance_numbers(Nums) ->
    lists:foldl(fun(X, Acc) -> Acc + count_imbalance(X, Nums) end, 0, lists:seq(1, length(Nums))).

count_imbalance(Size, Nums) ->
    lists:foldl(fun(_, Acc) -> Acc + imbalance_window(Size, Nums) end, 0, lists:seq(1, length(Nums) - Size + 1)),
    lists:sublist(Nums, Size + 1, length(Nums) - Size).

imbalance_window(Size, Nums) ->
    {Sublist, _Rest} = lists:split(Size, Nums),
    Sorted = lists:usort(Sublist),
    lists:foldl(fun(X, {Prev, Count}) -> 
                    if 
                        X - Prev > 1 -> {X, Count + 1}; 
                        true -> {X, Count} 
                    end 
                end, {hd(Sorted), 0}, tl(Sorted)) |> element(2)."
erlang,compile_error,"Line 36: Char 5: function snd/1 undefined
%   36|     snd(Imbalance).
%     |     ^",../questions/Hard\sum-of-imbalance-numbers-of-all-subarrays\responses\Erlang\response_erlang_2_failed.json,"-spec sum_imbalance_numbers(Nums :: [integer()]) -> integer().
sum_imbalance_numbers(Nums) ->
    sum_imbalance_numbers(Nums, maps:new(), 1, length(Nums), 0).

sum_imbalance_numbers(_Nums, _Map, _Start, 0, Acc) ->
    Acc;
sum_imbalance_numbers(Nums, Map, Start, Length, Acc) ->
    {SubList, NewMap} = get_sublist(Nums, Map, Start, Length),
    Imbalance = calculate_imbalance(SubList, NewMap),
    NextAcc = Acc + Imbalance,
    if Start + Length > length(Nums) ->
        sum_imbalance_numbers(Nums, Map, 1, Length - 1, NextAcc);
    true ->
        sum_imbalance_numbers(Nums, Map, Start + 1, Length, NextAcc)
    end.

get_sublist(Nums, Map, Start, Length) ->
    case maps:find({Start, Length}, Map) of
        {ok, SubList} ->
            {SubList, Map};
        error ->
            SubList = lists:sublist(Nums, Start, Length),
            {SubList, maps:put({Start, Length}, SubList, Map)}
    end.

calculate_imbalance(SubList, Map) ->
    Sorted = lists:usort(SubList),
    Imbalance = lists:foldl(fun(X, {Prev, Acc}) ->
                                if
                                    X - Prev > 1 ->
                                        {X, Acc + 1};
                                    true ->
                                        {X, Acc}
                                end
                            end, {hd(Sorted) - 1, 0}, Sorted),
    snd(Imbalance)."
erlang,compile_error,"Line 15: Char 55: syntax error before: '=='
%   15|                 (lists:sum(Left) >= M or length(Left) == 1) andalso
%     |                                                       ^
Line 1: Char 2: spec for undefined function can_split_array/2
%    1| -spec can_split_array(Nums :: [integer()], M :: integer()) -> boolean().
%     |  ^
Line 38: Char 13: function can_split_array/2 undefined
%   38|       Ret = can_split_array(Param_1, Param_2),
%     |             ^",../questions/Medium\check-if-it-is-possible-to-split-array\responses\Erlang\response_erlang_1_failed.json,"-spec can_split_array(Nums :: [integer()], M :: integer()) -> boolean().
can_split_array(Nums, M) ->
    % Helper function to check if we can form a valid split with sums >= M
    % Operates by attempting to split the array at every possible position
    % and checking if both resulting subarrays satisfy the conditions.
    CheckSplit = fun
        (_Check, [], _M) ->
            false; % Cannot split an empty array
        (_Check, [_], _M) ->
            true; % A single element array is always a valid split
        (Check, Lst, M) when length(Lst) > 1 ->
            % Try splitting the list at each possible index and check both parts
            lists:any(fun(I) ->
                {Left, Right} = lists:split(I, Lst),
                (lists:sum(Left) >= M or length(Left) == 1) andalso
                (lists:sum(Right) >= M or length(Right) == 1) andalso
                Check(Check, Left, M) andalso Check(Check, Right, M)
            end, lists:seq(1, length(Lst) - 1))
    end,
    CheckSplit(CheckSplit, Nums, M)."
erlang,compile_error,"Line 12: Char 41: illegal guard expression
%   12|                 RowIndex =< length(Grid -- [lists:nth(RowIndex, Grid)]) ->
%     |                                         ^
Line 12: Char 45: illegal guard expression
%   12|                 RowIndex =< length(Grid -- [lists:nth(RowIndex, Grid)]) ->
%     |                                             ^",../questions/Medium\construct-product-matrix\responses\Erlang\response_erlang_2_failed.json,"-spec construct_product_matrix(Grid :: [[integer()]]) -> [[integer()]].
construct_product_matrix(Grid) ->
    Rows = length(Grid),
    Cols = length(hd(Grid)),
    lists:map(fun(RowIndex) ->
        lists:map(fun(ColIndex) ->
            Product = lists:foldl(fun(Row, Acc) ->
                Elem = lists:nth(ColIndex, Row),
                (Acc * Elem) rem 12345
            end, 1, Grid -- [lists:nth(RowIndex, Grid)]),
            if
                RowIndex =< length(Grid -- [lists:nth(RowIndex, Grid)]) ->
                    lists:foldl(fun(X, Acc) -> (Acc * X) rem 12345 end, Product, tl(lists:nth(RowIndex, Grid)));
                true -> Product
            end
        end, lists:seq(1, Cols))
    end, lists:seq(1, Rows))."
erlang,compile_error,"Line 9: Char 16: illegal guard expression
%    9|             if lists:member(Char, Vowels) -> {Vow + 1, Con};
%     |                ^",../questions/Medium\count-beautiful-substrings-i\responses\Erlang\response_erlang_0_failed.json,"-spec beautiful_substrings(S :: unicode:unicode_binary(), K :: integer()) -> integer().
beautiful_substrings(S, K) ->
    Vowels = ""aeiou"",
    Len = byte_size(S),
    Substrs = [binary:part(S, Start, Length) || Start <- lists:seq(0, Len - 1),
                                                Length <- lists:seq(1, Len - Start)],
    BeautifulSubstrs = lists:filter(fun(Substr) ->
        {V, C} = lists:foldl(fun(Char, {Vow, Con}) ->
            if lists:member(Char, Vowels) -> {Vow + 1, Con};
               true -> {Vow, Con + 1}
            end
        end, {0, 0}, binary_to_list(Substr)),
        V =:= C andalso (V * C) rem K =:= 0
    end, Substrs),
    length(BeautifulSubstrs)."
erlang,compile_error,"Line 9: Char 16: illegal guard expression
%    9|             if lists:member(Char, Vowels) -> {Vow + 1, Con};
%     |                ^",../questions/Medium\count-beautiful-substrings-i\responses\Erlang\response_erlang_1_failed.json,"-spec beautiful_substrings(S :: unicode:unicode_binary(), K :: integer()) -> integer().
beautiful_substrings(S, K) ->
    Vowels = ""aeiou"",
    Len = byte_size(S),
    Substrs = [binary:part(S, Start, Length) || Start <- lists:seq(0, Len - 1),
                                                Length <- lists:seq(1, Len - Start)],
    BeautifulSubstrs = lists:foldl(fun(Substr, Acc) ->
        {V, C} = lists:foldl(fun(Char, {Vow, Con}) ->
            if lists:member(Char, Vowels) -> {Vow + 1, Con};
               true -> {Vow, Con + 1}
            end
        end, {0, 0}, binary_to_list(Substr)),
        if V =:= C andalso (V * C) rem K =:= 0 -> Acc + 1;
           true -> Acc
        end
    end, 0, Substrs),
    BeautifulSubstrs."
erlang,compile_error,"Line 10: Char 19: illegal guard expression
%   10|     NewCount = if maps:size(UpdatedMap) == DistinctCount -> Count + CurrentLength + 1; true -> Count end,
%     |                   ^",../questions/Medium\count-complete-subarrays-in-an-array\responses\Erlang\response_erlang_0_failed.json,"-spec count_complete_subarrays(Nums :: [integer()]) -> integer().
count_complete_subarrays(Nums) ->
    DistinctCount = length(lists:usort(Nums)),
    count_complete_subarrays(Nums, DistinctCount, 0, {0, maps:new()}).

count_complete_subarrays([], _, Count, _) ->
    Count;
count_complete_subarrays([H|T], DistinctCount, Count, {CurrentLength, CurrentMap}) ->
    UpdatedMap = maps:update_with(H, fun(Val) -> Val + 1 end, 1, CurrentMap),
    NewCount = if maps:size(UpdatedMap) == DistinctCount -> Count + CurrentLength + 1; true -> Count end,
    {NewLength, PrunedMap} = prune_map(T, UpdatedMap, DistinctCount, CurrentLength + 1),
    count_complete_subarrays(T, DistinctCount, NewCount, {NewLength, PrunedMap}).

prune_map(Nums, Map, DistinctCount, Length) ->
    case maps:size(Map) == DistinctCount of
        true ->
            {Key, 1} = maps:find(min_value(Map), Map),
            {Length - 1, maps:remove(Key, Map)};
        false ->
            {Length, Map}
    end.

min_value(Map) ->
    MinValue = lists:min(maps:values(Map)),
    lists:keyfind(MinValue, 2, maps:to_list(Map))."
erlang,compile_error,"Line 21: Char 9: syntax error before: 'after'
%   21|     end after
%     |         ^
Line 9: Char 5: function count_sub/8 undefined
%    9|     count_sub(Nums, Unique, Map, Acc, Start, Start, Len, 0).
%     |     ^",../questions/Medium\count-complete-subarrays-in-an-array\responses\Erlang\response_erlang_2_failed.json,"-spec count_complete_subarrays(Nums :: [integer()]) -> integer().
count_complete_subarrays(Nums) ->
    Unique = length(lists:usort(Nums)),
    count(Nums, Unique, maps:new(), 0, 1, length(Nums)).

count(_, _, _, Acc, Start, Len) when Start > Len ->
    Acc;
count(Nums, Unique, Map, Acc, Start, Len) ->
    count_sub(Nums, Unique, Map, Acc, Start, Start, Len, 0).

count_sub(_, _, _, Acc, _, _, Len, SubAcc) when SubAcc > Len ->
    Acc;
count_sub(Nums, Unique, Map, Acc, Start, End, Len, SubAcc) ->
    {NewMap, NewUnique} = update_map(maps:get(element(End, Nums), Map, 0), Map, element(End, Nums)),
    if
        NewUnique =:= Unique ->
            NextAcc = Acc + 1,
            count_sub(Nums, Unique, NewMap, NextAcc, Start, End + 1, Len, SubAcc + 1);
        true ->
            count_sub(Nums, Unique, NewMap, Acc, Start, End + 1, Len, SubAcc + 1)
    end after
    if
        End - Start + 1 =:= Len ->
            count(Nums, Unique, maps:new(), Acc, Start + 1, Len);
        true ->
            ok
    end.

update_map(Count, Map, Key) ->
    case Count of
        0 ->
            {maps:put(Key, 1, Map), 1};
        _ ->
            {Map, 0}
    end."
erlang,compile_error,"Line 18: Char 61: variable 'Idxs' is unbound
%   18|                                     _ -> lists:nth(Pos - 1, Idxs)
%     |                                                             ^
Line 20: Char 80: variable 'Idxs' is unbound
%   20|                                             X when X =< Length -> lists:nth(X, Idxs);
%     |                                                                                ^
Line 21: Char 61: variable 'Idxs' is unbound
%   21|                                             _ -> lists:last(Idxs) + 1
%     |                                                             ^",../questions/Medium\count-subarrays-where-max-element-appears-at-least-k-times\responses\Erlang\response_erlang_1_failed.json,"-spec count_subarrays(Nums :: [integer()], K :: integer()) -> integer().
count_subarrays(Nums, K) ->
    Max = lists:max(Nums),
    Idxs = [Idx || {N, Idx} <- lists:zip(Nums, lists:seq(1, length(Nums))), N == Max],
    count_valid_subarrays(Idxs, K).

count_valid_subarrays(Idxs, K) ->
    count_valid_subarrays(Idxs, K, 0, length(Idxs)).

count_valid_subarrays(_Idxs, K, Count, Length) when K > Length ->
    Count;
count_valid_subarrays(Idxs, K, Count, Length) ->
    count_valid_subarrays(Idxs, K, 1 + Count, Length, 1).

count_valid_subarrays([H|T], K, Count, Length, Pos) when Pos =< Length - K + 1 ->
    NextCount = Count + (H - (case Pos of
                                    1 -> 0;
                                    _ -> lists:nth(Pos - 1, Idxs)
                                end)) * ((case Pos + K - 1 of
                                            X when X =< Length -> lists:nth(X, Idxs);
                                            _ -> lists:last(Idxs) + 1
                                        end) - H),
    count_valid_subarrays(T, K, NextCount, Length, Pos + 1);
count_valid_subarrays(_, _, Count, _, _) ->
    Count."
erlang,compile_error,"Line 15: Char 40: variable 'Idxs' is unbound
%   15|                _ -> lists:nth(Pos - 1, Idxs) + 1
%     |                                        ^
Line 18: Char 51: variable 'Idxs' unsafe in 'case' (line 17, column 12)
%   18|                X when X =< Length -> lists:nth(X, Idxs);
%     |                                                   ^
Line 19: Char 28: variable 'Idxs' unsafe in 'case' (line 17, column 12)
%   19|                _ -> length(Idxs)
%     |                            ^",../questions/Medium\count-subarrays-where-max-element-appears-at-least-k-times\responses\Erlang\response_erlang_2_failed.json,"-spec count_subarrays(Nums :: [integer()], K :: integer()) -> integer().
count_subarrays(Nums, K) ->
    Max = lists:max(Nums),
    Idxs = [Idx || {N, Idx} <- lists:zip(Nums, lists:seq(1, length(Nums))), N == Max],
    count_subarrays(Idxs, K, 0, length(Idxs), Max).

count_subarrays(_, K, Count, Length, _) when K > Length ->
    Count;
count_subarrays(Idxs, K, Count, Length, Max) ->
    count_subarrays(Idxs, K, Count, Length, Max, 1, 0).

count_subarrays([H|T], K, Count, Length, Max, Pos, Acc) when Pos =< Length - K + 1 ->
    Prev = case Pos of
               1 -> 1;
               _ -> lists:nth(Pos - 1, Idxs) + 1
           end,
    Next = case Pos + K - 1 of
               X when X =< Length -> lists:nth(X, Idxs);
               _ -> length(Idxs)
           end,
    NewAcc = Acc + (H - Prev + 1) * (Next - H + 1),
    count_subarrays(T, K, Count + NewAcc - Acc, Length, Max, Pos + 1, NewAcc);
count_subarrays(_, _, Count, _, _, _, _) ->
    Count."
erlang,compile_error,"Line 11: Char 95: syntax error before: '<='
%   11|                     ActiveDuringQuery = lists:any(fun(Time) -> Time >= Query - X andalso Time <= Query end, Times),
%     |                                                                                               ^
Line 1: Char 2: spec for undefined function count_servers/4
%    1| -spec count_servers(N :: integer(), Logs :: [[integer()]], X :: integer(), Queries :: [integer()]) -> [integer()].
%     |  ^
Line 36: Char 13: function count_servers/4 undefined
%   36|       Ret = count_servers(Param_1, Param_2, Param_3, Param_4),
%     |             ^",../questions/Medium\count-zero-request-servers\responses\Erlang\response_erlang_0_failed.json,"-spec count_servers(N :: integer(), Logs :: [[integer()]], X :: integer(), Queries :: [integer()]) -> [integer()].
count_servers(N, Logs, X, Queries) ->
    ActiveTimes = lists:foldl(
        fun([Server, Time], Acc) ->
            maps:update_with(Server, fun(Times) -> [Time | Times] end, [Time], Acc)
        end, #{}, Logs),
    lists:map(
        fun(Query) ->
            maps:fold(
                fun(Server, Times, Count) ->
                    ActiveDuringQuery = lists:any(fun(Time) -> Time >= Query - X andalso Time <= Query end, Times),
                    if ActiveDuringQuery -> Count; true -> Count + 1 end
                end, 0, ActiveTimes)
        end, Queries)."
erlang,compile_error,"Line 16: Char 75: syntax error before: '>'
%   16|     if LastCharX =:= FirstCharY -> binary:part(X, {0, byte_size(X) - 1}) <> binary:part(Y, {1, byte_size(Y) - 1});
%     |                                                                           ^
Line 5: Char 31: function join/2 undefined
%    5|                       Join1 = join(Prev, H),
%     |                               ^
Line 6: Char 31: function join/2 undefined
%    6|                       Join2 = join(H, Prev),
%     |                               ^",../questions/Medium\decremental-string-concatenation\responses\Erlang\response_erlang_0_failed.json,"-spec minimize_concatenated_length(Words :: [unicode:unicode_binary()]) -> integer().
minimize_concatenated_length(Words) ->
    Minimize = fun Minimize(Prev, [], MinLen) -> MinLen;
                  Minimize(Prev, [H|T], MinLen) ->
                      Join1 = join(Prev, H),
                      Join2 = join(H, Prev),
                      MinLen1 = Minimize(Join1, T, MinLen + byte_size(Join1) - byte_size(Prev)),
                      MinLen2 = Minimize(Join2, T, MinLen + byte_size(Join2) - byte_size(Prev)),
                      min(MinLen1, MinLen2)
               end,
    Minimize(hd(Words), tl(Words), byte_size(hd(Words))).

join(X, Y) ->
    LastCharX = binary:last(X),
    FirstCharY = binary:at(Y, 0),
    if LastCharX =:= FirstCharY -> binary:part(X, {0, byte_size(X) - 1}) <> binary:part(Y, {1, byte_size(Y) - 1});
       true -> X <> Y
    end."
erlang,compile_error,"Line 13: Char 16: syntax error before: 'when'
%   13|     join(X, Y) when is_binary(X), is_binary(Y) ->
%     |                ^
Line 1: Char 2: spec for undefined function minimize_concatenated_length/1
%    1| -spec minimize_concatenated_length(Words :: [unicode:unicode_binary()]) -> integer().
%     |  ^
Line 36: Char 13: function minimize_concatenated_length/1 undefined
%   36|       Ret = minimize_concatenated_length(Param_1),
%     |             ^",../questions/Medium\decremental-string-concatenation\responses\Erlang\response_erlang_1_failed.json,"-spec minimize_concatenated_length(Words :: [unicode:unicode_binary()]) -> integer().
minimize_concatenated_length(Words) ->
    Minimize = fun Minimize(_, [], MinLen) -> MinLen;
                  Minimize(Prev, [H|T], MinLen) ->
                      Join1 = join(Prev, H),
                      Join2 = join(H, Prev),
                      MinLen1 = Minimize(Join1, T, MinLen + byte_size(Join1) - byte_size(Prev)),
                      MinLen2 = Minimize(Join2, T, MinLen + byte_size(Join2) - byte_size(Prev)),
                      min(MinLen1, MinLen2)
               end,
    Minimize(hd(Words), tl(Words), byte_size(hd(Words))),

    join(X, Y) when is_binary(X), is_binary(Y) ->
        LastCharX = binary:last(X),
        FirstCharY = binary:at(Y, 0),
        if LastCharX =:= FirstCharY ->
                binary:part(X, 0, byte_size(X) - 1) <> binary:part(Y, 1, byte_size(Y) - 1);
           true ->
                X <> Y
        end."
erlang,compile_error,"Line 11: Char 5: syntax error before: '|'
%   11|     |> snd()
%     |     ^
Line 16: Char 54: syntax error before: '>'
%   16|         true -> binary:part(X, 0, byte_size(X) - 1) <> binary:part(Y, 1, byte_size(Y) - 1);
%     |                                                      ^
Line 1: Char 2: spec for undefined function minimize_concatenated_length/1
%    1| -spec minimize_concatenated_length([binary()]) -> integer().
%     |  ^
Line 34: Char 13: function minimize_concatenated_length/1 undefined
%   34|       Ret = minimize_concatenated_length(Param_1),
%     |             ^",../questions/Medium\decremental-string-concatenation\responses\Erlang\response_erlang_2_failed.json,"-spec minimize_concatenated_length([binary()]) -> integer().
minimize_concatenated_length(Words) ->
    lists:foldl(fun(Word, {_, Acc}) ->
                        case Acc of
                            [] -> {Word, byte_size(Word)};
                            _ ->
                                [{join(Word, X), byte_size(join(Word, X))} || X <- Acc] ++
                                [{join(X, Word), byte_size(join(X, Word))} || X <- Acc]
                        end
                end, {[], []}, Words)
    |> snd()
    |> lists:min().

join(X, Y) ->
    case binary:last(X) =:= binary:at(Y, 0) of
        true -> binary:part(X, 0, byte_size(X) - 1) <> binary:part(Y, 1, byte_size(Y) - 1);
        false -> X <> Y
    end."
erlang,compile_error,"Line 6: Char 36: syntax error before: '^'
%    6|             Result = (((A*B rem 10)^C) rem M),
%     |                                    ^
Line 1: Char 2: spec for undefined function get_good_indices/2
%    1| -spec get_good_indices(Variables :: [[integer()]], Target :: integer()) -> [integer()].
%     |  ^
Line 30: Char 13: function get_good_indices/2 undefined
%   30|       Ret = get_good_indices(Param_1, Param_2),
%     |             ^",../questions/Medium\double-modular-exponentiation\responses\Erlang\response_erlang_0_failed.json,"-spec get_good_indices(Variables :: [[integer()]], Target :: integer()) -> [integer()].
get_good_indices(Variables, Target) ->
    lists:foldl(
        fun(Var, {Idx, Acc}) ->
            [A, B, C, M] = Var,
            Result = (((A*B rem 10)^C) rem M),
            if
                Result == Target -> {Idx + 1, [Idx | Acc]};
                true -> {Idx + 1, Acc}
            end
        end, {0, []}, Variables)
    |> element(2)."
erlang,compile_error,"Line 14: Char 51: syntax error before: '('
%   14|     Memo = fun(M) -> fun(I) -> maps:get(I, M, F(M)(I, F(M))) end end,
%     |                                                   ^
Line 1: Char 2: spec for undefined function min_extra_char/2
%    1| -spec min_extra_char(S :: unicode:unicode_binary(), Dictionary :: [unicode:unicode_binary()]) -> integer().
%     |  ^
Line 34: Char 13: function min_extra_char/2 undefined
%   34|       Ret = min_extra_char(Param_1, Param_2),
%     |             ^",../questions/Medium\extra-characters-in-a-string\responses\Erlang\response_erlang_0_failed.json,"-spec min_extra_char(S :: unicode:unicode_binary(), Dictionary :: [unicode:unicode_binary()]) -> integer().
min_extra_char(S, Dictionary) ->
    DP = fun DP(0, _) -> 0;
             DP(I, F) ->
                 Min = lists:foldl(fun(D, Acc) ->
                                           case binary:part(S, {I - size(D), size(D)}) of
                                               D -> min(F(I - size(D)), Acc);
                                               _ -> Acc
                                           end
                                   end, I, Dictionary),
                 min(Min, F(I - 1) + 1)
         end,
    Fun = fun(F) -> DP end,
    Memo = fun(M) -> fun(I) -> maps:get(I, M, F(M)(I, F(M))) end end,
    F = Memo(lib:fix(Fun)),
    F(binary:size(S))."
erlang,compile_error,"Line 9: Char 65: illegal guard expression
%    9|                                                      Start > 0, binary:part(S, {Start - 1, byte_size(DictWord)}) == DictWord ->
%     |                                                                 ^",../questions/Medium\extra-characters-in-a-string\responses\Erlang\response_erlang_1_failed.json,"-spec min_extra_char(S :: unicode:unicode_binary(), Dictionary :: [unicode:unicode_binary()]) -> integer().
min_extra_char(S, Dictionary) ->
    Len = byte_size(S),
    DP = lists:foldl(fun(_, Acc) -> [0 | Acc] end, [], lists:seq(0, Len)),
    Memo = lists:foldl(fun(Pos, Acc) ->
                           Min = lists:foldl(fun(DictWord, MinAcc) ->
                                                 Start = Pos - byte_size(DictWord) + 1,
                                                 if
                                                     Start > 0, binary:part(S, {Start - 1, byte_size(DictWord)}) == DictWord ->
                                                         MinSoFar = lists:nth(Start, Acc),
                                                         Min0 = erlang:min(MinSoFar, MinAcc),
                                                         Min0;
                                                     true ->
                                                         MinAcc
                                                 end
                                             end, Pos, Dictionary),
                           [Min | Acc]
                       end, [0], lists:seq(1, Len)),
    hd(Memo) - 1."
erlang,compile_error,"Line 12: Char 36: illegal guard expression
%   12|                                    binary:part(S, {Pos - size(D), size(D)}) == D ->
%     |                                    ^",../questions/Medium\extra-characters-in-a-string\responses\Erlang\response_erlang_2_failed.json,"-spec min_extra_char(S :: unicode:unicode_binary(), Dictionary :: [unicode:unicode_binary()]) -> integer().
min_extra_char(S, Dictionary) ->
    DP = fun DP(_, 0, _) -> 0;
             DP(Memo, Pos, F) ->
                 case maps:find(Pos, Memo) of
                     {ok, Val} -> Val;
                     error ->
                         Min = lists:foldl(
                           fun(D, Acc) ->
                               if
                                   Pos >= size(D),
                                   binary:part(S, {Pos - size(D), size(D)}) == D ->
                                       Min0 = F(Memo, Pos - size(D), F),
                                       erlang:min(Min0, Acc);
                                   true ->
                                       Acc
                               end
                           end, Pos, Dictionary),
                         Memo1 = maps:put(Pos, erlang:min(Min, F(Memo, Pos - 1, F) + 1), Memo),
                         maps:get(Pos, Memo1)
                 end
         end,
    Fun = fun(F) -> fun(Memo, Pos) -> DP(Memo, Pos, F) end end,
    F = lib:fix(Fun),
    F(maps:new(), size(S), F)."
erlang,compile_error,"Line 19: Char 21: illegal guard expression
%   19|                 abs(lists:nth(I + 1, Nums) - lists:nth(J + 1, Nums)) >= ValueDifference ->
%     |                     ^
Line 19: Char 46: illegal guard expression
%   19|                 abs(lists:nth(I + 1, Nums) - lists:nth(J + 1, Nums)) >= ValueDifference ->
%     |                                              ^",../questions/Medium\find-indices-with-index-and-value-difference-ii\responses\Erlang\response_erlang_1_failed.json,"-spec find_indices(Nums :: [integer()], IndexDifference :: integer(), ValueDifference :: integer()) -> [integer()].
find_indices(Nums, IndexDifference, ValueDifference) ->
    Length = length(Nums),
    find_indices_loop(Nums, IndexDifference, ValueDifference, 0, Length).

find_indices_loop(Nums, IndexDifference, ValueDifference, StartIndex, Length) ->
    case find_valid_pair(Nums, IndexDifference, ValueDifference, StartIndex, Length) of
        {I, J} when I =/= -1, J =/= -1 -> [I, J];
        _ -> [-1, -1]
    end.

find_valid_pair(Nums, IndexDifference, ValueDifference, StartIndex, Length) ->
    find_valid_pair_helper(Nums, IndexDifference, ValueDifference, StartIndex, StartIndex + IndexDifference, Length).

find_valid_pair_helper(Nums, IndexDifference, ValueDifference, I, J, Length) ->
    if
        I < Length, J < Length ->
            if
                abs(lists:nth(I + 1, Nums) - lists:nth(J + 1, Nums)) >= ValueDifference ->
                    {I, J};
                true ->
                    NextJ = J + 1,
                    if
                        NextJ - I >= IndexDifference ->
                            find_valid_pair_helper(Nums, IndexDifference, ValueDifference, I, NextJ, Length);
                        true ->
                            NextI = I + 1,
                            if NextI < Length - IndexDifference ->
                                find_valid_pair_helper(Nums, IndexDifference, ValueDifference, NextI, NextI + IndexDifference, Length);
                            true ->
                                {-1, -1}
                            end
                    end
            end;
        true -> {-1, -1}
    end."
erlang,compile_error,"Line 21: Char 9: illegal guard expression
%   21|         binary:part(S, {Len, byte_size(S) - Len}) =:= Sub ->
%     |         ^",../questions/Medium\find-longest-special-substring-that-occurs-thrice-i\responses\Erlang\response_erlang_1_failed.json,"-spec maximum_length(S :: unicode:unicode_binary()) -> integer().
maximum_length(S) ->
    MaxLen = byte_size(S),
    find_max(S, MaxLen, 1, -1).

find_max(_S, 0, _CurLen, Max) ->
    Max;
find_max(S, MaxLen, CurLen, Max) ->
    Count = count_occurrences(S, MaxLen, CurLen, 0),
    if
        Count >= 3 ->
            find_max(S, MaxLen - 1, CurLen + 1, CurLen);
        true ->
            find_max(S, MaxLen - 1, CurLen + 1, Max)
    end.

count_occurrences(S, MaxLen, Len, Acc) when MaxLen >= Len ->
    Sub = binary:part(S, {0, Len}),
    Rest = binary:part(S, {1, byte_size(S) - 1}),
    if
        binary:part(S, {Len, byte_size(S) - Len}) =:= Sub ->
            count_occurrences(Rest, MaxLen - 1, Len, Acc + 1);
        true ->
            count_occurrences(Rest, MaxLen - 1, Len, Acc)
    end;
count_occurrences(_S, _MaxLen, _Len, Acc) ->
    Acc."
erlang,compile_error,"Line 7: Char 111: variable 'Start' is unbound
%    7|             length([Ok || Ok <- [binary:part(S, Other, Len) || Other <- lists:seq(0, MaxLen - Len), Other =/= Start], Ok == SubStr]) >= 2])
%     |                                                                                                               ^",../questions/Medium\find-longest-special-substring-that-occurs-thrice-ii\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_length(S :: unicode:unicode_binary()) -> integer().
maximum_length(S) ->
    MaxLen = byte_size(S),
    try
        lists:max([Len || Len <- lists:seq(1, MaxLen), 
            SubStr <- [binary:part(S, Start, Len) || Start <- lists:seq(0, MaxLen - Len)],
            length([Ok || Ok <- [binary:part(S, Other, Len) || Other <- lists:seq(0, MaxLen - Len), Other =/= Start], Ok == SubStr]) >= 2]) 
    catch
        _:_ -> -1
    end."
erlang,compile_error,"Line 9: Char 8: call to local/imported function check_length/2 is illegal in guard
%    9|     if check_length(S, Mid) ->
%     |        ^
Line 21: Char 33: illegal guard expression
%   21|                                 maps:is_key(SubStr, Acc) ->
%     |                                 ^",../questions/Medium\find-longest-special-substring-that-occurs-thrice-ii\responses\Erlang\response_erlang_2_failed.json,"-spec maximum_length(S :: unicode:unicode_binary()) -> integer().
maximum_length(S) ->
    find_max_length(S, 1, byte_size(S), -1).

find_max_length(_S, _Min, Max, Result) when Max < _Min ->
    Result;
find_max_length(S, Min, Max, Result) ->
    Mid = (Min + Max) div 2,
    if check_length(S, Mid) ->
        find_max_length(S, Mid + 1, Max, Mid);
       true ->
        find_max_length(S, Min, Mid - 1, Result)
    end.

check_length(S, Len) ->
    MaxStart = byte_size(S) - Len + 1,
    Count = lists:foldl(fun(Start, Acc) ->
                            SubStr = binary:part(S, Start, Len),
                            if 
                                Acc == undefined -> maps:put(SubStr, 1, Acc);
                                maps:is_key(SubStr, Acc) -> 
                                    C = maps:get(SubStr, Acc),
                                    if C == 2 -> throw(found); true -> maps:update(SubStr, C + 1, Acc) end;
                                true -> maps:put(SubStr, 1, Acc)
                            end
                        end, #{}, lists:seq(0, MaxStart - 1)),
    catch Count,
    false."
erlang,compile_error,"Line 4: Char 66: variable 'F' is unbound
%    4|             (Count, Max, Current, [H | T]) when H =:= Current -> F(Count + 1, max(Count + 1, Max), Current, T);
%     |                                                                  ^
Line 10: Char 17: variable 'F' is unbound
%   10|                 F(maps:put(H, NextCount, Count), max(NextCount, Max), H, T)
%     |                 ^",../questions/Medium\find-the-longest-equal-subarray\responses\Erlang\response_erlang_0_failed.json,"-spec longest_equal_subarray(Nums :: [integer()], K :: integer()) -> integer().
longest_equal_subarray(Nums, K) ->
    F = fun(Count, Max, _, []) -> Max;
            (Count, Max, Current, [H | T]) when H =:= Current -> F(Count + 1, max(Count + 1, Max), Current, T);
            (Count, Max, Current, [H | T]) ->
                NextCount = case maps:get(H, Count, 0) of
                                C when C + K >= length(T) + 1 -> length(T) + 1;
                                C -> C + 1
                            end,
                F(maps:put(H, NextCount, Count), max(NextCount, Max), H, T)
        end,
    F(maps:new(), 0, hd(Nums), Nums)."
erlang,compile_error,"Line 11: Char 19: syntax error before: '<='
%   11|         Count - 1 <= K -> Max + 1;
%     |                   ^
Line 4: Char 5: function longest_equal_subarray/6 undefined
%    4|     longest_equal_subarray(Nums, K, Maps, 0, 0, 0).
%     |     ^",../questions/Medium\find-the-longest-equal-subarray\responses\Erlang\response_erlang_2_failed.json,"-spec longest_equal_subarray(Nums :: [integer()], K :: integer()) -> integer().
longest_equal_subarray(Nums, K) ->
    Maps = lists:foldl(fun(X, Acc) -> maps:update_with(X, fun(Val) -> Val + 1 end, 1, Acc) end, #{}, Nums),
    longest_equal_subarray(Nums, K, Maps, 0, 0, 0).

longest_equal_subarray([], _, _, Max, _, _) ->
    Max;
longest_equal_subarray([H|T], K, Maps, Max, CurrentMax, CurrentElem) ->
    Count = maps:get(H, Maps),
    NewMax = if
        Count - 1 <= K -> Max + 1;
        true -> Max
    end,
    if
        H =:= CurrentElem ->
            longest_equal_subarray(T, K, maps:update_with(H, fun(Val) -> Val - 1 end, Maps), NewMax, CurrentMax + 1, CurrentElem);
        true ->
            NewCurrentMax = max(CurrentMax, NewMax),
            longest_equal_subarray(T, K, maps:update_with(H, fun(Val) -> Val - 1 end, Maps), 1, NewCurrentMax, H)
    end."
erlang,compile_error,"Line 3: Char 51: syntax error before: '('
%    3|     MaxLen = fun MaxLen(_, _, _, Max, _, byte_size(S)) -> Max;
%     |                                                   ^
Line 1: Char 2: spec for undefined function longest_semi_repetitive_substring/1
%    1| -spec longest_semi_repetitive_substring(S :: unicode:unicode_binary()) -> integer().
%     |  ^
Line 34: Char 13: function longest_semi_repetitive_substring/1 undefined
%   34|       Ret = longest_semi_repetitive_substring(Param_1),
%     |             ^",../questions/Medium\find-the-longest-semi-repetitive-substring\responses\Erlang\response_erlang_1_failed.json,"-spec longest_semi_repetitive_substring(S :: unicode:unicode_binary()) -> integer().
longest_semi_repetitive_substring(S) ->
    MaxLen = fun MaxLen(_, _, _, Max, _, byte_size(S)) -> Max;
                 MaxLen(F, Prev, PrevPrev, Max, Start, I) ->
                    C = binary:at(S, I),
                    NewMax = if C =:= Prev andalso Prev =:= PrevPrev -> 
                                max(Max, I - Start);
                             true -> 
                                Max
                             end,
                    NewStart = if C =:= Prev andalso Prev =:= PrevPrev -> 
                                  I - 1;
                               true -> 
                                  Start
                               end,
                    F(F, C, Prev, NewMax, NewStart, I + 1)
             end,
    MaxLen(MaxLen, <<0>>, <<0>>, 0, 0, 0)."
erlang,compile_error,"Line 3: Char 48: syntax error before: '('
%    3|     MaxLen = fun MaxLen(_, _, Max, _, byte_size(S)) -> Max;
%     |                                                ^
Line 1: Char 2: spec for undefined function longest_semi_repetitive_substring/1
%    1| -spec longest_semi_repetitive_substring(S :: unicode:unicode_binary()) -> integer().
%     |  ^
Line 34: Char 13: function longest_semi_repetitive_substring/1 undefined
%   34|       Ret = longest_semi_repetitive_substring(Param_1),
%     |             ^",../questions/Medium\find-the-longest-semi-repetitive-substring\responses\Erlang\response_erlang_2_failed.json,"-spec longest_semi_repetitive_substring(S :: unicode:unicode_binary()) -> integer().
longest_semi_repetitive_substring(S) ->
    MaxLen = fun MaxLen(_, _, Max, _, byte_size(S)) -> Max;
                 MaxLen(F, Prev, Max, Start, I) ->
                    C = binary:at(S, I),
                    NewMax = if C =:= Prev -> 
                                max(Max, I - Start);
                             true -> 
                                Max
                             end,
                    NewStart = if C =:= Prev -> 
                                  I;
                               true -> 
                                  Start
                               end,
                    F(F, C, NewMax, NewStart, I + 1)
             end,
    MaxLen(MaxLen, <<>>, 0, 0, 0)."
erlang,compile_error,"Line 4: Char 19: syntax error before: 'div'
%    4|     Base = erlang:div(Target, 2),
%     |                   ^
Line 1: Char 2: spec for undefined function minimum_possible_sum/2
%    1| -spec minimum_possible_sum(N :: integer(), Target :: integer()) -> integer().
%     |  ^
Line 30: Char 13: function minimum_possible_sum/2 undefined
%   30|       Ret = minimum_possible_sum(Param_1, Param_2),
%     |             ^",../questions/Medium\find-the-minimum-possible-sum-of-a-beautiful-array\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_possible_sum(N :: integer(), Target :: integer()) -> integer().
minimum_possible_sum(N, Target) ->
    Mod = 1000000007,
    Base = erlang:div(Target, 2),
    Extra = case Target rem 2 of
                0 -> Base;
                1 -> Base + 1
            end,
    if
        N > Base -> (((2 * Extra + N - 1) * N div 2) rem Mod);
        true -> (((N * (N + 1)) div 2) rem Mod)
    end."
erlang,compile_error,"Line 10: Char 9: call to local/imported function can_partition/3 is illegal in guard
%   10|         can_partition(Squared, Current, []) ->
%     |         ^",../questions/Medium\find-the-punishment-number-of-an-integer\responses\Erlang\response_erlang_0_failed.json,"-spec punishment_number(N :: integer()) -> integer().
punishment_number(N) ->
    punishment_number(N, 1, 0).

punishment_number(0, _, Acc) ->
    Acc;
punishment_number(N, Current, Acc) when Current =< N ->
    Squared = Current * Current,
    if
        can_partition(Squared, Current, []) ->
            punishment_number(N, Current + 1, Acc + Squared);
        true ->
            punishment_number(N, Current + 1, Acc)
    end.

can_partition(0, 0, _) ->
    true;
can_partition(Number, Target, Acc) when Number > 0, Target >= 0 ->
    Digit = Number rem 10,
    NewNumber = Number div 10,
    NewTarget = Target - Digit,
    if
        NewTarget >= 0 ->
            can_partition(NewNumber, NewTarget, [Digit|Acc]);
        true ->
            false
    end;
can_partition(_, _, _) ->
    false."
erlang,compile_error,"Line 10: Char 9: call to local/imported function can_partition/2 is illegal in guard
%   10|         can_partition(Squared, Current) ->
%     |         ^",../questions/Medium\find-the-punishment-number-of-an-integer\responses\Erlang\response_erlang_1_failed.json,"-spec punishment_number(N :: integer()) -> integer().
punishment_number(N) ->
    punishment_number(N, 1, 0).

punishment_number(0, _, Acc) ->
    Acc;
punishment_number(N, Current, Acc) when Current =< N ->
    Squared = Current * Current,
    if
        can_partition(Squared, Current) ->
            punishment_number(N, Current + 1, Acc + Squared);
        true ->
            punishment_number(N, Current + 1, Acc)
    end.

can_partition(Number, Target) ->
    can_partition(Number, Target, 0).

can_partition(0, 0, _) ->
    true;
can_partition(Number, Target, Sum) when Number > 0, Target >= 0 ->
    Digit = Number rem 10,
    NewNumber = Number div 10,
    NewSum = Sum + Digit,
    if
        NewSum =:= Target ->
            true;
        true ->
            can_partition(NewNumber, Target, NewSum) orelse can_partition(NewNumber, Target, 0)
    end;
can_partition(_, _, _) ->
    false."
erlang,compile_error,"Line 10: Char 9: call to local/imported function check_partition/2 is illegal in guard
%   10|         check_partition(integer_to_list(Squared), Current) ->
%     |         ^
Line 10: Char 25: call to local/imported function integer_to_list/1 is illegal in guard
%   10|         check_partition(integer_to_list(Squared), Current) ->
%     |                         ^",../questions/Medium\find-the-punishment-number-of-an-integer\responses\Erlang\response_erlang_2_failed.json,"-spec punishment_number(N :: integer()) -> integer().
punishment_number(N) ->
    punishment_number(N, 1, 0).

punishment_number(N, Current, Acc) when Current > N ->
    Acc;
punishment_number(N, Current, Acc) ->
    Squared = Current * Current,
    if
        check_partition(integer_to_list(Squared), Current) ->
            punishment_number(N, Current + 1, Acc + Squared);
        true ->
            punishment_number(N, Current + 1, Acc)
    end.

check_partition(SquaredList, Target) ->
    check_partition(SquaredList, Target, 0).

check_partition([], 0, 0) ->
    true;
check_partition([], _, _) ->
    false;
check_partition([H|T], Target, CurrentSum) ->
    Digit = H - 48, % Convert char to integer
    NewSum = CurrentSum * 10 + Digit,
    if
        NewSum =:= Target ->
            check_partition(T, Target, 0);
        NewSum < Target ->
            check_partition(T, Target, NewSum);
        true ->
            false
    end.

integer_to_list(Number) ->
    lists:reverse(integer_to_list(Number, [])).
    
integer_to_list(0, Acc) when Acc =/= [] ->
    Acc;
integer_to_list(N, Acc) ->
    Digit = (N rem 10) + 48, % ASCII offset
    integer_to_list(N div 10, [Digit|Acc])."
erlang,compile_error,"Line 12: Char 37: syntax error before: '<='
%   12|     Selected > H orelse NotSelected <= H ->
%     |                                     ^
Line 5: Char 3: function count_ways_helper/5 undefined
%    5|   count_ways_helper(Sorted, Total, 0, 1, 0).
%     |   ^",../questions/Medium\happy-students\responses\Erlang\response_erlang_1_failed.json,"-spec count_ways(Nums :: [integer()]) -> integer().
count_ways(Nums) ->
  Sorted = lists:sort(Nums),
  Total = length(Nums),
  count_ways_helper(Sorted, Total, 0, 1, 0).

count_ways_helper([], _Total, _Selected, _PrevWays, Acc) ->
  Acc + 1;
count_ways_helper([H|T], Total, Selected, PrevWays, Acc) ->
  NotSelected = Total - Selected,
  if
    Selected > H orelse NotSelected <= H ->
      if 
        Selected == 0 orelse H /= hd(T) ->
          count_ways_helper(T, Total, Selected + 1, 1, Acc + PrevWays);
        true ->
          count_ways_helper(T, Total, Selected + 1, PrevWays + 1, Acc)
      end;
    true ->
      Acc
  end."
erlang,compile_error,"Line 19: Char 35: syntax error before: '<='
%   19|     Count < H andalso NotSelected <= H ->
%     |                                   ^
Line 5: Char 3: function count_ways_helper/4 undefined
%    5|   count_ways_helper(Sorted, Total, 0, 0).
%     |   ^",../questions/Medium\happy-students\responses\Erlang\response_erlang_2_failed.json,"-spec count_ways(Nums :: [integer()]) -> integer().
count_ways(Nums) ->
  Sorted = lists:sort(Nums),
  Total = length(Nums),
  count_ways_helper(Sorted, Total, 0, 0).

count_ways_helper([], Total, Count, Acc) ->
  if 
    Count == 0 ->
      Acc + 1;
    true ->
      Acc
  end;
count_ways_helper([H|T], Total, Count, Acc) ->
  NotSelected = Total - Count,
  if 
    Count >= H andalso NotSelected > H ->
      count_ways_helper(T, Total, Count + 1, Acc);
    Count < H andalso NotSelected <= H ->
      count_ways_helper(T, Total, Count, Acc + 1);
    true ->
      Acc
  end."
erlang,compile_error,"Line 3: Char 5: function foldl/3 undefined
%    3|     foldl(fun(A, Acc) when A >= hd(Acc) -> [A + hd(Acc) | tl(Acc)]; (A, Acc) -> [A | Acc] end, [0], lists:reverse(Nums)) -- [0].
%     |     ^",../questions/Medium\largest-element-in-an-array-after-merge-operations\responses\Erlang\response_erlang_1_failed.json,"-spec max_array_value(Nums :: [integer()]) -> integer().
max_array_value(Nums) ->
    foldl(fun(A, Acc) when A >= hd(Acc) -> [A + hd(Acc) | tl(Acc)]; (A, Acc) -> [A | Acc] end, [0], lists:reverse(Nums)) -- [0]."
erlang,compile_error,"Line 3: Char 52: syntax error before: '<='
%    3|     lists:max(lists:foldl(fun(X, [H|T]=Acc) when X <= H -> [X+H|T]; (X, Acc) -> [X|Acc] end, [hd(Nums)], tl(Nums))).
%     |                                                    ^
Line 1: Char 2: spec for undefined function max_array_value/1
%    1| -spec max_array_value(Nums :: [integer()]) -> integer().
%     |  ^
Line 19: Char 13: function max_array_value/1 undefined
%   19|       Ret = max_array_value(Param_1),
%     |             ^",../questions/Medium\largest-element-in-an-array-after-merge-operations\responses\Erlang\response_erlang_2_failed.json,"-spec max_array_value(Nums :: [integer()]) -> integer().
max_array_value(Nums) ->
    lists:max(lists:foldl(fun(X, [H|T]=Acc) when X <= H -> [X+H|T]; (X, Acc) -> [X|Acc] end, [hd(Nums)], tl(Nums)))."
erlang,compile_error,"Line 8: Char 15: variable 'NewCounts' unsafe in 'if' (line 12, column 44)
%    8|     {NewNums, NewCounts, NewEnd, NewLen} = if
%     |               ^
Line 17: Char 6: variable 'NewMaxLen' unsafe in 'if' (line 21, column 42)
%   17|     {NewMaxLen, NewStart, CleanCounts} = if
%     |      ^
Line 17: Char 17: variable 'NewStart' unsafe in 'if' (line 21, column 42)
%   17|     {NewMaxLen, NewStart, CleanCounts} = if
%     |                 ^
Line 17: Char 27: variable 'CleanCounts' unsafe in 'if' (line 21, column 42)
%   17|     {NewMaxLen, NewStart, CleanCounts} = if
%     |                           ^
Line 18: Char 18: variable 'NewCounts' unsafe in 'if' (line 12, column 44)
%   18|         map_size(NewCounts) =< K ->
%     |                  ^
Line 24: Char 42: variable 'NewCounts' unsafe in 'if' (line 12, column 44)
%   24|             CleanCount = maps:get(First, NewCounts) - 1,
%     |                                          ^
Line 31: Char 42: variable 'CleanCounts' unsafe in 'if' (line 21, column 42)
%   31|     find_max_subarray_length(NewNums, K, CleanCounts, NewMaxLen, NewStart, NewEnd, NewLen).
%     |                                          ^
Line 31: Char 55: variable 'NewMaxLen' unsafe in 'if' (line 21, column 42)
%   31|     find_max_subarray_length(NewNums, K, CleanCounts, NewMaxLen, NewStart, NewEnd, NewLen).
%     |                                                       ^
Line 31: Char 66: variable 'NewStart' unsafe in 'if' (line 21, column 42)
%   31|     find_max_subarray_length(NewNums, K, CleanCounts, NewMaxLen, NewStart, NewEnd, NewLen).
%     |                                                                  ^",../questions/Medium\length-of-longest-subarray-with-at-most-k-frequency\responses\Erlang\response_erlang_2_failed.json,"-spec max_subarray_length(Nums :: [integer()], K :: integer()) -> integer().
max_subarray_length(Nums, K) ->
    find_max_subarray_length(Nums, K, maps:new(), 0, 1, 1, 0).

find_max_subarray_length(_Nums, _K, _Counts, MaxLen, _Start, End, Len) when End > Len ->
    MaxLen;
find_max_subarray_length(Nums, K, Counts, MaxLen, Start, End, Len) ->
    {NewNums, NewCounts, NewEnd, NewLen} = if 
        End =< Len ->
            [H|T] = Nums,
            NewCount = maps:get(H, Counts, 0) + 1,
            NewCounts = Counts#{H => NewCount},
            {T, NewCounts, End + 1, Len};
        true ->
            {Nums, Counts, End, Len}
    end,
    {NewMaxLen, NewStart, CleanCounts} = if 
        map_size(NewCounts) =< K ->
            {max(MaxLen, NewEnd - Start), Start, NewCounts};
        true ->
            First = hd(lists:nthtail(Start - 1, Nums)),
            NewStart = Start + 1,
            NewMaxLen = MaxLen,
            CleanCount = maps:get(First, NewCounts) - 1,
            CleanCounts = if
                CleanCount =:= 0 -> maps:remove(First, NewCounts);
                true -> NewCounts#{First => CleanCount}
            end,
            {NewMaxLen, NewStart, CleanCounts}
    end,
    find_max_subarray_length(NewNums, K, CleanCounts, NewMaxLen, NewStart, NewEnd, NewLen)."
erlang,compile_error,"Line 10: Char 30: variable 'SmallestString' is unbound
%   10|                              SmallestString(T, Acc ++ [NewChar])
%     |                              ^
Line 19: Char 9: variable 'Start' unsafe in 'case' (line 16, column 17)
%   19|         Start ->
%     |         ^",../questions/Medium\lexicographically-smallest-string-after-substring-operation\responses\Erlang\response_erlang_0_failed.json,"-spec smallest_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
smallest_string(S) ->
    SmallestString = fun(Str, Acc) when length(Str) =:= 0 -> Acc;
                         (Str, Acc) ->
                             [H|T] = Str,
                             NewChar = case H of
                                           $a -> $z;
                                           _ -> H - 1
                                       end,
                             SmallestString(T, Acc ++ [NewChar])
                     end,
    FirstNonA = case re:run(S, ""[b-z]"", [{capture, first, list}]) of
                    {match, [{Start, _}]} -> Start;
                    nomatch -> -1
                end,
    case FirstNonA of
        -1 -> SmallestString(binary_to_list(S), []);
        0 -> binary_to_list(S);
        Start ->
            Before = binary_part(S, {0, Start}),
            ToChange = binary_part(S, {Start, byte_size(S) - Start}),
            Before ++ SmallestString(binary_to_list(ToChange), [])
    end."
erlang,compile_error,"Line 19: Char 9: variable 'Start' unsafe in 'case' (line 16, column 17)
%   19|         Start ->
%     |         ^",../questions/Medium\lexicographically-smallest-string-after-substring-operation\responses\Erlang\response_erlang_1_failed.json,"-spec smallest_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
smallest_string(S) ->
    SmallestString = fun(Str, Acc, SSFun) when length(Str) =:= 0 -> Acc;
                         (Str, Acc, SSFun) ->
                             [H|T] = Str,
                             NewChar = case H of
                                           $a -> $z;
                                           _ -> H - 1
                                       end,
                             SSFun(T, Acc ++ [NewChar], SSFun)
                     end,
    FirstNonA = case re:run(S, ""[b-z]"", [{capture, first, list}]) of
                    {match, [{Start, _}]} -> Start;
                    nomatch -> -1
                end,
    case FirstNonA of
        -1 -> SmallestString(binary_to_list(S), [], SmallestString);
        0 -> S;
        Start ->
            Before = binary_part(S, {0, Start}),
            ToChange = binary_part(S, {Start, byte_size(S) - Start}),
            Before ++ SmallestString(binary_to_list(ToChange), [], SmallestString)
    end."
erlang,compile_error,"Line 3: Char 15: function foldl/3 undefined
%    3|     lists:max(foldl(fun({A, B}, {PrevA, PrevB, Len}) ->
%     |               ^",../questions/Medium\longest-non-decreasing-subarray-from-two-arrays\responses\Erlang\response_erlang_0_failed.json,"-spec max_non_decreasing_length(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
max_non_decreasing_length(Nums1, Nums2) ->
    lists:max(foldl(fun({A, B}, {PrevA, PrevB, Len}) ->
                        {MaxA, MaxB} = {max(PrevA, A), max(PrevB, B)},
                        {NewA, NewB, NewLen} = if
                                                   A >= MaxA andalso B >= MaxB -> {A, B, Len + 1};
                                                   A >= MaxA -> {A, max(A, PrevB), Len + 1};
                                                   B >= MaxB -> {max(B, PrevA), B, Len + 1};
                                                   true -> {A, B, 1}
                                               end,
                        {NewA, NewB, max(Len, NewLen)}
                    end, {hd(Nums1), hd(Nums2), 1}, tl(lists:zip(Nums1, Nums2)))). "
erlang,compile_error,"Line 28: Char 44: syntax error before: ')'
%   28|         end, [{0, 0}], lists:seq(1, Length)),
%     |                                            ^
Line 1: Char 2: spec for undefined function max_non_decreasing_length/2
%    1| -spec max_non_decreasing_length(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
%     |  ^
Line 47: Char 13: function max_non_decreasing_length/2 undefined
%   47|       Ret = max_non_decreasing_length(Param_1, Param_2),
%     |             ^",../questions/Medium\longest-non-decreasing-subarray-from-two-arrays\responses\Erlang\response_erlang_2_failed.json,"-spec max_non_decreasing_length(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
max_non_decreasing_length(Nums1, Nums2) ->
    Length = length(Nums1),
    DP = lists:foldl(
        fun(Index, Acc) ->
            {MaxLen1, MaxLen2} = lists:nth(Index, Acc),
            {Val1, Val2} = {lists:nth(Index, Nums1), lists:nth(Index, Nums2)},
            NewMaxLen1 = case Index of
                             1 ->
                                 1;
                             _ ->
                                 if
                                     Val1 >= lists:nth(Index - 1, Nums1) -> lists:nth(Index - 1, Acc) + 1;
                                     Val1 >= lists:nth(Index - 1, Nums2) -> MaxLen2 + 1;
                                     true -> 1
                                 end,
            NewMaxLen2 = case Index of
                             1 ->
                                 1;
                             _ ->
                                 if
                                     Val2 >= lists:nth(Index - 1, Nums2) -> lists:nth(Index, Acc) + 1;
                                     Val2 >= lists:nth(Index - 1, Nums1) -> MaxLen1 + 1;
                                     true -> 1
                                 end
            end,
            Acc ++ [{max(NewMaxLen1, NewMaxLen2)}]
        end, [{0, 0}], lists:seq(1, Length)),
    lists:max([MaxLen || {MaxLen} <- DP])."
erlang,compile_error,"Line 28: Char 19: function snd/1 undefined
%   28|     end, {0, []}, snd(Seq)),
%     |                   ^",../questions/Medium\longest-unequal-adjacent-groups-subsequence-i\responses\Erlang\response_erlang_1_failed.json,"-spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].
get_words_in_longest_subsequence(N, Words, Groups) ->
    Seq = lists:foldl(
        fun(Group, {PrevGroup, Acc}) ->
            case Acc of
                [] ->
                    if PrevGroup =:= undefined -> {Group, [[Group]]};
                       true -> {Group, [[Group]]}
                    end;
                [H | _T] = L ->
                    if PrevGroup =/= Group ->
                        {Group, [[Group] | L]};
                       true ->
                        NewH = [Group | H],
                        {Group, [NewH | tl(L)]}
                    end
            end
        end,
        {undefined, []},
        Groups
    ),
    {_, Longest} = lists:foldl(fun(L, {Max, Acc}) ->
        Len = length(L),
        case Len > Max of
            true -> {Len, [L]};
            false -> {Max, Acc}
        end
    end, {0, []}, snd(Seq)),
    lists:map(fun(Index) -> lists:nth(Index, Words) end, hd(Longest))."
erlang,compile_error,"Line 21: Char 66: function snd/1 undefined
%   21|     SelectedIndices = [Index || {Index, _Group} <- lists:reverse(snd(FilteredIndices))],
%     |                                                                  ^",../questions/Medium\longest-unequal-adjacent-groups-subsequence-i\responses\Erlang\response_erlang_2_failed.json,"-spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].
get_words_in_longest_subsequence(N, Words, Groups) ->
    FilteredIndices = lists:foldl(
        fun(Group, {PrevGroup, Acc}) ->
            case Acc of
                [] ->
                    [{1, Group}];
                [_|_] = L ->
                    [{Index, G} | _] = L,
                    if
                        PrevGroup =/= Group ->
                            [{Index + 1, Group} | L];
                        true ->
                            L
                    end
            end
        end,
        {undefined, []},
        [{Index, Group} || {Index, Group} <- lists:zip(lists:seq(1, N), Groups)]
    ),
    SelectedIndices = [Index || {Index, _Group} <- lists:reverse(snd(FilteredIndices))],
    [lists:nth(Index, Words) || Index <- SelectedIndices]."
erlang,compile_error,"Line 6: Char 16: syntax error before: I
%    6|         Groups#I =/= Groups#J andalso Hamming1(lists:nth(I + 1, Words), lists:nth(J + 1, Words)) =:= 1 end,
%     |                ^
Line 1: Char 2: spec for undefined function get_words_in_longest_subsequence/3
%    1| -spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].
%     |  ^
Line 38: Char 13: function get_words_in_longest_subsequence/3 undefined
%   38|       Ret = get_words_in_longest_subsequence(Param_1, Param_2, Param_3),
%     |             ^",../questions/Medium\longest-unequal-adjacent-groups-subsequence-ii\responses\Erlang\response_erlang_0_failed.json,"-spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].
get_words_in_longest_subsequence(N, Words, Groups) ->
    Hamming1 = fun(A, B) -> 
        lists:sum([if X =/= Y -> 1; true -> 0 end || {X, Y} <- lists:zip(binary:bin_to_list(A), binary:bin_to_list(B))]) end,
    CanFollow = fun(I, J) -> 
        Groups#I =/= Groups#J andalso Hamming1(lists:nth(I + 1, Words), lists:nth(J + 1, Words)) =:= 1 end,
    Paths = lists:foldl(
        fun(I, Acc) -> 
            lists:foldl(
                fun(J, AccIn) when I < J, CanFollow(I, J) -> 
                    SeqI = proplists:get_value(I, AccIn, []),
                    SeqJ = proplists:get_value(J, AccIn, []),
                    if length(SeqI) + 1 > length(SeqJ) -> 
                        proplists:replace({J, [I|SeqI]}, AccIn);
                       true -> AccIn end;
                   (_, AccIn) -> AccIn end, Acc, lists:seq(0, N - 1)) end, [{-1, []}], lists:seq(-1, N - 1)),
    {MaxIndex, _} = lists:max([ {length(Seq), I} || {I, Seq} <- Paths ]),
    [lists:nth(I + 1, Words) || I <- lists:reverse(proplists:get_value(MaxIndex, Paths))]."
erlang,compile_error,"Line 10: Char 43: illegal guard expression
%   10|                 fun(J, AccIn) when I < J, CanFollow(I, J) ->
%     |                                           ^",../questions/Medium\longest-unequal-adjacent-groups-subsequence-ii\responses\Erlang\response_erlang_1_failed.json,"-spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].
get_words_in_longest_subsequence(N, Words, Groups) ->
    Hamming1 = fun(A, B) -> 
        lists:sum([if X =/= Y -> 1; true -> 0 end || {X, Y} <- lists:zip(binary:bin_to_list(A), binary:bin_to_list(B))]) end,
    CanFollow = fun(I, J) -> 
        lists:nth(I, Groups) =/= lists:nth(J, Groups) andalso Hamming1(lists:nth(I, Words), lists:nth(J, Words)) =:= 1 end,
    Paths = lists:foldl(
        fun(I, Acc) -> 
            lists:foldl(
                fun(J, AccIn) when I < J, CanFollow(I, J) -> 
                    SeqI = proplists:get_value(I, AccIn, []),
                    SeqJ = proplists:get_value(J, AccIn, []),
                    if length(SeqI) + 1 > length(SeqJ) -> 
                        proplists:replace({J, [I|SeqI]}, AccIn);
                       true -> AccIn end;
                   (_, AccIn) -> AccIn end, Acc, lists:seq(0, N - 1)) end, [{-1, []}], lists:seq(0, N - 1)),
    {MaxIndex, _} = lists:max([ {length(Seq), I} || {I, Seq} <- Paths, I =/= -1 ]),
    [lists:nth(I + 1, Words) || I <- lists:reverse(proplists:get_value(MaxIndex, Paths))]."
erlang,compile_error,"Line 11: Char 38: illegal guard expression
%   11|                     if I < J andalso CanFollow(I, J) ->
%     |                                      ^",../questions/Medium\longest-unequal-adjacent-groups-subsequence-ii\responses\Erlang\response_erlang_2_failed.json,"-spec get_words_in_longest_subsequence(N :: integer(), Words :: [unicode:unicode_binary()], Groups :: [integer()]) -> [unicode:unicode_binary()].
get_words_in_longest_subsequence(N, Words, Groups) ->
    Hamming1 = fun(A, B) -> 
        lists:sum([if X =/= Y -> 1; true -> 0 end || {X, Y} <- lists:zip(binary:bin_to_list(A), binary:bin_to_list(B))]) end,
    CanFollow = fun(I, J) -> 
        lists:nth(I + 1, Groups) =/= lists:nth(J + 1, Groups) andalso Hamming1(lists:nth(I + 1, Words), lists:nth(J + 1, Words)) =:= 1 end,
    Paths = lists:foldl(
        fun(I, Acc) -> 
            lists:foldl(
                fun(J, AccIn) -> 
                    if I < J andalso CanFollow(I, J) -> 
                        SeqI = proplists:get_value(I, AccIn, []),
                        SeqJ = proplists:get_value(J, AccIn, []),
                        if length(SeqI) + 1 > length(SeqJ) -> 
                            proplists:replace({J, [I|SeqI]}, AccIn);
                           true -> AccIn end;
                       true -> AccIn end end, Acc, lists:seq(0, N - 1)) end, [{-1, []}], lists:seq(-1, N - 1)),
    {MaxIndex, _} = lists:max([ {length(Seq), I} || {I, Seq} <- Paths, I >= 0 ]),
    [lists:nth(I + 1, Words) || I <- lists:reverse(proplists:get_value(MaxIndex, Paths))]."
erlang,compile_error,"Line 5: Char 65: syntax error before: '{'
%    5|                              MaxTillNow = lists:max([0 | [Acc#{}{val} || #{}{end = PrevEnd, val = Val} <- Acc, PrevEnd < S]]),
%     |                                                                 ^
Line 1: Char 2: spec for undefined function maximize_the_profit/2
%    1| -spec maximize_the_profit(N :: integer(), Offers :: [[integer()]]) -> integer().
%     |  ^
Line 29: Char 13: function maximize_the_profit/2 undefined
%   29|       Ret = maximize_the_profit(Param_1, Param_2),
%     |             ^",../questions/Medium\maximize-the-profit-as-the-salesman\responses\Erlang\response_erlang_0_failed.json,"-spec maximize_the_profit(N :: integer(), Offers :: [[integer()]]) -> integer().
maximize_the_profit(N, Offers) ->
    SortedOffers = lists:sort(fun([_,E1,G1],[_,E2,G2]) -> E1 < E2 orelse (E1 == E2 andalso G1 > G2) end, Offers),
    DP = lists:foldl(fun([S,E,G], Acc) ->
                             MaxTillNow = lists:max([0 | [Acc#{}{val} || #{}{end = PrevEnd, val = Val} <- Acc, PrevEnd < S]]),
                             [{end = E, val = max(G + MaxTillNow, (case Acc of [] -> 0; [H|_] -> H#{}{val} end))} | Acc]
                     end, [], SortedOffers),
    case DP of
        [] -> 0;
        [H|_] -> H#{}{val}
    end."
erlang,compile_error,"Line 5: Char 68: syntax error before: 'end'
%    5|                              MaxTillNow = lists:max([0 | [Val || #{end := PrevEnd, val := Val} <- Acc, PrevEnd < S]]),
%     |                                                                    ^
Line 1: Char 2: spec for undefined function maximize_the_profit/2
%    1| -spec maximize_the_profit(N :: integer(), Offers :: [[integer()]]) -> integer().
%     |  ^
Line 29: Char 13: function maximize_the_profit/2 undefined
%   29|       Ret = maximize_the_profit(Param_1, Param_2),
%     |             ^",../questions/Medium\maximize-the-profit-as-the-salesman\responses\Erlang\response_erlang_1_failed.json,"-spec maximize_the_profit(N :: integer(), Offers :: [[integer()]]) -> integer().
maximize_the_profit(N, Offers) ->
    SortedOffers = lists:sort(fun([_, E1, G1], [_, E2, G2]) -> E1 < E2 orelse (E1 == E2 andalso G1 > G2) end, Offers),
    DP = lists:foldl(fun([S, E, G], Acc) ->
                             MaxTillNow = lists:max([0 | [Val || #{end := PrevEnd, val := Val} <- Acc, PrevEnd < S]]),
                             [#{end => E, val => max(G + MaxTillNow, case Acc of [] -> 0; [#{val := Val}|_] -> Val end)} | Acc]
                     end, [], SortedOffers),
    case DP of
        [] -> 0;
        [#{val := Val}|_] -> Val
    end."
erlang,compile_error,"Line 5: Char 68: syntax error before: 'end'
%    5|                              MaxTillNow = lists:max([0 | [Val || #{end := PrevEnd, val := Val} <- Acc, PrevEnd < S]]),
%     |                                                                    ^
Line 1: Char 2: spec for undefined function maximize_the_profit/2
%    1| -spec maximize_the_profit(N :: integer(), Offers :: [[integer()]]) -> integer().
%     |  ^
Line 29: Char 13: function maximize_the_profit/2 undefined
%   29|       Ret = maximize_the_profit(Param_1, Param_2),
%     |             ^",../questions/Medium\maximize-the-profit-as-the-salesman\responses\Erlang\response_erlang_2_failed.json,"-spec maximize_the_profit(N :: integer(), Offers :: [[integer()]]) -> integer().
maximize_the_profit(N, Offers) ->
    SortedOffers = lists:sort(fun([_, E1, G1], [_, E2, G2]) -> E1 < E2 orelse (E1 == E2 andalso G1 > G2) end, Offers),
    DP = lists:foldl(fun([S, E, G], Acc) ->
                             MaxTillNow = lists:max([0 | [Val || #{end := PrevEnd, val := Val} <- Acc, PrevEnd < S]]),
                             [#{end => E, val => max(G + MaxTillNow, case Acc of [] -> 0; [H|_] -> H#{}{val} end)} | Acc]
                     end, [], SortedOffers),
    case DP of
        [] -> 0;
        [H|_] -> H#{}{val}
    end."
erlang,compile_error,"Line 24: Char 28: syntax error before: '['
%   24|             Diff = abs(Nums[I] - Nums[Index]),
%     |                            ^
Line 9: Char 51: illegal guard expression
%    9| loop(N, Nums, Target, Q, Visited) when N > 0, not queue:is_empty(Q) ->
%     |                                                   ^
Line 15: Char 30: function fold/8 undefined
%   15|             {Q2, Visited1} = fold(N, Nums, Target, Index, Jumps, Q1, Visited, Index + 1),
%     |                              ^",../questions/Medium\maximum-number-of-jumps-to-reach-the-last-index\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_jumps(Nums :: [integer()], Target :: integer()) -> integer().
maximum_jumps(Nums, Target) ->
    N = length(Nums),
    Q = queue:new(),
    Q1 = queue:in({0, 0}, Q), % {Index, Jumps}
    Visited = array:set(array:new(N, {default, false}), 0, true),
    loop(N, Nums, Target, Q1, Visited).

loop(N, Nums, Target, Q, Visited) when N > 0, not queue:is_empty(Q) ->
    {{Index, Jumps}, Q1} = queue:out(Q),
    if
        Index == N - 1 ->
            Jumps;
        true ->
            {Q2, Visited1} = fold(N, Nums, Target, Index, Jumps, Q1, Visited, Index + 1),
            loop(N, Nums, Target, Q2, Visited1)
    end;
loop(_, _, _, _, _) ->
    -1.

fold(N, Nums, Target, Index, Jumps, Q, Visited, I) when I < N ->
    case array:get(I, Visited) of
        false ->
            Diff = abs(Nums[I] - Nums[Index]),
            if
                Diff =< Target ->
                    Visited1 = array:set(Visited, I, true),
                    Q1 = queue:in({I, Jumps + 1}, Q),
                    fold(N, Nums, Target, Index, Jumps, Q1, Visited1, I + 1);
                true ->
                    fold(N, Nums, Target, Index, Jumps, Q, Visited, I + 1)
            end;
        true ->
            fold(N, Nums, Target, Index, Jumps, Q, Visited, I + 1)
    end;
fold(_, _, _, _, _, Q, Visited, _) ->
    {Q, Visited}."
erlang,compile_error,"Line 14: Char 12: syntax error before: '.'
%   14|     Low - 1.
%     |            ^
Line 3: Char 5: function binary_search/4 undefined
%    3|     binary_search(0, K * X, K, X).
%     |     ^",../questions/Medium\maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k\responses\Erlang\response_erlang_2_failed.json,"-spec find_maximum_number(K :: integer(), X :: integer()) -> integer().
find_maximum_number(K, X) ->
    binary_search(0, K * X, K, X).

binary_search(Low, High, K, X) ->
    if Low < High ->
        Mid = (Low + High) div 2,
        if price(Mid, X) > K ->
            binary_search(Low, Mid, K, X);
        true ->
            binary_search(Mid + 1, High, K, X)
    end;
binary_search(Low, _, _, _) ->
    Low - 1.

price(N, X) ->
    price(N, X, 1, 0).

price(0, _, _, Acc) ->
    Acc;
price(N, X, I, Acc) when I =< N ->
    Increment = if
                    (I rem X) == 0 ->
                        1;
                    true ->
                        0
                end,
    NewAcc = Acc + count_set_bits(I) * Increment,
    price(N, X, I + 1, NewAcc).

count_set_bits(0) ->
    0;
count_set_bits(N) ->
    count_set_bits(N band (N - 1)) + 1."
erlang,compile_error,"Line 10: Char 24: variable 'Neg' is unbound
%   10|     case {lists:length(Neg) rem 2, Zero} of
%     |                        ^
Line 10: Char 36: variable 'Zero' is unbound
%   10|     case {lists:length(Neg) rem 2, Zero} of
%     |                                    ^",../questions/Medium\maximum-strength-of-a-group\responses\Erlang\response_erlang_0_failed.json,"-spec max_strength(Nums :: [integer()]) -> integer().
max_strength(Nums) ->
    {Max, _, _} = lists:foldl(fun (X, {Max, Neg, Zero}) ->
                                  case X of
                                      0 -> {Max, Neg, true};
                                      N when N < 0 -> {Max, [N|Neg], Zero};
                                      P -> {max(Max, P), Neg, Zero}
                                  end
                              end, {0, [], false}, Nums),
    case {lists:length(Neg) rem 2, Zero} of
        {1, true} -> Max;
        {1, false} -> lists:foldl(fun (X, Acc) -> X * Acc end, 1, lists:delete(lists:min(Neg), Neg));
        _ -> lists:foldl(fun (X, Acc) -> X * Acc end, 1, Nums)
    end."
erlang,compile_error,"Line 11: Char 57: syntax error before: true
%   11|     lists:foldl(fun(X, Acc) when Acc == 0; X == 0 -> 0; true -> X * Acc end, 1, AllNums).
%     |                                                         ^
Line 1: Char 2: spec for undefined function max_strength/1
%    1| -spec max_strength(Nums :: [integer()]) -> integer().
%     |  ^
Line 27: Char 13: function max_strength/1 undefined
%   27|       Ret = max_strength(Param_1),
%     |             ^",../questions/Medium\maximum-strength-of-a-group\responses\Erlang\response_erlang_2_failed.json,"-spec max_strength(Nums :: [integer()]) -> integer().
max_strength(Nums) ->
    Positives = [X || X <- Nums, X > 0],
    Negatives = lists:sort([X || X <- Nums, X < 0]),
    NegLen = length(Negatives),
    MaxNeg = if 
                NegLen rem 2 == 0 -> Negatives; 
                true -> tl(Negatives) 
             end,
    AllNums = Positives ++ MaxNeg,
    lists:foldl(fun(X, Acc) when Acc == 0; X == 0 -> 0; true -> X * Acc end, 1, AllNums)."
erlang,compile_error,"Line 3: Char 26: syntax error before: '->'
%    3|     gcd_list(Nums) =:= 1 -> 1; 2.
%     |                          ^
Line 1: Char 2: spec for undefined function minimum_array_length/1
%    1| -spec minimum_array_length([integer()]) -> integer().
%     |  ^
Line 25: Char 13: function minimum_array_length/1 undefined
%   25|       Ret = minimum_array_length(Param_1),
%     |             ^",../questions/Medium\minimize-length-of-array-using-operations\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_array_length([integer()]) -> integer().
minimum_array_length(Nums) ->
    gcd_list(Nums) =:= 1 -> 1; 2.

gcd_list([H|T]) ->
    lists:foldl(fun(X, Acc) -> gcd(X, Acc) end, H, T).

gcd(A, 0) -> A;
gcd(A, B) -> gcd(B, A rem B)."
erlang,compile_error,"Line 4: Char 9: call to local/imported function gcd_list/1 is illegal in guard
%    4|         gcd_list(Nums) =:= 1 -> 1;
%     |         ^",../questions/Medium\minimize-length-of-array-using-operations\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_array_length([integer()]) -> integer().
minimum_array_length(Nums) ->
    if
        gcd_list(Nums) =:= 1 -> 1;
        true -> 2
    end.

gcd_list([H|T]) ->
    lists:foldl(fun(X, Acc) -> gcd(X, Acc) end, H, T).

gcd(A, 0) -> A;
gcd(A, B) -> gcd(B, A rem B)."
erlang,compile_error,"Line 5: Char 98: syntax error before: E
%    5|                                                     if abs(E - F) >= X -> min(AccInner, abs(Nums#E - Nums#F));
%     |                                                                                                  ^
Line 1: Char 2: spec for undefined function min_absolute_difference/2
%    1| -spec min_absolute_difference(Nums :: [integer()], X :: integer()) -> integer().
%     |  ^
Line 29: Char 13: function min_absolute_difference/2 undefined
%   29|       Ret = min_absolute_difference(Param_1, Param_2),
%     |             ^",../questions/Medium\minimum-absolute-difference-between-elements-with-constraint\responses\Erlang\response_erlang_1_failed.json,"-spec min_absolute_difference(Nums :: [integer()], X :: integer()) -> integer().
min_absolute_difference(Nums, X) ->
    MinDiff = lists:foldl(fun(E, Acc) ->
                              Min = lists:foldl(fun(F, AccInner) ->
                                                    if abs(E - F) >= X -> min(AccInner, abs(Nums#E - Nums#F));
                                                       true -> AccInner
                                                    end
                                                end, Acc, lists:seq(0, length(Nums) - 1)),
                              min(Acc, Min)
                          end, hd(Nums), lists:seq(0, length(Nums) - X - 1)),
    MinDiff."
erlang,compile_error,"Line 3: Char 34: variable 'X' is unbound
%    3|     Count = lists:foldl(fun(X, #{X := C}=Map) -> Map#{X => C+1};
%     |                                  ^",../questions/Medium\minimum-array-length-after-pair-removals\responses\Erlang\response_erlang_1_failed.json,"-spec min_length_after_removals(Nums :: [integer()]) -> integer().
min_length_after_removals(Nums) ->
    Count = lists:foldl(fun(X, #{X := C}=Map) -> Map#{X => C+1};
                           (X, Map) -> Map#{X => 1}
                        end, #{}, Nums),
    2 * (lists:foldl(fun(_, Acc) -> Acc+1 end, 0, Count) rem 2)."
erlang,compile_error,"Line 17: Char 13: variable 'FindSplit' is unbound
%   17|             FindSplit(I + 1, {NewLeft, NewRight}, Acc);
%     |             ^",../questions/Medium\minimum-index-of-a-valid-split\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_index(Nums :: [integer()]) -> integer().
minimum_index(Nums) ->
    Freqs = lists:foldl(fun(X, Acc) -> maps:update_with(X, fun(Y) -> Y + 1 end, 1, Acc) end, #{}, Nums),
    {DomElem, DomCount} = lists:max_by(fun({_, Count}) -> Count end, maps:to_list(Freqs)),
    Total = length(Nums),
    FindSplit = fun
        (I, {Left, Right}, Acc) when I < Total - 1 ->
            NewLeft = maps:update_with(DomElem, fun(C) -> C + 1 end, 1, Left),
            NewRight = maps:update_with(DomElem, fun(C) -> C - 1 end, 0, Right),
            LeftCount = maps:get(DomElem, NewLeft, 0),
            RightCount = maps:get(DomElem, NewRight, 0),
            if LeftCount * 2 > I + 1 andalso RightCount * 2 > Total - I - 1 ->
                [I|Acc];
               true ->
                Acc
            end,
            FindSplit(I + 1, {NewLeft, NewRight}, Acc);
        (_, _, Acc) ->
            Acc
    end,
    case FindSplit(0, {#{DomElem => 0}, Freqs#{DomElem := DomCount - 1}}, []) of
        [] -> -1;
        L -> lists:min(L)
    end."
erlang,compile_error,"Line 8: Char 14: variable '_' is unbound
%    8|             {_, Changes + 1}
%     |              ^",../questions/Medium\minimum-number-of-changes-to-make-binary-string-beautiful\responses\Erlang\response_erlang_2_failed.json,"-spec min_changes(S :: unicode:unicode_binary()) -> integer().
min_changes(S) ->
    B = binary:bin_to_list(S),
    CountChanges = fun
        (Char, {Prev, Changes}) when Char =:= Prev ->
            {Char, Changes};
        (_, {_, Changes}) ->
            {_, Changes + 1}
    end,
    {_, MinChanges} = lists:foldl(CountChanges, {hd(B), 0}, tl(B)),
    MinChanges div 2."
erlang,compile_error,"Line 11: Char 5: function fst/1 undefined
%   11|     fst(GroupCount).
%     |     ^",../questions/Medium\minimum-number-of-groups-to-create-a-valid-assignment\responses\Erlang\response_erlang_0_failed.json,"-spec min_groups_for_valid_assignment(Nums :: [integer()]) -> integer().
min_groups_for_valid_assignment(Nums) ->
    Counts = lists:foldl(fun(X, Acc) -> maps:update_with(X, fun(C) -> C + 1 end, 1, Acc) end, #{}, Nums),
    SortedCounts = lists:sort(maps:values(Counts)),
    GroupCount = lists:foldl(fun(C, {Groups, PrevCount}) ->
                                 if
                                     C == PrevCount -> {Groups, C};
                                     true -> {Groups + 1, C}
                                 end
                             end, {0, -1}, SortedCounts),
    fst(GroupCount)."
erlang,compile_error,"Line 10: Char 24: illegal guard expression
%   10| queue(_, _, Q, _) when queue:is_empty(Q) ->
%     |                        ^",../questions/Medium\minimum-number-of-operations-to-make-x-and-y-equal\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_operations_to_make_equal(X :: integer(), Y :: integer()) -> integer().
minimum_operations_to_make_equal(X, Y) ->
    queue(X, Y, queue:new()).

queue(X, Y, Q) when X == Y ->
    0;
queue(X, Y, Q) ->
    queue(X, Y, queue:in({X, 0}, Q), #{X => true}).

queue(_, _, Q, _) when queue:is_empty(Q) ->
    -1; % Should never happen
queue(X, Y, Q, Visited) ->
    {value, {{CX, Ops}, Q1}} = queue:out(Q),
    NewOps = Ops + 1,
    NextStates = [{CX + 1, NewOps}, {CX - 1, NewOps}] ++
        (case CX rem 11 == 0 of true -> [{CX div 11, NewOps}]; false -> [] end) ++
        (case CX rem 5 == 0 of true -> [{CX div 5, NewOps}]; false -> [] end),
    FoldFun = fun({NextX, Ops}, {QAcc, VisitedAcc}) ->
                  case maps:is_key(NextX, VisitedAcc) of
                      false when NextX == Y -> throw(Ops);
                      false -> {queue:in({NextX, Ops}, QAcc), maps:put(NextX, true, VisitedAcc)};
                      true -> {QAcc, VisitedAcc}
                  end
              end,
    try lists:foldl(FoldFun, {Q1, Visited}, NextStates)
    catch
        C:Ops -> Ops
    end."
erlang,compile_error,"Line 14: Char 52: variable 'Acc' is unbound
%   14|                               {$5, $0} when length(Acc) > 1 -> CheckSpecial(T, H, Ops + 1, min(Min, Ops + 1));
%     |                                                    ^",../questions/Medium\minimum-operations-to-make-a-special-number\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_operations(Num :: unicode:unicode_binary()) -> integer().
minimum_operations(Num) ->
    Str = unicode:characters_to_list(Num),
    MinOps = fun(MinOps, [], _Acc) -> MinOps;
                (MinOps, [H | T], Acc) when H =:= $0; H =:= $2; H =:= $5; H =:= $7 -> MinOps(T, [H | Acc]);
                (MinOps, [_ | T], Acc) -> MinOps(T, Acc) + 1
             end,
    CheckSpecial = fun(CheckSpecial, [], _Last, _Ops, Min) -> Min;
                      (CheckSpecial, [H | T], Last, Ops, Min) when H =:= $0; H =:= $2; H =:= $5; H =:= $7 ->
                          case {H, Last} of
                              {$2, $5} -> CheckSpecial(T, H, Ops + 1, min(Min, Ops + 1));
                              {$7, $5} -> CheckSpecial(T, H, Ops + 1, min(Min, Ops + 1));
                              {$0, $0} -> CheckSpecial(T, H, Ops + 1, Min);
                              {$5, $0} when length(Acc) > 1 -> CheckSpecial(T, H, Ops + 1, min(Min, Ops + 1));
                              _ -> CheckSpecial(T, H, Ops + 1, Min)
                          end;
                      (CheckSpecial, [_ | T], Last, Ops, Min) -> CheckSpecial(T, Last, Ops, Min)
                   end,
    MinOpsInitial = MinOps(length(Str), Str, []),
    CheckSpecial(length(Str), lists:reverse(Str), $1, 0, MinOpsInitial)."
erlang,compile_error,"Line 4: Char 27: syntax error before: 0
%    4|     RequiredEndings = [[${0}, ${0}], [${2}, ${5}], [${5}, ${0}], [${7}, ${5}]],
%     |                           ^
Line 1: Char 2: spec for undefined function minimum_operations/1
%    1| -spec minimum_operations(Num :: unicode:unicode_binary()) -> integer().
%     |  ^
Line 35: Char 13: function minimum_operations/1 undefined
%   35|       Ret = minimum_operations(Param_1),
%     |             ^",../questions/Medium\minimum-operations-to-make-a-special-number\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_operations(Num :: unicode:unicode_binary()) -> integer().
minimum_operations(Num) ->
    Str = unicode:characters_to_list(Num),
    RequiredEndings = [[${0}, ${0}], [${2}, ${5}], [${5}, ${0}], [${7}, ${5}]],
    MinOperations = lists:foldl(
        fun(Ending, Acc) ->
            Ops = find_min_operations(Str, Ending, length(Str), 0),
            min(Ops, Acc)
        end,
        length(Str),
        RequiredEndings),
    MinOperations.

find_min_operations(_, [], Ops, Found) -> Ops - Found;
find_min_operations([], _, Ops, _) -> Ops;
find_min_operations([H|T], [E|Es], Ops, Found) when H == E ->
    find_min_operations(T, Es, Ops, Found + 1);
find_min_operations([_|T], Ending, Ops, Found) ->
    find_min_operations(T, Ending, Ops - 1, Found)."
erlang,compile_error,"Line 6: Char 18: illegal guard expression
%    6|         Max1 =:= lists:last(Nums1) andalso Max2 =:= lists:last(Nums2) -> 0;
%     |                  ^
Line 6: Char 53: illegal guard expression
%    6|         Max1 =:= lists:last(Nums1) andalso Max2 =:= lists:last(Nums2) -> 0;
%     |                                                     ^
Line 10: Char 67: illegal guard expression
%   10|             NeededSwaps1 = if SwapMax1 > Max2 orelse SwapMax1 =:= lists:last(Nums2) -> true; true -> false end,
%     |                                                                   ^
Line 11: Char 67: illegal guard expression
%   11|             NeededSwaps2 = if SwapMax2 > Max1 orelse SwapMax2 =:= lists:last(Nums1) -> true; true -> false end,
%     |                                                                   ^",../questions/Medium\minimum-operations-to-maximize-last-elements-in-arrays\responses\Erlang\response_erlang_1_failed.json,"-spec min_operations(Nums1 :: [integer()], Nums2 :: [integer()]) -> integer().
min_operations(Nums1, Nums2) ->
    Max1 = lists:max(Nums1),
    Max2 = lists:max(Nums2),
    if 
        Max1 =:= lists:last(Nums1) andalso Max2 =:= lists:last(Nums2) -> 0;
        true ->
            SwapMax1 = lists:max([lists:nth(Index, Nums2) || Index <- lists:seq(1, length(Nums1)), lists:nth(Index, Nums1) =:= Max1]),
            SwapMax2 = lists:max([lists:nth(Index, Nums1) || Index <- lists:seq(1, length(Nums2)), lists:nth(Index, Nums2) =:= Max2]),
            NeededSwaps1 = if SwapMax1 > Max2 orelse SwapMax1 =:= lists:last(Nums2) -> true; true -> false end,
            NeededSwaps2 = if SwapMax2 > Max1 orelse SwapMax2 =:= lists:last(Nums1) -> true; true -> false end,
            case {NeededSwaps1, NeededSwaps2} of
                {true, true} -> 1;
                _ -> -1
            end
    end."
erlang,compile_error,"Line 15: Char 57: syntax error before: '|'
%   15|     lists:reverse(foldl(fun(Elem, [H|T]) -> [F(Elem,H)|H|T] end, [Acc0], List)).
%     |                                                         ^
Line 3: Char 12: function scanl/3 undefined
%    3|     Sums = scanl(fun(X, Acc) -> X + Acc end, 0, Nums),
%     |            ^
Line 10: Char 22: function foldl/3 undefined
%   10|             MinLen = foldl(fun(Elem, Acc) -> min(Acc, check(Sums, Elem, Target, TotalSum, N)) end, N+1, Sums),
%     |                      ^",../questions/Medium\minimum-size-subarray-in-infinite-array\responses\Erlang\response_erlang_1_failed.json,"-spec min_size_subarray(Nums :: [integer()], Target :: integer()) -> integer().
min_size_subarray(Nums, Target) ->
    Sums = scanl(fun(X, Acc) -> X + Acc end, 0, Nums),
    TotalSum = hd(lists:reverse(Sums)),
    N = length(Nums),
    if
        TotalSum < Target -> -1; % If total sum is less than target, impossible to find such subarray
        TotalSum == Target -> N; % If total sum is exactly target, return length of the array
        true ->
            MinLen = foldl(fun(Elem, Acc) -> min(Acc, check(Sums, Elem, Target, TotalSum, N)) end, N+1, Sums),
            if MinLen == N + 1 -> -1; true -> MinLen end
    end.

scanl(F, Acc0, List) -> 
    lists:reverse(foldl(fun(Elem, [H|T]) -> [F(Elem,H)|H|T] end, [Acc0], List)).

check(Sums, Elem, Target, TotalSum, N) ->
    Needed = Elem + Target,
    case lists:dropwhile(fun(X) -> X < Needed end, Sums) of
        [Head|_] ->
            Idx = case TotalSum >= Target of
                true -> (N - 1) rem length(Sums);
                false -> 0
            end,
            Min1 = ((N * ((Head - Elem - Target) div TotalSum)) + Idx + 1),
            Min2 = length(Sums) - 1 - (lists:keyfind(Needed, 1, lists:zip(Sums, lists:seq(1, length(Sums))))),
            min(Min1, Min2);
        [] -> N + 1
    end."
erlang,compile_error,"Line 26: Char 36: variable '_' is unbound
%   26|     calculate_sum_distance([{Pos2, _} | Tail], (Acc + NewDist) rem Mod, Mod).
%     |                                    ^",../questions/Medium\movement-of-robots\responses\Erlang\response_erlang_1_failed.json,"-spec sum_distance(Nums :: [integer()], S :: unicode:unicode_binary(), D :: integer()) -> integer().
sum_distance(Nums, S, D) ->
    Positions = lists:zip(Nums, binary_to_list(S)),
    SortedPositions = lists:sort(fun({Pos1, _}, {Pos2, _}) -> Pos1 < Pos2 end, Positions),
    FinalPositions = calculate_positions(SortedPositions, D),
    calculate_sum_distance(FinalPositions, 0, 1000000007).

calculate_positions(Positions, 0) -> Positions;
calculate_positions(Positions, D) ->
    calculate_positions(move_robots(Positions, []), D - 1).

move_robots([], Acc) -> lists:reverse(Acc);
move_robots([{Pos, Dir}], Acc) -> lists:reverse([{Pos + direction(Dir), Dir} | Acc]);
move_robots([{Pos1, $L}, {Pos2, $R} | Tail], Acc) when Pos1 + 1 == Pos2 ->
    move_robots([{Pos2 - 1, $L}, {Pos1 + 1, $R} | Tail], Acc);
move_robots([{Pos, Dir} | Tail], Acc) ->
    move_robots(Tail, [{Pos + direction(Dir), Dir} | Acc]).

direction($L) -> -1;
direction($R) -> 1.

calculate_sum_distance([], _, _) -> 0;
calculate_sum_distance([_], _, _) -> 0;
calculate_sum_distance([{Pos1, _}, {Pos2, _} | Tail], Acc, Mod) ->
    NewDist = (Pos2 - Pos1) rem Mod,
    calculate_sum_distance([{Pos2, _} | Tail], (Acc + NewDist) rem Mod, Mod)."
erlang,compile_error,"Line 3: Char 32: syntax error before: 'bxor'
%    3|     lists:foldl(fun(X, Acc) -> bxor(X, Acc) end, 0, Derived) =:= hd(Derived).
%     |                                ^
Line 1: Char 2: spec for undefined function does_valid_array_exist/1
%    1| -spec does_valid_array_exist(Derived :: [integer()]) -> boolean().
%     |  ^
Line 19: Char 13: function does_valid_array_exist/1 undefined
%   19|       Ret = does_valid_array_exist(Param_1),
%     |             ^",../questions/Medium\neighboring-bitwise-xor\responses\Erlang\response_erlang_0_failed.json,"-spec does_valid_array_exist(Derived :: [integer()]) -> boolean().
does_valid_array_exist(Derived) ->
    lists:foldl(fun(X, Acc) -> bxor(X, Acc) end, 0, Derived) =:= hd(Derived)."
erlang,compile_error,"Line 3: Char 39: syntax error before: 'bxor'
%    3|     lists:foldl(fun(X, Acc) -> erlang:bxor(X, Acc) end, 0, Derived) =:= hd(Derived).
%     |                                       ^
Line 1: Char 2: spec for undefined function does_valid_array_exist/1
%    1| -spec does_valid_array_exist([integer()]) -> boolean().
%     |  ^
Line 19: Char 13: function does_valid_array_exist/1 undefined
%   19|       Ret = does_valid_array_exist(Param_1),
%     |             ^",../questions/Medium\neighboring-bitwise-xor\responses\Erlang\response_erlang_1_failed.json,"-spec does_valid_array_exist([integer()]) -> boolean().
does_valid_array_exist(Derived) ->
    lists:foldl(fun(X, Acc) -> erlang:bxor(X, Acc) end, 0, Derived) =:= hd(Derived)."
erlang,compile_error,"Line 3: Char 27: syntax error before: 'bxor'
%    3|     Fold = fun(X, Acc) -> bxor(X, Acc) end,
%     |                           ^
Line 1: Char 2: spec for undefined function does_valid_array_exist/1
%    1| -spec does_valid_array_exist([integer()]) -> boolean().
%     |  ^
Line 20: Char 13: function does_valid_array_exist/1 undefined
%   20|       Ret = does_valid_array_exist(Param_1),
%     |             ^",../questions/Medium\neighboring-bitwise-xor\responses\Erlang\response_erlang_2_failed.json,"-spec does_valid_array_exist([integer()]) -> boolean().
does_valid_array_exist(Derived) ->
    Fold = fun(X, Acc) -> bxor(X, Acc) end,
    lists:foldl(Fold, 0, Derived) =:= hd(Derived)."
erlang,compile_error,"Line 3: Char 22: syntax error before: 'when'
%    3|     is_power_of_5(N) when N > 0 ->
%     |                      ^
Line 1: Char 2: spec for undefined function minimum_beautiful_substrings/1
%    1| -spec minimum_beautiful_substrings(S :: unicode:unicode_binary()) -> integer().
%     |  ^
Line 20: Char 25: illegal guard expression
%   20|                         IsPowerOf5(BinaryToInt(Sub)) ->
%     |                         ^
Line 47: Char 13: function minimum_beautiful_substrings/1 undefined
%   47|       Ret = minimum_beautiful_substrings(Param_1),
%     |             ^",../questions/Medium\partition-string-into-minimum-beautiful-substrings\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_beautiful_substrings(S :: unicode:unicode_binary()) -> integer().
minimum_beautiful_substrings(S) ->
    is_power_of_5(N) when N > 0 ->
        lists:member(N, [1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625, 48828125, 244140625, 1220703125, 6103515625, 30517578125]),
    is_power_of_5(_) -> false,
    
    binary_to_int(B) -> 
        list_to_integer(binary_to_list(B), 2),

    dp(S, is_power_of_5, binary_to_int, fun(X) -> X end, 16#FFFFFFFF).

dp(<<>>, _, _, _, _) -> 0;
dp(S, IsPowerOf5, BinaryToInt, Min, Cache) ->
    case Cache of
        16#FFFFFFFF ->
            MinResult = lists:foldl(
                fun (I, Acc) ->
                    Sub = binary:part(S, {0, I}),
                    if 
                        IsPowerOf5(BinaryToInt(Sub)) ->
                            Result = dp(binary:part(S, {I, byte_size(S) - I}), IsPowerOf5, BinaryToInt, Min, 16#FFFFFFFF),
                            if 
                                Result >= 0 -> Min(Acc, Result + 1);
                                true -> Acc
                            end;
                        true -> Acc
                    end
                end, Cache, lists:seq(1, byte_size(S))),
            if MinResult == Cache -> -1; true -> MinResult end;
        _ -> Cache
    end."
erlang,compile_error,"Line 8: Char 21: illegal guard expression
%    8|         NewAcc = if lists:member(0, NewPow) -> Acc + 1; true -> Acc end,
%     |                     ^",../questions/Medium\partition-string-into-minimum-beautiful-substrings\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_beautiful_substrings(S :: unicode:unicode_binary()) -> integer().
minimum_beautiful_substrings(S) ->
    {_, Result} = lists:foldl(fun(X, {Pow, Acc}) ->
        NewPow = case X of
            $0 -> [0 | Pow];
            $1 -> [1 | lists:map(fun(Y) -> (Y*2) rem 5 end, Pow)] ++ [1]
        end,
        NewAcc = if lists:member(0, NewPow) -> Acc + 1; true -> Acc end,
        {lists:usort(NewPow), NewAcc}
    end, {[], 0}, binary_to_list(S)),
    case lists:member(0, lists:foldl(fun(X, Acc) -> [X+1 | Acc] end, [], Result)) of
        true -> lists:min(Result);
        false -> -1
    end."
erlang,compile_error,"Line 3: Char 24: syntax error before: '->'
%    3|     is_beautiful(<<>>) -> false;
%     |                        ^
Line 1: Char 2: spec for undefined function minimum_beautiful_substrings/1
%    1| -spec minimum_beautiful_substrings(S :: unicode:unicode_binary()) -> integer().
%     |  ^
Line 38: Char 13: function minimum_beautiful_substrings/1 undefined
%   38|       Ret = minimum_beautiful_substrings(Param_1),
%     |             ^",../questions/Medium\partition-string-into-minimum-beautiful-substrings\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_beautiful_substrings(S :: unicode:unicode_binary()) -> integer().
minimum_beautiful_substrings(S) ->
    is_beautiful(<<>>) -> false;
    is_beautiful(Bin) ->
        {ok, N} = string:to_integer(binary_to_list(Bin), 2),
        lists:any(fun(X) -> X == N end, [1 | [5 bsl X || X <- lists:seq(0, 20)]]),

    min_splits(S, 1, byte_size(S), is_beautiful).

min_splits(_, _, 0, _) -> -1;
min_splits(S, Start, Len, CheckFun) when Len >= Start ->
    Sub = binary:part(S, {0, Start}),
    case CheckFun(Sub) of
        true ->
            Rest = binary:part(S, {Start, byte_size(S) - Start}),
            case min_splits(Rest, 1, byte_size(Rest), CheckFun) of
                -1 -> min_splits(S, Start + 1, Len, CheckFun);
                RestSplits -> 1 + RestSplits
            end;
        false -> min_splits(S, Start + 1, Len, CheckFun)
    end;
min_splits(_, _, _, _) -> -1."
erlang,compile_error,"Line 11: Char 5: call to local/imported function is_prime/2 is illegal in guard
%   11|     is_prime(2, X) andalso is_prime(2, Y) -> prime_pairs(N, X + 1, Acc ++ [[X, Y]]);
%     |     ^
Line 11: Char 28: call to local/imported function is_prime/2 is illegal in guard
%   11|     is_prime(2, X) andalso is_prime(2, Y) -> prime_pairs(N, X + 1, Acc ++ [[X, Y]]);
%     |                            ^",../questions/Medium\prime-pairs-with-target-sum\responses\Erlang\response_erlang_0_failed.json,"-spec is_prime(I :: integer(), N :: integer()) -> boolean().
is_prime(I, N) when I * I > N -> true;
is_prime(I, N) when N rem I == 0 -> false;
is_prime(I, N) -> is_prime(I + 1, N).

-spec prime_pairs(N :: integer(), X :: integer(), Acc :: [[integer()]]) -> [[integer()]].
prime_pairs(N, X, Acc) when X > N div 2 -> Acc;
prime_pairs(N, X, Acc) ->
  Y = N - X,
  if
    is_prime(2, X) andalso is_prime(2, Y) -> prime_pairs(N, X + 1, Acc ++ [[X, Y]]);
    true -> prime_pairs(N, X + 1, Acc)
  end.

-spec find_prime_pairs(N :: integer()) -> [[integer()]].
find_prime_pairs(N) ->
  prime_pairs(N, 2, [])."
erlang,compile_error,"Line 23: Char 5: call to local/imported function is_prime/1 is illegal in guard
%   23|     is_prime(Current) andalso is_prime(Y) -> NewAcc = Acc ++ [[Current, Y]];
%     |     ^
Line 23: Char 31: call to local/imported function is_prime/1 is illegal in guard
%   23|     is_prime(Current) andalso is_prime(Y) -> NewAcc = Acc ++ [[Current, Y]];
%     |                               ^",../questions/Medium\prime-pairs-with-target-sum\responses\Erlang\response_erlang_1_failed.json,"-spec is_prime(N :: integer()) -> boolean().
is_prime(1) -> false;
is_prime(2) -> true;
is_prime(N) -> is_prime_helper(N, 2).

-spec is_prime_helper(N :: integer(), Current :: integer()) -> boolean().
is_prime_helper(N, Current) when Current * Current > N -> true;
is_prime_helper(N, Current) ->
  if
    N rem Current == 0 -> false;
    true -> is_prime_helper(N, Current + 1)
  end.

-spec find_prime_pairs(N :: integer()) -> [[integer()]].
find_prime_pairs(N) ->
  find_prime_pairs(N, 2, []).

-spec find_prime_pairs(N :: integer(), Current :: integer(), Acc :: [[integer()]]) -> [[integer()]].
find_prime_pairs(N, Current, Acc) when Current > N div 2 -> Acc;
find_prime_pairs(N, Current, Acc) ->
  Y = N - Current,
  if
    is_prime(Current) andalso is_prime(Y) -> NewAcc = Acc ++ [[Current, Y]];
    true -> NewAcc = Acc
  end,
  find_prime_pairs(N, Current + 1, NewAcc)."
erlang,compile_error,"Line 6: Char 16: type variable 'N' is only used once (is unbound)
%    6| -spec is_prime(N, Divisor) -> boolean().
%     |                ^
Line 6: Char 19: type variable 'Divisor' is only used once (is unbound)
%    6| -spec is_prime(N, Divisor) -> boolean().
%     |                   ^
Line 22: Char 9: call to local/imported function is_prime/1 is illegal in guard
%   22|         is_prime(Current) andalso is_prime(Y) -> find_pairs(Current + 1, N, [[Current, Y] | Acc]);
%     |         ^
Line 22: Char 35: call to local/imported function is_prime/1 is illegal in guard
%   22|         is_prime(Current) andalso is_prime(Y) -> find_pairs(Current + 1, N, [[Current, Y] | Acc]);
%     |                                   ^",../questions/Medium\prime-pairs-with-target-sum\responses\Erlang\response_erlang_2_failed.json,"-spec is_prime(N :: integer()) -> boolean().
is_prime(2) -> true;
is_prime(N) when N < 2; N rem 2 == 0 -> false;
is_prime(N) -> is_prime(N, 3).

-spec is_prime(N, Divisor) -> boolean().
is_prime(N, Divisor) when Divisor * Divisor > N -> true;
is_prime(N, Divisor) ->
    if N rem Divisor == 0 -> false;
       true -> is_prime(N, Divisor + 2)
    end.

-spec find_prime_pairs(N :: integer()) -> [[integer()]].
find_prime_pairs(N) ->
    find_pairs(1, N, []).

-spec find_pairs(Current :: integer(), N :: integer(), Acc :: [[integer()]]) -> [[integer()]].
find_pairs(Current, N, Acc) when Current > N div 2 -> lists:reverse(Acc);
find_pairs(Current, N, Acc) ->
    Y = N - Current,
    if
        is_prime(Current) andalso is_prime(Y) -> find_pairs(Current + 1, N, [[Current, Y] | Acc]);
        true -> find_pairs(Current + 1, N, Acc)
    end."
erlang,compile_error,"Line 26: Char 85: syntax error before: ')'
%   26|             {NewMinSub, {NewCount - (if C =:= 1 andalso NewCount > K -> 1; true -> 0), NewStartIdx}}
%     |                                                                                     ^
Line 1: Char 2: spec for undefined function shortest_beautiful_substring/2
%    1| -spec shortest_beautiful_substring(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().
%     |  ^
Line 46: Char 13: function shortest_beautiful_substring/2 undefined
%   46|       Ret = shortest_beautiful_substring(Param_1, Param_2),
%     |             ^",../questions/Medium\shortest-and-lexicographically-smallest-beautiful-string\responses\Erlang\response_erlang_1_failed.json,"-spec shortest_beautiful_substring(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().
shortest_beautiful_substring(S, K) ->
    Len = byte_size(S),
    {Result, _} = lists:foldl(
        fun (Idx, {MinSub, {Count, StartIdx}}) when Idx < Len ->
            C = binary:at(S, Idx),
            NewCount = Count + if C =:= 1 -> 1; true -> 0 end,
            {NewStartIdx, NewMinSub} = if NewCount < K ->
                {StartIdx, MinSub};
            NewCount == K ->
                Sub = binary:part(S, StartIdx, Idx - StartIdx + 1),
                case MinSub of
                    <<>> -> {Idx + 1 - K, Sub};
                    _ -> 
                        MinLen = byte_size(MinSub),
                        SubLen = byte_size(Sub),
                        if SubLen < MinLen; (SubLen == MinLen andalso Sub < MinSub) ->
                            {Idx + 1 - K, Sub};
                        true ->
                            {StartIdx + 1, MinSub}
                        end
                end;
            true ->
                {StartIdx + 1, MinSub}
            end,
            {NewMinSub, {NewCount - (if C =:= 1 andalso NewCount > K -> 1; true -> 0), NewStartIdx}}
        end, {<<>>, {0, 0}}, lists:seq(0, Len - 1)),
    Result."
erlang,compile_error,"Line 30: Char 6: variable 'NewMin' unsafe in 'case' (line 34, column 24)
%   30|     {NewMin, NewLen} = case NewLength of
%     |      ^
Line 32: Char 9: variable 'L' unsafe in 'case' (line 27, column 17)
%   32|         L when L =< byte_size(Window) + 1 ->
%     |         ^
Line 39: Char 46: variable 'NewMin' unsafe in 'case' (line 34, column 24)
%   39|     find_shortest_beautiful(T, K, NewWindow, NewMin, NewLen).
%     |                                              ^",../questions/Medium\shortest-and-lexicographically-smallest-beautiful-string\responses\Erlang\response_erlang_2_failed.json,"-spec shortest_beautiful_substring(S :: binary(), K :: integer()) -> binary().
shortest_beautiful_substring(S, K) ->
    {_, Result, _} = binary:foldl(
        fun(Byte, {Count, Acc, Min}) when Byte =:= 1 ->
                NewCount = Count + 1,
                {NewCount, [Byte | Acc], case NewCount of K -> lists:reverse(Acc); _ -> Min end};
           (Byte, {Count, Acc, Min}) ->
                {Count, [Byte | Acc], Min}
        end,
        {0, [], <<>>},
        S
    ),
    find_shortest_beautiful(binary:bin_to_list(S), K, Result, <<>>, undefined).

find_shortest_beautiful(_, _, Result, Min, undefined) when Result =/= <<>> -> Result;
find_shortest_beautiful(_, _, _, Min, _) -> Min;
find_shortest_beautiful([], _, _, Min, _) -> Min;
find_shortest_beautiful([H | T], K, Window, Min, Length) ->
    NewWindow = case byte_size(Window) of
        Len when Len < K -> Window;
        _ -> binary:part(Window, 1, byte_size(Window) - 1)
    end,
    NewLength = case H of
        1 -> case Length of
                undefined -> K;
                L -> L - 1
             end;
        _ -> Length
    end,
    {NewMin, NewLen} = case NewLength of
        undefined -> {Min, NewLength};
        L when L =< byte_size(Window) + 1 ->
            NewMin = case Min of
                <<>> -> binary:part([H | T], 0, L);
                _ -> Min
            end,
            {NewMin, L}
    end,
    find_shortest_beautiful(T, K, NewWindow, NewMin, NewLen)."
erlang,compile_error,"Line 23: Char 51: syntax error before: '('
%   23|         [MaxPrefix|_] -> <<A/binary, B/binary-part(B, MaxPrefix, BLen-MaxPrefix)>>
%     |                                                   ^
Line 9: Char 10: function merge_two/2 undefined
%    9|     AB = merge_two(A,B),
%     |          ^
Line 10: Char 11: function merge_two/2 undefined
%   10|     ABC = merge_two(AB,C),
%     |           ^",../questions/Medium\shortest-string-that-contains-three-strings\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_string(A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), C :: unicode:unicode_binary()) -> unicode:unicode_binary().
minimum_string(A, B, C) ->
    Permutations = [[A,B,C], [A,C,B], [B,A,C], [B,C,A], [C,A,B], [C,B,A]],
    Lists = lists:map(fun(X) -> merge_strings(X) end, Permutations),
    Sorted = lists:sort(fun(X,Y) -> {length(X), X} < {length(Y), Y} end, Lists),
    hd(Sorted).

merge_strings([A,B,C]) ->
    AB = merge_two(A,B),
    ABC = merge_two(AB,C),
    ABC.

merge_two(A, B) when A =:= B -> A;
merge_two(A, B) ->
    {ALen, BLen} = {byte_size(A), byte_size(B)},
    Prefix = lists:dropwhile(fun(I) -> 
                                SubA = binary_part(A, ALen-I, I),
                                SubB = binary_part(B, 0, I),
                                SubA =/= SubB
                             end, lists:seq(1, min(ALen, BLen))),
    case Prefix of
        [] -> <<A/binary, B/binary>>;
        [MaxPrefix|_] -> <<A/binary, B/binary-part(B, MaxPrefix, BLen-MaxPrefix)>>
    end."
erlang,compile_error,"Line 18: Char 30: syntax error before: '('
%   18|     <<A/binary, B/binary-part(B, Prefix)/binary>>.
%     |                              ^
Line 9: Char 10: function merge_two/2 undefined
%    9|     AB = merge_two(A,B),
%     |          ^
Line 10: Char 11: function merge_two/2 undefined
%   10|     ABC = merge_two(AB,C),
%     |           ^",../questions/Medium\shortest-string-that-contains-three-strings\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_string(A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), C :: unicode:unicode_binary()) -> unicode:unicode_binary().
minimum_string(A, B, C) ->
    Permutations = [[A,B,C], [A,C,B], [B,A,C], [B,C,A], [C,A,B], [C,B,A]],
    Lists = lists:map(fun(X) -> merge_strings(X) end, Permutations),
    Sorted = lists:sort(fun(X,Y) -> {length(X), X} < {length(Y), Y} end, Lists),
    hd(Sorted).

merge_strings([A,B,C]) ->
    AB = merge_two(A,B),
    ABC = merge_two(AB,C),
    ABC.

merge_two(A, B) ->
    ALen = byte_size(A),
    BLen = byte_size(B),
    Prefix = lists:max([0| [I || I <- lists:seq(1, min(ALen, BLen)),
                             binary_part(A, size(A) - I, I) == binary_part(B, 0, I)]]),
    <<A/binary, B/binary-part(B, Prefix)/binary>>."
erlang,compile_error,"Line 6: Char 16: illegal guard expression
%    6|             if Vowels(C) -> {[C | Vs], Cs};
%     |                ^
Line 13: Char 16: illegal guard expression
%   13|             if Vowels(hd(Acc)) -> [hd(SortedVowels) | tl(Acc)];
%     |                ^",../questions/Medium\sort-vowels-in-a-string\responses\Erlang\response_erlang_0_failed.json,"-spec sort_vowels(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
sort_vowels(S) ->
    Vowels = fun(C) -> lists:member(C, ""aeiouAEIOU"") end,
    {VowelChars, ConsonantMap} = lists:foldl(
        fun(C, {Vs, Cs}) ->
            if Vowels(C) -> {[C | Vs], Cs};
               true -> {Vs, [C | Cs]}
            end
        end, {[], []}, unicode:characters_to_list(S)),
    SortedVowels = lists:sort(VowelChars),
    lists:foldr(
        fun(C, Acc) ->
            if Vowels(hd(Acc)) -> [hd(SortedVowels) | tl(Acc)];
               true -> [C | Acc]
            end
        end, ConsonantMap, unicode:characters_to_list(S))."
erlang,compile_error,"Line 5: Char 29: illegal guard expression
%    5|         fun(C, {V, O}) when IsVowel(C) -> {[C | V], O};
%     |                             ^
Line 10: Char 26: illegal guard expression
%   10|         fun(C, Acc) when IsVowel(C) -> [lists:nth(1, SortedVowels) | tl(SortedVowels)], Acc;
%     |                          ^",../questions/Medium\sort-vowels-in-a-string\responses\Erlang\response_erlang_1_failed.json,"-spec sort_vowels(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
sort_vowels(S) ->
    IsVowel = fun(C) -> lists:member(C, ""aeiouAEIOU"") end,
    {Vowels, Others} = lists:foldl(
        fun(C, {V, O}) when IsVowel(C) -> {[C | V], O};
           (C, {V, O}) -> {V, [C | O]}
        end, {[], []}, unicode:characters_to_list(S)),
    SortedVowels = lists:reverse(lists:sort(Vowels)),
    lists:reverse(lists:foldl(
        fun(C, Acc) when IsVowel(C) -> [lists:nth(1, SortedVowels) | tl(SortedVowels)], Acc;
           (C, Acc) -> [C | Acc]
        end, SortedVowels, Others))."
erlang,compile_error,"Line 25: Char 70: syntax error before: ')'
%   25|                                           end, 0, lists:seq(0, N - 1)),
%     |                                                                      ^
Line 1: Char 2: spec for undefined function special_perm/1
%    1| -spec special_perm(Nums :: [integer()]) -> integer().
%     |  ^
Line 47: Char 13: function special_perm/1 undefined
%   47|       Ret = special_perm(Param_1),
%     |             ^",../questions/Medium\special-permutations\responses\Erlang\response_erlang_0_failed.json,"-spec special_perm(Nums :: [integer()]) -> integer().
special_perm(Nums) ->
    N = length(Nums),
    SortedNums = lists:sort(Nums),
    DP = lists:duplicate(1 bsl N, 0),
    Mod = 1000000007,

    F = fun(F, I, Mask, DP) ->
            case I of
                N -> 1;
                _ ->
                    Acc = lists:foldl(fun(J, Acc) ->
                                          if
                                              Mask band (1 bsl J) =/= 0 ->
                                                  Acc;
                                              true ->
                                                  if
                                                      (I == 0) orelse
                                                      (element(J + 1, SortedNums) rem element(I, SortedNums) == 0) orelse
                                                      (element(I, SortedNums) rem element(J + 1, SortedNums) == 0) ->
                                                          (Acc + F(F, I + 1, Mask bor (1 bsl J), DP)) rem Mod;
                                                      true ->
                                                          Acc
                                                  end
                                          end, 0, lists:seq(0, N - 1)),
                    DP#put({Mask, I}, Acc),
                    Acc
            end
    end,

    F(F, 0, 0, DP)."
erlang,compile_error,"Line 8: Char 56: syntax error before: State
%    8|     CalcDP = fun CalcDP(0, _) -> 1; (Pos, State) -> DP#State end,
%     |                                                        ^
Line 1: Char 2: spec for undefined function special_perm/1
%    1| -spec special_perm(Nums :: [integer()]) -> integer().
%     |  ^
Line 52: Char 13: function special_perm/1 undefined
%   52|       Ret = special_perm(Param_1),
%     |             ^",../questions/Medium\special-permutations\responses\Erlang\response_erlang_1_failed.json,"-spec special_perm(Nums :: [integer()]) -> integer().
special_perm(Nums) ->
    Sorted = lists:sort(Nums),
    N = length(Sorted),
    Mod = 1000000007,
    DP = lists:duplicate(1 bsl N, -1),
    
    CalcDP = fun CalcDP(0, _) -> 1; (Pos, State) -> DP#State end,
    
    UpdateDP = fun UpdateDP(Pos, State, Value) ->
        lists:update_at(State, Value, DP)
    end,
    
    Solve = fun Solve(_, 0) -> 1;
                 Solve(I, State) ->
                     case CalcDP(I, State) of
                         -1 -> 
                             Sum = lists:foldl(fun(J, Acc) ->
                                                   if
                                                       State band (1 bsl J) == 0 ->
                                                           Prev = if I == 1 -> true;
                                                                     true -> (element(J, Sorted) rem element(I - 1, Sorted) == 0) or (element(I - 1, Sorted) rem element(J, Sorted) == 0)
                                                                   end,
                                                           if Prev -> (Acc + Solve(I - 1, State bor (1 bsl J))) rem Mod;
                                                              true -> Acc
                                                           end;
                                                       true -> Acc
                                                   end
                                               end, 0, lists:seq(0, N - 1)),
                             UpdateDP(I, State, Sum),
                             Sum;
                         Res -> Res
                     end
             end,
    
    Solve(N, 0)."
erlang,compile_error,"Line 9: Char 44: illegal guard expression
%    9|                              Penalty = if (lists:nth(Pi, Nums) rem 2) /= (N rem 2) -> X;
%     |                                            ^",../questions/Medium\visit-array-positions-to-maximize-score\responses\Erlang\response_erlang_1_failed.json,"-spec max_score(Nums :: [integer()], X :: integer()) -> integer().
max_score(Nums, X) ->
    max_score_dp(Nums, X, [{0, hd(Nums)}], 1, hd(Nums)).

max_score_dp(_, _, Acc, _, MaxScore) when Acc == [] -> MaxScore;
max_score_dp(Nums, X, [{I, Score} | Rest], J, MaxScore) when J < length(Nums) ->
    N = lists:nth(J, Nums),
    NewAcc = lists:foldl(fun({Pi, PScore}, Acc) ->
                             Penalty = if (lists:nth(Pi, Nums) rem 2) /= (N rem 2) -> X;
                                       true -> 0
                             end,
                             [{J, PScore + N - Penalty} | Acc]
                         end, Rest, [{I, Score}]),
    {NewMax, PrunedAcc} = prune_and_find_max(NewAcc, MaxScore),
    max_score_dp(Nums, X, PrunedAcc, J + 1, NewMax);
max_score_dp(_, _, _, _, MaxScore) -> MaxScore.

prune_and_find_max(Acc, Max) ->
    Sorted = lists:sort(fun({_, S1}, {_, S2}) -> S1 > S2 end, Acc),
    Pruned = prune(Sorted, []),
    MaxScore = case Pruned of
                   [{_, S} | _] -> max(S, Max);
                   [] -> Max
               end,
    {MaxScore, Pruned}.

prune([], Acc) -> lists:reverse(Acc);
prune([H = {_, S} | T], Acc) ->
    case Acc of
        [{_, LastS} | _] = _Acc when S =< LastS -> prune(T, Acc);
        _ -> prune(T, [H | Acc])
    end."
erlang,compile_error,"Line 9: Char 19: illegal guard expression
%    9|     Penalty = if (lists:nth(I - 1, Nums) rem 2) /= (N rem 2) -> X; true -> 0 end,
%     |                   ^",../questions/Medium\visit-array-positions-to-maximize-score\responses\Erlang\response_erlang_2_failed.json,"-spec max_score(Nums :: [integer()], X :: integer()) -> integer().
max_score(Nums, X) ->
    find_max_score(Nums, X, 1, hd(Nums), hd(Nums)).

find_max_score(_Nums, _X, _I, MaxScore, _CurrentScore) when _I == length(_Nums) ->
    MaxScore;
find_max_score(Nums, X, I, MaxScore, CurrentScore) ->
    N = lists:nth(I, Nums),
    Penalty = if (lists:nth(I - 1, Nums) rem 2) /= (N rem 2) -> X; true -> 0 end,
    NewScore = CurrentScore + N - Penalty,
    NewMaxScore = max(MaxScore, NewScore),
    find_max_score(Nums, X, I + 1, NewMaxScore, NewScore)."
erlang,runtime_error,"Line 4: exception error: badarg
[{unicode,characters_to_list,
          [<<""alice"">>,1],
          [{error_info,#{module => erl_stdlib_errors}}]},
 {solution,'-is_acronym/2-fun-0-',2,[{file,""solution.erl""},{line,4}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,is_acronym,2,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,24}]},
 {solution,driver,0,[{file,""solution.erl""},{line,10}]},
 {solution,start,0,[{file,""solution.erl""},{line,41}]},
 {init,start_em,1,[]}]",../questions/Easy\check-if-a-string-is-an-acronym-of-words\responses\Erlang\response_erlang_0_failed.json,"-spec is_acronym(Words :: [unicode:unicode_binary()], S :: unicode:unicode_binary()) -> boolean().
is_acronym(Words, S) ->
    Acronym = lists:foldl(fun(Word, Acc) -> 
                            [unicode:characters_to_list(Word, 1) | Acc] 
                          end, [], Words),
    lists:reverse(Acronym) == unicode:characters_to_list(S)."
erlang,runtime_error,"Line 29: exception error: undef
[{erlang,byte,""1"",[]},
 {solution,digit_to_int,1,[{file,""solution.erl""},{line,29}]},
 {solution,'-sum_digits/1-fun-0-',2,[{file,""solution.erl""},{line,26}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,is_symmetric,1,[{file,""solution.erl""},{line,22}]},
 {solution,count_symmetric_integers,3,[{file,""solution.erl""},{line,8}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,47}]},
 {solution,driver,0,[{file,""solution.erl""},{line,33}]}]",../questions/Easy\count-symmetric-integers\responses\Erlang\response_erlang_1_failed.json,"-spec count_symmetric_integers(Low :: integer(), High :: integer()) -> integer().
count_symmetric_integers(Low, High) ->
    count_symmetric_integers(Low, High, 0).

count_symmetric_integers(Current, High, Count) when Current > High ->
    Count;
count_symmetric_integers(Current, High, Count) ->
    NewCount = case is_symmetric(Current) of
        true -> Count + 1;
        false -> Count
    end,
    count_symmetric_integers(Current + 1, High, NewCount).

is_symmetric(Number) ->
    Digits = integer_to_list(Number),
    Length = length(Digits),
    if
        Length rem 2 =/= 0 ->
            false;
        true ->
            {FirstHalf, SecondHalf} = lists:split(Length div 2, Digits),
            sum_digits(FirstHalf) =:= sum_digits(SecondHalf)
    end.

sum_digits(Digits) ->
    lists:foldl(fun(Digit, Acc) -> Acc + digit_to_int(Digit) end, 0, Digits).

digit_to_int(DigitChar) ->
    erlang:byte(DigitChar) - 48."
erlang,runtime_error,"Line 10: exception error: {badfun,infinity}
[{solution,minimum_cost,1,[{file,""solution.erl""},{line,10}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,31}]},
 {solution,driver,0,[{file,""solution.erl""},{line,19}]},
 {solution,start,0,[{file,""solution.erl""},{line,48}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\divide-an-array-into-subarrays-with-minimum-cost-i\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_cost(Nums :: [integer()]) -> integer().
minimum_cost(Nums) ->
    N = length(Nums),
    MinCost = fun(MinCost, I, J) when I < N, J < N -> 
                  SubArray1 = lists:nth(I, Nums),
                  SubArray2 = lists:nth(J, Nums),
                  SubArray3 = lists:nth(N, Nums),
                  Cost = SubArray1 + SubArray2 + SubArray3,
                  if I + 1 < J -> MinCost(MinCost, I + 1, J);
                     J + 1 < N -> MinCost(MinCost, 1, J + 1);
                     true -> Cost
                  end;
              (MinCost, _, _) -> MinCost
    end,
    MinCost(infinity, 1, 2)."
erlang,runtime_error,"Line 29: exception error: function_clause
[{lists,reverse,[<<""str"">>],[{file,""lists.erl""},{line,175}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,29}]},
 {solution,driver,0,[{file,""solution.erl""},{line,17}]},
 {solution,start,0,[{file,""solution.erl""},{line,46}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\faulty-keyboard\responses\Erlang\response_erlang_0_failed.json,"-spec final_string(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
final_string(S) ->
    final_string(S, <<>>).

final_string(<<>>, Acc) ->
    Acc;
final_string(<<C, Rest/binary>>, Acc) ->
    case C of
        $i ->
            final_string(Rest, lists:reverse(Acc));
        _ ->
            final_string(Rest, <<Acc/binary, C>>)
    end."
erlang,runtime_error,"Line 15: exception error: {badarity,{#Fun<solution.0.68306875>,
                            [#Fun<solution.0.68306875>,
                             [<<""cd"">>,<<""ac"">>,<<""dc"">>,<<""ca"">>,<<""zz"">>],
                             0]}}
[{solution,maximum_number_of_string_pairs,1,
              [{file,""solution.erl""},{line,15}]},
 {solution,driver,0,[{file,""solution.erl""},{line,19}]},
 {solution,start,0,[{file,""solution.erl""},{line,48}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\find-maximum-number-of-string-pairs\responses\Erlang\response_erlang_2_failed.json,"-spec maximum_number_of_string_pairs(Words :: [unicode:unicode_binary()]) -> integer().
maximum_number_of_string_pairs(Words) ->
    CountPairs = fun CountPairsFun([], Count) -> 
                        Count;
                    CountPairsFun([Word|Rest], Count) ->
                        ReversedWord = lists:reverse(binary_to_list(Word)),
                        case lists:member(ReversedWord, Rest) of
                            true ->
                                FilteredRest = lists:delete(ReversedWord, Rest),
                                CountPairsFun(FilteredRest, Count + 1);
                            false ->
                                CountPairsFun(Rest, Count)
                        end
                end,
    CountPairs(CountPairs, Words, 0)."
erlang,runtime_error,"exception throw: {invalid_user_return_value,{2,[1,0]},""[integer()]""}",../questions/Easy\find-words-containing-character\responses\Erlang\response_erlang_0_failed.json,"-spec find_words_containing(Words :: [unicode:unicode_binary()], X :: char()) -> [integer()].
find_words_containing(Words, X) ->
    lists:foldl(
        fun(Word, {Index, Acc}) ->
            case lists:member(X, binary_to_list(Word)) of
                true -> {Index + 1, [Index|Acc]};
                false -> {Index + 1, Acc}
            end
        end, {0, []}, Words)."
erlang,runtime_error,"Line 16: exception error: badarg
[{erlang,list_to_integer,[""prev""],[{error_info,#{module => erl_erts_errors}}]},
 {solution,last_visited_integers,4,[{file,""solution.erl""},{line,16}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,33}]},
 {solution,driver,0,[{file,""solution.erl""},{line,21}]},
 {solution,start,0,[{file,""solution.erl""},{line,50}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\last-visited-integers\responses\Erlang\response_erlang_0_failed.json,"-spec last_visited_integers(Words :: [unicode:unicode_binary()]) -> [integer()].
last_visited_integers(Words) ->
    last_visited_integers(Words, [], [], 0).

last_visited_integers([], _Nums, Result, _ConsecutivePrev) ->
    lists:reverse(Result);
last_visited_integers([""prev"" | T], Nums, Result, ConsecutivePrev) ->
    case ConsecutivePrev < length(Nums) of
        true ->
            {Value, _} = lists:nthsplit(ConsecutivePrev, lists:reverse(Nums)),
            last_visited_integers(T, Nums, [hd(Value) | Result], ConsecutivePrev + 1);
        false ->
            last_visited_integers(T, Nums, [-1 | Result], ConsecutivePrev + 1)
    end;
last_visited_integers([H | T], Nums, Result, _ConsecutivePrev) ->
    IntValue = list_to_integer(binary_to_list(H)),
    last_visited_integers(T, [IntValue | Nums], Result, 0)."
erlang,runtime_error,"Line 13: exception error: undef
[{lists,nthsplit,[1,[1,2]],[]},
 {solution,last_visited_integers,4,[{file,""solution.erl""},{line,13}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,37}]},
 {solution,driver,0,[{file,""solution.erl""},{line,25}]},
 {solution,start,0,[{file,""solution.erl""},{line,54}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\last-visited-integers\responses\Erlang\response_erlang_1_failed.json,"-spec last_visited_integers(Words :: [unicode:unicode_binary()]) -> [integer()].
last_visited_integers(Words) ->
    last_visited_integers(Words, [], [], 0).

last_visited_integers([], _Nums, Result, _ConsecutivePrev) ->
    lists:reverse(Result);
last_visited_integers([H | T], Nums, Result, ConsecutivePrev) ->
    case binary_to_list(H) of
        ""prev"" ->
            PrevIndex = ConsecutivePrev,
            case length(Nums) > PrevIndex of
                true ->
                    {Value, _} = lists:nthsplit(PrevIndex + 1, lists:reverse(Nums)),
                    last_visited_integers(T, Nums, [hd(Value) | Result], PrevIndex + 1);
                false ->
                    last_visited_integers(T, Nums, [-1 | Result], PrevIndex + 1)
            end;
        _ ->
            IntValue = list_to_integer(binary_to_list(H)),
            last_visited_integers(T, [IntValue | Nums], Result, 0)
    end."
erlang,runtime_error,"Line 11: exception error: badarg
[{erlang,hd,[[]],[{error_info,#{module => erl_erts_errors}}]},
 {solution,last_visited_integers,4,[{file,""solution.erl""},{line,11}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,33}]},
 {solution,driver,0,[{file,""solution.erl""},{line,21}]},
 {solution,start,0,[{file,""solution.erl""},{line,50}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\last-visited-integers\responses\Erlang\response_erlang_2_failed.json,"-spec last_visited_integers(Words :: [unicode:unicode_binary()]) -> [integer()].
last_visited_integers(Words) ->
    last_visited_integers(Words, [], 0, []).

last_visited_integers([], _Nums, _ConsecutivePrev, Acc) ->
    lists:reverse(Acc);
last_visited_integers([H | T], Nums, ConsecutivePrev, Acc) when H =:= <<""prev"">> ->
    case length(Nums) > ConsecutivePrev of
        true ->
            {Value, _} = lists:split(ConsecutivePrev, lists:reverse(Nums)),
            last_visited_integers(T, Nums, ConsecutivePrev + 1, [hd(Value) | Acc]);
        false ->
            last_visited_integers(T, Nums, ConsecutivePrev + 1, [-1 | Acc])
    end;
last_visited_integers([H | T], Nums, _ConsecutivePrev, Acc) ->
    IntValue = list_to_integer(binary_to_list(H)),
    last_visited_integers(T, [IntValue | Nums], 0, Acc)."
erlang,runtime_error,"Line 24: exception error: function_clause
[{lists,nthtail_1,[1,[]],[{file,""lists.erl""},{line,218}]},
 {solution,make_palindrome_helper,3,[{file,""solution.erl""},{line,24}]},
 {solution,make_smallest_palindrome,1,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,44}]},
 {solution,driver,0,[{file,""solution.erl""},{line,32}]},
 {solution,start,0,[{file,""solution.erl""},{line,61}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\lexicographically-smallest-palindrome\responses\Erlang\response_erlang_1_failed.json,"-spec make_smallest_palindrome(S :: unicode:unicode_binary()) -> unicode:unicode_binary().
make_smallest_palindrome(S) ->
    List = binary_to_list(S),
    PalindromeList = make_palindrome(List),
    list_to_binary(PalindromeList).

make_palindrome(List) ->
    make_palindrome_helper(List, 1, length(List)).

make_palindrome_helper(List, Left, Right) when Left >= Right -> List;
make_palindrome_helper(List, Left, Right) ->
    LeftChar = lists:nth(Left, List),
    RightChar = lists:nth(Right, List),
    UpdatedList = if
        LeftChar =< RightChar ->
            lists:sublist(List, Left - 1) ++
            [LeftChar] ++
            lists:nthtail(Left, lists:sublist(List, Right - Left - 1)) ++
            [LeftChar] ++
            lists:nthtail(Right, List);
        true ->
            lists:sublist(List, Left - 1) ++
            [RightChar] ++
            lists:nthtail(Left, lists:sublist(List, Right - Left - 1)) ++
            [RightChar] ++
            lists:nthtail(Right, List)
    end,
    make_palindrome_helper(UpdatedList, Left + 1, Right - 1)."
erlang,runtime_error,"Line 14: exception error: function_clause
[{lists,nth_1,[1,[]],[{file,""lists.erl""},{line,202}]},
 {solution,'-maximum_triplet_value/1-fun-1-',3,
              [{file,""solution.erl""},{line,14}]},
 {lists,foldl_1,3,[{file,""lists.erl""},{line,1599}]},
 {solution,maximum_triplet_value,1,[{file,""solution.erl""},{line,12}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,38}]},
 {solution,driver,0,[{file,""solution.erl""},{line,26}]},
 {solution,start,0,[{file,""solution.erl""},{line,55}]},
 {init,start_em,1,[]}]",../questions/Easy\maximum-value-of-an-ordered-triplet-i\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_triplet_value(Nums :: [integer()]) -> integer().
maximum_triplet_value(Nums) ->
    Lists = lists,
    MaxK = lists:duplicate(length(Nums), 0),
    MaxJ = lists:duplicate(length(Nums), 0),
    
    %% Calculate max value for k for every index
    MaxK1 = lists:foldl(fun(X, [H|T]) -> [lists:max([X, H]) | T] end, MaxK, lists:reverse(Nums)),
    MaxK2 = lists:reverse(MaxK1),
    
    %% Calculate max value for (i-j)*k for every index
    {_, _, MaxValue} = lists:foldl(
        fun(X, {I, [H|T], Max}) ->
            NewMax = lists:max([Max, (X - H) * lists:nth(I + 2, MaxK2)]),
            {I + 1, [lists:max([X, H]) | T], NewMax}
        end,
        {1, MaxJ, 0},
        Nums
    ),
    
    %% Return max value or 0 if all values are negative
    lists:max([0, MaxValue])."
erlang,runtime_error,"Line 12: exception error: badarith
[{erlang,'-',[infinity],[{error_info,#{module => erl_erts_errors}}]},
 {solution,maximum_triplet_value,1,[{file,""solution.erl""},{line,12}]},
 {solution,driver,0,[{file,""solution.erl""},{line,18}]},
 {solution,start,0,[{file,""solution.erl""},{line,47}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\maximum-value-of-an-ordered-triplet-i\responses\Erlang\response_erlang_1_failed.json,"-spec maximum_triplet_value(Nums :: [integer()]) -> integer().
maximum_triplet_value(Nums) ->
    %% Initialize the maximum value as negative infinity (or a very small number)
    Max = lists:foldl(fun(I, Acc) ->
                          lists:foldl(fun(J, AccJ) ->
                                          lists:foldl(fun(K, AccK) ->
                                                          Val = (lists:nth(I, Nums) - lists:nth(J, Nums)) * lists:nth(K, Nums),
                                                          %% Update maximum value if this triplet's value is greater
                                                          max(AccK, Val)
                                                      end, AccJ, lists:seq(J+1, length(Nums)))
                                      end, Acc, lists:seq(I+1, length(Nums)-1))
                      end, -infinity, lists:seq(1, length(Nums)-2)),
    %% Return the maximum value, ensuring it's at least 0
    max(0, Max)."
erlang,runtime_error,"Line 4: exception error: undef
[{lists,index_of,[1,[2,1,4,3]],[]},
 {solution,semi_ordered_permutation,1,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,22}]},
 {solution,driver,0,[{file,""solution.erl""},{line,10}]},
 {solution,start,0,[{file,""solution.erl""},{line,39}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\semi-ordered-permutation\responses\Erlang\response_erlang_0_failed.json,"-spec semi_ordered_permutation(Nums :: [integer()]) -> integer().
semi_ordered_permutation(Nums) ->
    N = length(Nums),
    Index1 = lists:index_of(1, Nums) - 1,
    IndexN = lists:index_of(N, Nums) - N,
    abs(Index1) + abs(IndexN)."
erlang,runtime_error,"Line 4: exception error: {badmatch,6}
[{solution,missing_integer,1,[{file,""solution.erl""},{line,4}]},
 {solution,driver,0,[{file,""solution.erl""},{line,30}]},
 {solution,start,0,[{file,""solution.erl""},{line,59}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Easy\smallest-missing-integer-greater-than-sequential-prefix-sum\responses\Erlang\response_erlang_2_failed.json,"-spec missing_integer(Nums :: [integer()]) -> integer().
missing_integer(Nums) ->
    SortedUniqueNums = lists:usort(Nums), % Sort and remove duplicates for efficient processing
    {LongestSeqSum, _} = longest_sequential_prefix(SortedUniqueNums, 0, 0, hd(SortedUniqueNums), 0),
    find_smallest_missing(SortedUniqueNums, LongestSeqSum + 1).

longest_sequential_prefix([], LongestSeqSum, CurrentSeqSum, _LastNum, CurrentSeqLen) ->
    max(LongestSeqSum, CurrentSeqSum + CurrentSeqLen); % Return the max of LongestSeqSum and CurrentSeqSum + CurrentSeqLen
longest_sequential_prefix([H|T], LongestSeqSum, CurrentSeqSum, LastNum, CurrentSeqLen) ->
    if
        H == LastNum + 1 ->
            longest_sequential_prefix(T, LongestSeqSum, CurrentSeqSum + LastNum, H, CurrentSeqLen + 1);
        true ->
            NewLongestSeqSum = max(LongestSeqSum, CurrentSeqSum + CurrentSeqLen),
            longest_sequential_prefix(T, NewLongestSeqSum, 0, H, 1)
    end.

find_smallest_missing([], X) ->
    X;
find_smallest_missing([H|T], X) ->
    if
        X < H ->
            X;
        true ->
            find_smallest_missing(T, X + 1)
    end."
erlang,runtime_error,"Line 4: exception error: badarg
[{binary,split,
         [<<""one.two.three"">>,<<""."">>,[global,{trim,true}]],
         [{error_info,#{module => erl_stdlib_errors}}]},
 {solution,'-split_words_by_separator/2-fun-0-',2,
              [{file,""solution.erl""},{line,4}]},
 {lists,map,2,[{file,""lists.erl""},{line,1559}]},
 {solution,split_words_by_separator,2,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,22}]},
 {solution,driver,0,[{file,""solution.erl""},{line,8}]},
 {solution,start,0,[{file,""solution.erl""},{line,39}]},
 {init,start_em,1,[]}]",../questions/Easy\split-strings-by-separator\responses\Erlang\response_erlang_1_failed.json,"-spec split_words_by_separator(Words :: [unicode:unicode_binary()], Separator :: char()) -> [unicode:unicode_binary()].
split_words_by_separator(Words, Separator) ->
    SeparatorBinary = <<Separator/utf8>>,
    lists:flatten(lists:map(fun(Word) -> binary:split(Word, SeparatorBinary, [global, {trim, true}]) end, Words))."
erlang,runtime_error,"Line 5: exception error: {badkey,0}
[{erlang,map_get,
         [0,#{2 => 1,5 => 1,6 => 1,8 => 1}],
         [{error_info,#{module => erl_erts_errors}}]},
 {solution,'-max_sum/2-lc$^2/1-0-',2,[{file,""solution.erl""},{line,5}]},
 {solution,max_sum,2,[{file,""solution.erl""},{line,5}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,26}]},
 {solution,driver,0,[{file,""solution.erl""},{line,12}]},
 {solution,start,0,[{file,""solution.erl""},{line,43}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\apply-operations-on-array-to-maximize-sum-of-squares\responses\Erlang\response_erlang_1_failed.json,"-spec max_sum(Nums :: [integer()], K :: integer()) -> integer().
max_sum(Nums, K) ->
    MaxValue = lists:max(Nums),
    Freq = lists:foldl(fun(X, Acc) -> maps:update_with(X, fun(V) -> V + 1 end, 1, Acc) end, #{}, Nums),
    MaxList = lists:flatten([lists:duplicate(maps:get(Key, Freq), Key) || Key <- lists:seq(0, MaxValue)]),
    Sorted = lists:reverse(lists:sort(MaxList)),
    SumSquares = lists:foldl(fun(X, Acc) -> (X*X rem 1000000007 + Acc) rem 1000000007 end, 0, lists:sublist(Sorted, 1, K)),
    SumSquares."
erlang,runtime_error,"Line 4: exception error: {badmatch,{6,2,1,4}}
[{solution,max_frequency_score,2,[{file,""solution.erl""},{line,4}]},
 {solution,driver,0,[{file,""solution.erl""},{line,14}]},
 {solution,start,0,[{file,""solution.erl""},{line,45}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\apply-operations-to-maximize-frequency-score\responses\Erlang\response_erlang_1_failed.json,"-spec max_frequency_score(Nums :: [integer()], K :: integer()) -> integer().
max_frequency_score(Nums, K) ->
    Sorted = lists:sort(Nums),
    {_, MaxFreq} = lists:foldl(fun(X, {Prev, Max, Count, Acc}) ->
                                   if 
                                       X =:= Prev -> {X, Max, Count + 1, Acc};
                                       true -> {X, max(Max, Count), 1, Acc + Count}
                                   end
                               end, {hd(Sorted), 0, 1, 0}, Sorted),
    MaxFreq + K."
erlang,runtime_error,"Line 5: exception error: badarg
[{erlang,'or',[1,true],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-maximum_score/2-fun-1-',2,[{file,""solution.erl""},{line,5}]},
 {lists,sort,2,[{file,""lists.erl""},{line,1210}]},
 {solution,maximum_score,2,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,46}]},
 {solution,driver,0,[{file,""solution.erl""},{line,32}]},
 {solution,start,0,[{file,""solution.erl""},{line,63}]},
 {init,start_em,1,[]}]",../questions/Hard\apply-operations-to-maximize-score\responses\Erlang\response_erlang_1_failed.json,"-spec maximum_score(Nums :: [integer()], K :: integer()) -> integer().
maximum_score(Nums, K) ->
    PrimeScores = lists:map(fun(X) -> {prime_score(X), X} end, Nums),
    Sorted = lists:sort(fun({PS1, X1}, {PS2, X2}) ->
                            PS1 > PS2 or (PS1 == PS2 andalso X1 > X2)
                        end, PrimeScores),
    Modulo = 1000000007,
    MaxScore = lists:foldl(fun({_, X}, Acc) -> (Acc * X) rem Modulo end, 1, lists:sublist(Sorted, 1, K)),
    MaxScore.

prime_score(N) ->
    prime_factors(N, 2, []).

prime_factors(1, _, Acc) -> length(lists:usort(Acc));
prime_factors(N, Factor, Acc) when N rem Factor == 0 ->
    prime_factors(N div Factor, Factor, [Factor|Acc]);
prime_factors(N, Factor, Acc) ->
    prime_factors(N, next_factor(Factor, N), Acc).

next_factor(Factor, N) ->
    case is_prime(Factor + 1, N) of
        true -> Factor + 1;
        false -> next_factor(Factor + 1, N)
    end.

is_prime(Factor, N) when Factor * Factor > N -> true;
is_prime(Factor, N) when N rem Factor == 0 -> false;
is_prime(Factor, N) -> is_prime(Factor + 1, N)."
erlang,runtime_error,"Line 5: exception error: badarg
[{erlang,'or',[2,false],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-maximum_score/2-fun-1-',2,[{file,""solution.erl""},{line,5}]},
 {lists,sort,2,[{file,""lists.erl""},{line,1210}]},
 {solution,maximum_score,2,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,56}]},
 {solution,driver,0,[{file,""solution.erl""},{line,42}]},
 {solution,start,0,[{file,""solution.erl""},{line,73}]},
 {init,start_em,1,[]}]",../questions/Hard\apply-operations-to-maximize-score\responses\Erlang\response_erlang_2_failed.json,"-spec maximum_score(Nums :: [integer()], K :: integer()) -> integer().
maximum_score(Nums, K) ->
    PrimeScores = lists:map(fun(X) -> {prime_score(X), X} end, Nums),
    Sorted = lists:sort(fun({PS1, X1}, {PS2, X2}) ->
                            PS1 > PS2 or (PS1 == PS2 andalso X1 < X2)
                        end, PrimeScores),
    Modulo = 1000000007,
    MaxScore = lists:foldl(fun({_, X}, Acc) -> (Acc * X) rem Modulo end, 1, lists:sublist(Sorted, 1, K)),
    MaxScore.

prime_score(N) ->
    find_primes(N, 2, 0).

find_primes(1, _, Count) -> Count;
find_primes(N, Factor, Count) when N rem Factor == 0 ->
    find_primes(N div Factor, Factor, Count + 1);
find_primes(N, Factor, Count) ->
    NextFactor = next_factor(Factor),
    if N rem NextFactor == 0 ->
        find_primes(N, NextFactor, Count + 1);
       true ->
        find_primes(N, NextFactor, Count)
    end.

next_factor(2) -> 3;
next_factor(Factor) ->
    case is_prime(Factor + 1) of
        true -> Factor + 1;
        false -> next_factor(Factor + 1)
    end.

is_prime(2) -> true;
is_prime(N) when N > 2 ->
    is_prime_helper(N, 2).

is_prime_helper(N, Factor) when Factor * Factor > N -> true;
is_prime_helper(N, Factor) when N rem Factor == 0 -> false;
is_prime_helper(N, Factor) -> is_prime_helper(N, Factor + 1)."
erlang,runtime_error,"Line 6: exception error: badarg
[{binary,at,[<<""baeyh"">>,5],[{error_info,#{module => erl_stdlib_errors}}]},
 {solution,'-beautiful_substrings/2-fun-1-',9,
              [{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,43}]},
 {solution,driver,0,[{file,""solution.erl""},{line,29}]},
 {solution,start,0,[{file,""solution.erl""},{line,60}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\count-beautiful-substrings-ii\responses\Erlang\response_erlang_0_failed.json,"-spec beautiful_substrings(S :: unicode:unicode_binary(), K :: integer()) -> integer().
beautiful_substrings(S, K) ->
    IsVowel = fun(C) -> lists:member(C, ""aeiou"") end,
    CountBeauties = fun
        (CountBeauties, I, J, Vowels, Consonants, Acc) when I =< byte_size(S), J =< byte_size(S) ->
            case IsVowel(binary:at(S, I)) of
                true -> Vowels1 = Vowels + 1;
                false -> Vowels1 = Vowels
            end,
            case IsVowel(binary:at(S, J)) of
                true -> Consonants1 = Consonants + 1;
                false -> Consonants1 = Consonants
            end,
            if 
                Vowels == Consonants, (Vowels * Consonants) rem K == 0 ->
                    CountBeauties(CountBeauties, I+1, J+1, Vowels1, Consonants1, Acc+1);
                true ->
                    CountBeauties(CountBeauties, I+1, J+1, Vowels1, Consonants1, Acc)
            end;
        (CountBeauties, I, _, _, _, Acc) when I =:= byte_size(S) + 1 ->
            Acc;
        (_, _, _, _, _, Acc) ->
            Acc
    end,
    CountBeauties(CountBeauties, 0, 0, 0, 0, 0)."
erlang,runtime_error,"Line 6: exception error: {badarity,{#Fun<solution.1.97533809>,[1,2,0,0,0]}}
[{solution,'-beautiful_substrings/2-CountBeauties/3-0-',4,
              [{file,""solution.erl""},{line,6}]},
 {solution,'-beautiful_substrings/2-BeautifulCount/2-1-',4,
              [{file,""solution.erl""},{line,24}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,46}]},
 {solution,driver,0,[{file,""solution.erl""},{line,32}]},
 {solution,start,0,[{file,""solution.erl""},{line,63}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\count-beautiful-substrings-ii\responses\Erlang\response_erlang_1_failed.json,"-spec beautiful_substrings(S :: unicode:unicode_binary(), K :: integer()) -> integer().
beautiful_substrings(S, K) ->
    Length = byte_size(S),
    IsVowel = fun(C) -> lists:member(C, [$a, $e, $i, $o, $u]) end,
    CountBeauties = fun CountBeauties(I, J, Acc) when I =< Length ->
        CountBeauties(I, J, Acc, 0, 0); 
        CountBeauties(_, _, Acc) -> 
        Acc 
    end,
    CountSubstr = fun CountSubstr(I, J, Vowels, Consonants) when J =< Length ->
        Char = binary:at(S, J-1),
        Vowels1 = Vowels + case IsVowel(Char) of true -> 1; false -> 0 end,
        Consonants1 = Consonants + case IsVowel(Char) of true -> 0; false -> 1 end,
        if 
            Vowels1 == Consonants1, (Vowels1 * Consonants1) rem K == 0 -> 
                CountBeauties(I, J+1, 1); 
            true -> 
                CountBeauties(I, J+1, 0) 
        end;
        CountSubstr(_, _, _, _) -> 
        0 
    end,
    BeautifulCount = fun BeautifulCount(I, Acc) when I =< Length ->
        BeautifulCount(I+1, Acc + CountSubstr(I, I, 0, 0));
        BeautifulCount(_, Acc) -> 
        Acc 
    end,
    BeautifulCount(1, 0)."
erlang,runtime_error,"Line 3: exception error: badarg
[{binary,bin_to_list,
         [2],
         [{file,""binary.erl""},
          {line,482},
          {error_info,#{module => erl_stdlib_errors}}]},
 {solution,count_k_subsequences_with_max_beauty,2,
              [{file,""solution.erl""},{line,3}]},
 {solution,count_k_subsequences_with_max_beauty,2,
              [{file,""solution.erl""},{line,9}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,31}]},
 {solution,driver,0,[{file,""solution.erl""},{line,17}]},
 {solution,start,0,[{file,""solution.erl""},{line,48}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\count-k-subsequences-of-a-string-with-maximum-beauty\responses\Erlang\response_erlang_0_failed.json,"-spec count_k_subsequences_with_max_beauty(S :: unicode:unicode_binary(), K :: integer()) -> integer().
count_k_subsequences_with_max_beauty(S, K) ->
    Freqs = lists:foldl(fun(C, Acc) -> maps:update_with(C, fun(X) -> X + 1 end, 1, Acc) end, #{}, binary:bin_to_list(S)),
    SortedFreqs = lists:reverse(lists:sort(maps:values(Freqs))),
    {MaxFreqs, Rest} = lists:split(K, SortedFreqs),
    MaxBeauty = lists:sum(MaxFreqs),
    CountMaxBeauty = fun
        (0, _) -> 1;
        (N, [H|T]) when N >= H -> (H * count_k_subsequences_with_max_beauty(N - H, T)) rem 1000000007;
        (N, [H|_]) when N < H -> N;
        (_, []) -> 0
    end,
    CountMaxBeauty(MaxBeauty, Rest) rem 1000000007."
erlang,runtime_error,"Line 7: exception error: badarg
[{erlang,element,
         [1,[{0,1},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}]],
         [{error_info,#{module => erl_erts_errors}}]},
 {solution,'-count_sub_multisets/3-fun-2-',3,
              [{file,""solution.erl""},{line,7}]},
 {lists,map_1,2,[{file,""lists.erl""},{line,1564}]},
 {lists,map,2,[{file,""lists.erl""},{line,1559}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,count_sub_multisets,3,[{file,""solution.erl""},{line,5}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,37}]},
 {solution,driver,0,[{file,""solution.erl""},{line,21}]}]",../questions/Hard\count-of-sub-multisets-with-bounded-sum\responses\Erlang\response_erlang_0_failed.json,"-spec count_sub_multisets(Nums :: [integer()], L :: integer(), R :: integer()) -> integer().
count_sub_multisets(Nums, L, R) ->
    Mod = 1000000007,
    MaxSum = lists:foldl(fun(X, Acc) -> X + Acc end, 0, Nums),
    DP = lists:foldl(fun(Num, Dp) ->
                         lists:map(fun({Idx, Val}) ->
                                       if Idx - Num >= 0 -> {Idx, (element(Idx - Num + 1, Dp) + Val) rem Mod};
                                       true -> {Idx, Val}
                                       end
                                   end, lists:zip(lists:seq(0, MaxSum), Dp))
                     end, [{0,1}|lists:map(fun(_) -> {0,0} end, lists:seq(1, MaxSum))], Nums),
    SumRange = lists:foldl(fun({Idx, Val}, Acc) ->
                               if Idx >= L, Idx =< R -> (Acc + Val) rem Mod;
                               true -> Acc
                               end
                           end, 0, DP),
    SumRange."
erlang,runtime_error,"Line 13: exception error: badarg
[{erlang,element,
         [1,[1,0,0,0,0,0,0,0,0,0]],
         [{error_info,#{module => erl_erts_errors}}]},
 {solution,'-update_dp/3-fun-0-',4,[{file,""solution.erl""},{line,13}]},
 {lists,map_1,2,[{file,""lists.erl""},{line,1564}]},
 {lists,map,2,[{file,""lists.erl""},{line,1559}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,count_sub_multisets,3,[{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,43}]},
 {solution,driver,0,[{file,""solution.erl""},{line,27}]}]",../questions/Hard\count-of-sub-multisets-with-bounded-sum\responses\Erlang\response_erlang_1_failed.json,"-spec count_sub_multisets(Nums :: [integer()], L :: integer(), R :: integer()) -> integer().
count_sub_multisets(Nums, L, R) ->
    Mod = 1000000007,
    MaxSum = lists:sum(Nums),
    InitDp = lists:duplicate(MaxSum + 1, 0),
    lists:foldl(fun(X, Dp) -> update_dp(X, Dp, Mod) end, [1|InitDp], Nums),
    SumRange = calculate_sum_range(L, R, Mod),

    SumRange.

update_dp(Num, Dp, Mod) ->
    lists:map(fun({Idx, Val}) ->
                  NewVal = if Idx >= Num -> (element(Idx - Num + 1, Dp) + Val) rem Mod;
                             true -> Val
                           end,
                  {Idx, NewVal}
              end, lists:zip(lists:seq(0, length(Dp) - 1), Dp)).

calculate_sum_range(L, R, Mod) ->
    DP = update_dp(0, lists:duplicate(R + 1, 0), Mod), % Placeholder for the correct DP update logic
    lists:foldl(fun(Idx, Acc) when Idx >= L andalso Idx =< R -> (element(Idx + 1, DP) + Acc) rem Mod;
                   (_, Acc) -> Acc
                end, 0, lists:seq(0, R))."
erlang,runtime_error,"Line 12: exception error: badarg
[{erlang,element,[1,[1,0,0,0]],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-dp_update/4-fun-0-',4,[{file,""solution.erl""},{line,12}]},
 {lists,map_1,2,[{file,""lists.erl""},{line,1564}]},
 {lists,map,2,[{file,""lists.erl""},{line,1559}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,count_sub_multisets,3,[{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,35}]},
 {solution,driver,0,[{file,""solution.erl""},{line,19}]}]",../questions/Hard\count-of-sub-multisets-with-bounded-sum\responses\Erlang\response_erlang_2_failed.json,"-spec count_sub_multisets(Nums :: [integer()], L :: integer(), R :: integer()) -> integer().
count_sub_multisets(Nums, L, R) ->
    Mod = 1000000007,
    Sums = lists:usort(Nums),
    Max = lists:last(Sums),
    DP = lists:foldl(fun(X, Acc) -> dp_update(X, Acc, Max, Mod) end, [1 | lists:duplicate(Max, 0)], Sums),
    Sum = lists:foldl(fun(X, Acc) -> if X >= L, X =< R -> (element(X+1, DP) + Acc) rem Mod; true -> Acc end end, 0, lists:seq(0, Max)),
    Sum.

dp_update(Num, DP, Max, Mod) ->
    lists:map(fun({I, Val}) ->
        if I >= Num -> {I, (element(I - Num + 1, DP) + Val) rem Mod};
        true -> {I, Val}
        end
    end, lists:zip(lists:seq(0, Max), DP))."
erlang,runtime_error,"Line 5: exception error: undef
[{lists,update_n,
        [1,
         {0,0},
         [{infinity,0},
          {infinity,0},
          {infinity,0},
          {infinity,0},
          {infinity,0},
          {infinity,0},
          {infinity,0}]],
        []},
 {solution,minimum_cost,3,[{file,""solution.erl""},{line,5}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,44}]},
 {solution,driver,0,[{file,""solution.erl""},{line,28}]},
 {solution,start,0,[{file,""solution.erl""},{line,61}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\divide-an-array-into-subarrays-with-minimum-cost-ii\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_cost(Nums :: [integer()], K :: integer(), Dist :: integer()) -> integer().
minimum_cost(Nums, K, Dist) ->
    N = length(Nums),
    DP = lists:duplicate(N + 1, {infinity, 0}),
    DP1 = lists:update_n(1, {0, 0}, DP),
    {_, Result} = lists:foldl(fun(X, {Idx, DP_Current}) ->
        {MinCost, _} = lists:foldl(fun(I, {Min, Count}) ->
            if 
                Count < K - 1 ->
                    StartIdx = max(1, Idx - Dist),
                    EndIdx = Idx - 1,
                    {Cost, _} = lists:nth(I, DP_Current),
                    NewCost = Cost + X,
                    NewMin = min(Min, NewCost),
                    {NewMin, Count + 1};
                true -> 
                    {Min, Count}
            end
        end, {infinity, 0}, lists:seq(1, N)),
        DP_Next = lists:update_n(Idx, {MinCost, 0}, DP_Current),
        {Idx + 1, DP_Next}
    end, {1, DP1}, Nums),
    {FinalCost, _} = lists:last(Result),
    FinalCost."
erlang,runtime_error,"Line 5: exception error: undef
[{lists,update_n,
        [1,0,[infinity,infinity,infinity,infinity,infinity,infinity,infinity]],
        []},
 {solution,minimum_cost,3,[{file,""solution.erl""},{line,5}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,35}]},
 {solution,driver,0,[{file,""solution.erl""},{line,19}]},
 {solution,start,0,[{file,""solution.erl""},{line,52}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\divide-an-array-into-subarrays-with-minimum-cost-ii\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_cost(Nums :: [integer()], K :: integer(), Dist :: integer()) -> integer().
minimum_cost(Nums, K, Dist) ->
    N = length(Nums),
    DP = lists:duplicate(N + 1, infinity),
    DP1 = lists:update_n(1, 0, DP),
    lists:foldl(fun(X, Acc) ->
                    lists:map(fun({I, Val}) ->
                                  if I == 1 -> Val;
                                     I - 1 > Dist andalso I > K -> infinity;
                                     true -> min(lists:nth(I - 1, Acc) + X, Val)
                                  end
                              end, lists:zip(lists:seq(1, N), Acc))
                end, DP1, Nums),
    MinFun = fun(X, Acc) -> min(X, Acc) end,
    lists:foldl(MinFun, infinity, lists:sublist(DP1, N - K + 2, K))."
erlang,runtime_error,"Line 6: exception error: function_clause
[{lists,seq,[0,-3],[{file,""lists.erl""},{line,280}]},
 {solution,beautiful_indices,4,[{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,33}]},
 {solution,driver,0,[{file,""solution.erl""},{line,15}]},
 {solution,start,0,[{file,""solution.erl""},{line,50}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\find-beautiful-indices-in-the-given-array-ii\responses\Erlang\response_erlang_0_failed.json,"-spec beautiful_indices(S :: unicode:unicode_binary(), A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), K :: integer()) -> [integer()].
beautiful_indices(S, A, B, K) ->
    SList = binary_to_list(S),
    AList = binary_to_list(A),
    BList = binary_to_list(B),
    ASizes = lists:seq(0, length(SList) - length(AList)),
    BSizes = lists:seq(0, length(SList) - length(BList)),
    AIndices = [I || I <- ASizes, lists:sublist(SList, I+1, length(AList)) == AList],
    BIndices = [J || J <- BSizes, lists:sublist(SList, J+1, length(BList)) == BList],
    FilteredIndices = [AI || AI <- AIndices, lists:any(fun(BI) -> abs(AI - BI) =< K end, BIndices)],
    lists:sort(FilteredIndices)."
erlang,runtime_error,"Line 27: exception error: undef
[{lists,drop,[0,[0,6,6,8,8,8]],[]},
 {solution,find_leftmost,4,[{file,""solution.erl""},{line,27}]},
 {solution,'-leftmost_building_queries/2-fun-1-',2,
              [{file,""solution.erl""},{line,13}]},
 {lists,map,2,[{file,""lists.erl""},{line,1559}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,52}]},
 {solution,driver,0,[{file,""solution.erl""},{line,38}]},
 {solution,start,0,[{file,""solution.erl""},{line,69}]},
 {init,start_em,1,[]}]",../questions/Hard\find-building-where-alice-and-bob-can-meet\responses\Erlang\response_erlang_0_failed.json,"-spec leftmost_building_queries(Heights :: [integer()], Queries :: [[integer()]]) -> [integer()].
leftmost_building_queries(Heights, Queries) ->
    Reachable = lists:foldl(fun(H, {Max, Acc}) ->
                                {max(H, Max), [Max | Acc]}
                            end, {0, []}, Heights),
    ReachableRev = lists:reverse(element(2, Reachable)),
    lists:map(fun([A, B]) ->
        case A == B of
            true -> A;
            false ->
                AliceReach = lists:nth(A + 1, ReachableRev),
                BobReach = lists:nth(B + 1, ReachableRev),
                MeetIndex = find_meet(AliceReach, BobReach, ReachableRev, A, B),
                case MeetIndex of
                    undefined -> -1;
                    _ -> MeetIndex
                end
        end
    end, Queries).

find_meet(AliceReach, BobReach, Reachable, A, B) when AliceReach >= B orelse BobReach >= A ->
    find_leftmost(A, B, max(AliceReach, BobReach), Reachable);
find_meet(_, _, _, _, _) ->
    undefined.

find_leftmost(A, B, MaxReach, Reachable) ->
    case lists:drop(A, Reachable) of
        [] -> undefined;
        [_|T] ->
            case lists:nth(B - A, T) of
                H when H >= MaxReach -> B;
                _ -> find_leftmost(A + 1, B, MaxReach, T)
            end
    end."
erlang,runtime_error,"Line 3: exception error: badarg
[{erlang,'++',
         [[124|<<""aaa"">>],[124|<<""cb"">>]],
         [{error_info,#{module => erl_erts_errors}}]},
 {solution,'-longest_valid_substring/2-fun-0-',2,
              [{file,""solution.erl""},{line,3}]},
 {lists,foldl_1,3,[{file,""lists.erl""},{line,1599}]},
 {solution,longest_valid_substring,2,[{file,""solution.erl""},{line,3}]},
 {solution,driver,0,[{file,""solution.erl""},{line,13}]},
 {solution,start,0,[{file,""solution.erl""},{line,44}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\length-of-the-longest-valid-substring\responses\Erlang\response_erlang_0_failed.json,"-spec longest_valid_substring(Word :: unicode:unicode_binary(), Forbidden :: [unicode:unicode_binary()]) -> integer().
longest_valid_substring(Word, Forbidden) ->
    ForbiddenRegex = lists:foldl(fun(F, Acc) -> Acc ++ ""|"" ++ unicode:characters_to_binary(F) end, """", Forbidden),
    TrimmedRegex = lists:sublist(ForbiddenRegex, 2, byte_size(ForbiddenRegex) - 1),
    Pattern = unicode:characters_to_binary([""("", TrimmedRegex, "")""]),
    {ok, MP} = re:compile(Pattern),
    SplitWord = re:split(Word, MP, [global, {return, list}]),
    MaxLength = lists:max([byte_size(S) || S <- SplitWord]),
    MaxLength."
erlang,runtime_error,"Line 6: exception error: badarg
[{re,split,
     [<<""cbaaaabc"">>,
      {ok,{re_pattern,0,1,0,
                      <<69,82,67,80,76,0,0,0,0,8,0,0,1,128,0,0,255,255,255,
                        255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,
                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,131,
                        0,3,119,0,5,29,97,120,0,8,0>>}},
      [global,{return,list}]],
     [{file,""re.erl""},
      {line,983},
      {error_info,#{cause => badopt,module => erl_stdlib_errors}}]},
 {solution,longest_valid_substring,2,[{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,26}]},
 {solution,driver,0,[{file,""solution.erl""},{line,12}]},
 {solution,start,0,[{file,""solution.erl""},{line,43}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\length-of-the-longest-valid-substring\responses\Erlang\response_erlang_1_failed.json,"-spec longest_valid_substring(Word :: unicode:unicode_binary(), Forbidden :: [unicode:unicode_binary()]) -> integer().
longest_valid_substring(Word, Forbidden) ->
    ForbiddenRegex = lists:foldl(fun(F, Acc) -> unicode:characters_to_binary([Acc, ""|"", F]) end, """", Forbidden),
    TrimmedRegex = unicode:characters_to_binary(lists:sublist(binary_to_list(ForbiddenRegex), 2)),
    Pattern = re:compile(TrimmedRegex, [unicode]),
    Matches = re:split(Word, Pattern, [global, {return, list}]),
    MaxLength = lists:max([byte_size(M) || M <- Matches, byte_size(M) > 0]),
    MaxLength."
erlang,runtime_error,"Line 8: exception error: badarg
[{re,split,
     [<<""cbaaaabc"">>,
      {re_pattern,1,0,0,
                  <<69,82,67,80,83,0,0,0,0,0,0,0,81,0,0,0,255,255,255,255,255,
                    255,255,255,124,0,97,0,0,0,1,0,0,0,64,0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,131,0,15,133,0,9,0,
                    1,29,124,29,97,120,0,9,120,0,15,0>>},
      [{return,list},global]],
     [{file,""re.erl""},
      {line,983},
      {error_info,#{cause => badopt,module => erl_stdlib_errors}}]},
 {solution,longest_valid_substring,2,[{file,""solution.erl""},{line,8}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,28}]},
 {solution,driver,0,[{file,""solution.erl""},{line,14}]},
 {solution,start,0,[{file,""solution.erl""},{line,45}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\length-of-the-longest-valid-substring\responses\Erlang\response_erlang_2_failed.json,"-spec longest_valid_substring(Word :: unicode:unicode_binary(), Forbidden :: [unicode:unicode_binary()]) -> integer().
longest_valid_substring(Word, Forbidden) ->
    ForbiddenPattern = lists:foldl(fun(F, Acc) -> Acc ++ ""|"" ++ unicode:characters_to_list(F) end, """", Forbidden),
    TrimmedPattern = lists:sublist(ForbiddenPattern, 2),
    EscapedPattern = re:replace(TrimmedPattern, ""([\\|\\(\\)\\{\\}\\[\\]\\*\\+\\?\\^\\$\\.])"", ""\\\\&"", [global, {return, list}]),
    Pattern = ""("" ++ EscapedPattern ++ "")"",
    {ok, CompiledPattern} = re:compile(Pattern),
    Splits = re:split(Word, CompiledPattern, [{return, list}, global]),
    MaxLength = lists:max([byte_size(Split) || Split <- Splits]),
    MaxLength."
erlang,runtime_error,"Line 3: exception error: badarg
[{erlang,element,[2,[3,2]],[{error_info,#{module => erl_erts_errors}}]},
 {lists,keysort,2,[{file,""lists.erl""},{line,952}]},
 {solution,find_maximum_elegance,2,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,31}]},
 {solution,driver,0,[{file,""solution.erl""},{line,17}]},
 {solution,start,0,[{file,""solution.erl""},{line,48}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\maximum-elegance-of-a-k-length-subsequence\responses\Erlang\response_erlang_1_failed.json,"-spec find_maximum_elegance(Items :: [[integer()]], K :: integer()) -> integer().
find_maximum_elegance(Items, K) ->
    {SortedItems, _} = lists:unzip(lists:keysort(2, Items)),
    Combinations = comb(SortedItems, K),
    lists:max([sum(Combo) + length(lists:usort([C || {_, C} <- Combo])) * length(lists:usort([C || {_, C} <- Combo])) || Combo <- Combinations]).

comb(_, 0) -> [[]];
comb([], _) -> [];
comb([H|T], N) ->
    [[H|C] || C <- comb(T, N-1)] ++ comb(T, N).

sum([]) -> 0;
sum([[P, _]|T]) -> P + sum(T)."
erlang,runtime_error,"Line 3: exception error: undef
[{erlang,prime_factors,""\b"",[]},
 {lists,map,2,[{file,""lists.erl""},{line,1559}]},
 {solution,maximum_sum,1,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,32}]},
 {solution,driver,0,[{file,""solution.erl""},{line,20}]},
 {solution,start,0,[{file,""solution.erl""},{line,49}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\maximum-element-sum-of-a-complete-subset-of-indices\responses\Erlang\response_erlang_1_failed.json,"-spec maximum_sum(Nums :: [integer()]) -> integer().
maximum_sum(Nums) ->
    PrimeFactors = lists:map(fun erlang:prime_factors/1, Nums),
    Simplify = fun(Factors) -> lists:foldl(fun(X, Acc) -> dict:update_counter(X, 1, Acc) end, dict:new(), Factors) end,
    SimplifiedFactors = lists:map(Simplify, PrimeFactors),
    GroupByKey = fun(Factors, Acc) ->
                      Key = dict:fold(fun(K, V, KAcc) -> if V rem 2 == 1 -> [K|KAcc]; true -> KAcc end end, [], Factors),
                      case dict:find(Key, Acc) of
                          {ok, Value} -> dict:update(Key, fun(Old) -> Old + 1 end, Acc);
                          error -> dict:store(Key, 1, Acc)
                      end
                  end,
    Groups = lists:foldl(GroupByKey, dict:new(), SimplifiedFactors),
    MaxGroup = dict:fold(fun(_Key, Size, Max) -> max(Size, Max) end, 0, Groups),
    MaxSum = lists:foldl(fun(Num, Acc) -> if Num =< MaxGroup -> Acc + Num; true -> Acc end end, 0, Nums),
    MaxSum."
erlang,runtime_error,"Line 23: exception error: function_clause
[{solution,update_limits,[[0,2,5],2],[{file,""solution.erl""},{line,23}]},
 {solution,find_max_groups,3,[{file,""solution.erl""},{line,11}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,43}]},
 {solution,driver,0,[{file,""solution.erl""},{line,31}]},
 {solution,start,0,[{file,""solution.erl""},{line,60}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Hard\maximum-number-of-groups-with-increasing-length\responses\Erlang\response_erlang_2_failed.json,"-spec max_increasing_groups(UsageLimits :: [integer()]) -> integer().
max_increasing_groups(UsageLimits) ->
    SortedLimits = lists:sort(UsageLimits),
    find_max_groups(SortedLimits, 1, 0).

find_max_groups([], _, Groups) ->
    Groups;
find_max_groups(Limits, GroupSize, Groups) ->
    case can_form_group(Limits, GroupSize, 0) of
        ok ->
            NewLimits = update_limits(Limits, GroupSize),
            find_max_groups(NewLimits, GroupSize + 1, Groups + 1);
        error ->
            Groups
    end.

can_form_group([], Count, Required) when Count >= Required -> ok;
can_form_group([], _, _) -> error;
can_form_group([_H|T], Count, Required) when Count < Required ->
    can_form_group(T, Count + 1, Required);
can_form_group(_, Count, Required) when Count >= Required -> ok.

update_limits(Limits, 0) -> Limits;
update_limits([], _) -> [];
update_limits([H|T], Count) when H > 0, Count > 0 ->
    [H - 1 | update_limits(T, Count - 1)];
update_limits(L, Count) when Count =< 0 -> L."
erlang,runtime_error,"exception throw: {invalid_user_return_value,{285,10},""integer()""}",../questions/Hard\maximum-spending-after-buying-items\responses\Erlang\response_erlang_0_failed.json,"-spec max_spending(Values :: [[integer()]]) -> integer().
max_spending(Values) ->
    Flattened = lists:flatten(Values),
    Sorted = lists:sort(Flattened),
    lists:foldl(fun(Elem, {Sum, Day}) -> {Sum + Elem * Day, Day + 1} end, {0, 1}, Sorted)."
erlang,runtime_error,"Line 8: exception error: function_clause
[{solution,solve,
              [""abcac"",1,0,
               [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1]]],
              [{file,""solution.erl""},{line,8}]},
 {solution,'-solve/4-fun-0-',6,[{file,""solution.erl""},{line,14}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,solve,4,[{file,""solution.erl""},{line,12}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,53}]},
 {solution,driver,0,[{file,""solution.erl""},{line,39}]},
 {solution,start,0,[{file,""solution.erl""},{line,70}]},
 {init,start_em,1,[]}]",../questions/Hard\minimum-changes-to-make-k-semi-palindromes\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_changes(S :: unicode:unicode_binary(), K :: integer()) -> integer().
minimum_changes(S, K) ->
    Str = unicode:characters_to_list(S),
    Len = length(Str),
    DP = lists:duplicate(K + 1, lists:duplicate(Len + 1, -1)),
    solve(Str, K, Len, DP).

solve(_Str, 0, 0, _DP) -> 0;
solve(Str, K, L, DP) when K > 0, L > 0 ->
    case lists:nth(L, lists:nth(K, DP)) of
        -1 ->
            Min = lists:foldl(fun(I, Acc) ->
                                  Changes = changes_required(lists:sublist(Str, I, L - I + 1)),
                                  MinSoFar = solve(Str, K - 1, I - 1, DP),
                                  min(Acc, Changes + MinSoFar)
                              end, infinity, lists:seq(1, L)),
            Update = lists:update_nth(K, lists:update_nth(L, lists:nth(K, DP), Min), DP),
            Min;
        Min -> Min
    end.

changes_required(Str) ->
    Len = length(Str),
    lists:foldl(fun(I, Acc) ->
                    if
                        I > Len div 2 -> Acc;
                        true -> Acc + case lists:nth(I, Str) == lists:nth(Len - I + 1, Str) of
                                          true -> 0;
                                          false -> 1
                                      end
                    end
                end, 0, lists:seq(1, Len div 2)).

min(A, B) when A < B -> A;
min(_, B) -> B."
erlang,runtime_error,"Line 24: exception error: function_clause
[{lists,prefix,[<<""a"">>,""abcd""],[{file,""lists.erl""},{line,229}]},
 {solution,'-find_min_operation/3-fun-0-',4,
              [{file,""solution.erl""},{line,24}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,find_min_operation,3,[{file,""solution.erl""},{line,22}]},
 {solution,find_min_cost,4,[{file,""solution.erl""},{line,14}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,70}]},
 {solution,driver,0,[{file,""solution.erl""},{line,50}]},
 {solution,start,0,[{file,""solution.erl""},{line,87}]}]",../questions/Hard\minimum-cost-to-convert-string-ii\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [unicode:unicode_binary()], Changed :: [unicode:unicode_binary()], Cost :: [integer()]) -> integer().
minimum_cost(Source, Target, Original, Changed, Cost) ->
    {SourceList, TargetList} = {binary_to_list(Source), binary_to_list(Target)},
    Ops = lists:zip3(Original, Changed, Cost),
    MinCost = find_min_cost(SourceList, TargetList, Ops, 0),
    case MinCost of
        infinity -> -1;
        _ -> MinCost
    end.

find_min_cost(_, [], _, Cost) ->
    Cost;
find_min_cost(Source, Target, Ops, AccumulatedCost) ->
    case find_min_operation(Source, Target, Ops) of
        {ok, {Cost, SourceAfterOp, TargetAfterOp}} ->
            find_min_cost(SourceAfterOp, TargetAfterOp, Ops, AccumulatedCost + Cost);
        error ->
            infinity
    end.

find_min_operation(Source, [T|TargetRest], Ops) ->
    MinOp = lists:foldl(
        fun({Orig, Changed, Cost}, Acc) ->
            case lists:prefix(Orig, Source) andalso lists:prefix(Changed, [T|TargetRest]) of
                true ->
                    SourceAfterOp = lists:nthtail(length(Orig), Source),
                    TargetAfterOp = lists:nthtail(length(Changed), [T|TargetRest]),
                    case Acc of
                        {ok, {AccCost, _, _}} when Cost < AccCost ->
                            {ok, {Cost, SourceAfterOp, TargetAfterOp}};
                        {ok, _} ->
                            Acc;
                        error ->
                            {ok, {Cost, SourceAfterOp, TargetAfterOp}}
                    end;
                false ->
                    Acc
            end
        end,
        error,
        Ops
    ),
    case MinOp of
        {ok, _} = Op -> Op;
        error -> find_min_operation(tl(Source), [T|TargetRest], Ops)
    end."
erlang,runtime_error,"Line 5: exception error: badarg
[{erlang,'or',[2,false],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-paint_walls/2-fun-0-',2,[{file,""solution.erl""},{line,5}]},
 {lists,sort,2,[{file,""lists.erl""},{line,1210}]},
 {solution,paint_walls,2,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,30}]},
 {solution,driver,0,[{file,""solution.erl""},{line,16}]},
 {solution,start,0,[{file,""solution.erl""},{line,47}]},
 {init,start_em,1,[]}]",../questions/Hard\painting-the-walls\responses\Erlang\response_erlang_0_failed.json,"-spec paint_walls(Cost :: [integer()], Time :: [integer()]) -> integer().
paint_walls(Cost, Time) ->
    Zipped = lists:zip(Time, Cost),
    Sorted = lists:sort(fun({Time1, Cost1}, {Time2, Cost2}) -> 
                            Time1 > Time2 or (Time1 == Time2 andalso Cost1 < Cost2) end, Zipped),
    {Paid, _} = lists:foldl(fun({Time, Cost}, {AccCost, AccTime}) ->
                                if 
                                    AccTime >= Time -> {AccCost, AccTime + 1};
                                    true -> {AccCost + Cost, AccTime + Time}
                                end
                            end, {0, 0}, Sorted),
    Paid."
erlang,runtime_error,"Line 26: exception error: {bad_filter,0}
[{solution,'-check_array_recursive/5-lc$^0/1-0-',3,
              [{file,""solution.erl""},{line,26}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,50}]},
 {solution,driver,0,[{file,""solution.erl""},{line,36}]},
 {solution,start,0,[{file,""solution.erl""},{line,67}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\apply-operations-to-make-all-array-elements-equal-to-zero\responses\Erlang\response_erlang_1_failed.json,"-spec check_array(Nums :: [integer()], K :: integer()) -> boolean().
check_array(Nums, K) ->
    % Initialize a list to track the extra decrements needed due to operations performed
    % on earlier elements, starting with all zeros.
    ExtraDecs = lists:duplicate(length(Nums), 0),
    check_array_recursive(Nums, ExtraDecs, K, 0, 1).

% The base case for recursion, when we've processed all elements.
check_array_recursive([], _, _, _, _) ->
    true;

% Process each element in the list.
check_array_recursive([H|T], ExtraDecs, K, AccumulatedDecs, Index) ->
    % Calculate the actual value after applying all decrements.
    ActualValue = H - AccumulatedDecs,
    % If the actual value is negative, it's impossible to make all elements zero.
    if ActualValue < 0 ->
        false;
    true ->
        % Calculate the new accumulated decrements and update ExtraDecs if needed.
        NewAccumulated = AccumulatedDecs + hd(ExtraDecs),
        NewExtraDecs = case length(ExtraDecs) >= K of
            true ->
                % Subtract the current decrement from the K-th next element.
                [NewDec || {NewDec, Idx} <- lists:zip(ExtraDecs, lists:seq(1, length(ExtraDecs))),
                          if Idx == K -> NewDec - ActualValue; true -> NewDec end];
            false ->
                ExtraDecs
        end,
        % Recurse with the tail of the list, updated ExtraDecs, and incremented index.
        check_array_recursive(T, tl(NewExtraDecs) ++ [ActualValue], K, NewAccumulated, Index + 1)
    end."
erlang,runtime_error,"Line 28: exception error: undef
[{lists,update_nth,[4,#Fun<solution.0.48684466>,[0,0,0,0,0,0]],[]},
 {solution,check_array_ops,5,[{file,""solution.erl""},{line,28}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,53}]},
 {solution,driver,0,[{file,""solution.erl""},{line,39}]},
 {solution,start,0,[{file,""solution.erl""},{line,70}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\apply-operations-to-make-all-array-elements-equal-to-zero\responses\Erlang\response_erlang_2_failed.json,"-spec check_array(Nums :: [integer()], K :: integer()) -> boolean().
check_array(Nums, K) ->
    % Length of the nums list
    N = length(Nums),
    % Initialize a dynamic array (list) to track the required operations on each element
    Ops = lists:duplicate(N, 0),
    check_array_ops(Nums, Ops, K, 1, 0).

check_array_ops([], _, _, _, _) ->
    true; % Successfully made all elements 0
check_array_ops([H|T], Ops, K, Index, Carry) when Index =< length(Ops) ->
    % Calculate the total decrements needed for the current element
    TotalDec = lists:nth(Index, Ops) + Carry,
    % Adjust the current element by the total decrements applied so far
    AdjustedH = H - TotalDec,
    % Check if it's possible to proceed
    if
        AdjustedH < 0 ->
            false; % Not possible to make all elements 0
        true ->
            % Calculate the new carry and update Ops if necessary
            NewCarry = if Index + K =< length(Ops) ->
                           lists:nth(Index + K, Ops) + AdjustedH;
                       true ->
                           0
                       end,
            NewOps = if Index + K =< length(Ops) ->
                         lists:update_nth(Index + K, fun(X) -> X + AdjustedH end, Ops);
                     true ->
                         Ops
                     end,
            check_array_ops(T, NewOps, K, Index + 1, NewCarry)
    end;
check_array_ops(_, _, _, _, _) ->
    false."
erlang,runtime_error,"Line 15: exception error: undef
[{lists,drop,[1,""1100011000""],[]},
 {solution,min_operations,4,[{file,""solution.erl""},{line,15}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,57}]},
 {solution,driver,0,[{file,""solution.erl""},{line,41}]},
 {solution,start,0,[{file,""solution.erl""},{line,74}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\apply-operations-to-make-two-strings-equal\responses\Erlang\response_erlang_2_failed.json,"-spec min_operations(S1 :: unicode:unicode_binary(), S2 :: unicode:unicode_binary(), X :: integer()) -> integer().
min_operations(S1, S2, X) ->
    min_operations(binary_to_list(S1), binary_to_list(S2), X, 0).

min_operations([], [], _, Cost) ->
    Cost;
min_operations([H1 | T1] = L1, [H2 | T2] = L2, X, Cost) ->
    case H1 == H2 of
        true ->
            min_operations(T1, T2, X, Cost);
        false ->
            case next_diff(L1, L2, 1) of
                {ok, Steps} when Steps > 0, X > 1 ->
                    %% If next difference is further than 1 step away and X is cost-effective for flipping
                    min_operations(skip(L1, Steps), skip(L2, Steps), X, Cost + 1);
                {ok, Steps} when Steps == 1 ->
                    %% Next difference is adjacent, flip adjacent at cost 1
                    min_operations(skip(L1, Steps), skip(L2, Steps), X, Cost + 1);
                _ ->
                    %% If no more differences or not cost-effective to flip, check if done or return -1
                    case (T1 == T2) of
                        true -> Cost;
                        false -> -1
                    end
            end
    end.

next_diff([H1 | T1], [H2 | T2], Steps) ->
    case H1 == H2 of
        true -> next_diff(T1, T2, Steps + 1);
        false -> {ok, Steps}
    end;
next_diff([], [], _) ->
    {done, 0}.

skip(List, N) ->
    lists:drop(N, List)."
erlang,runtime_error,"Line 8: exception error: badarg
[{erlang,hd,[[]],[{error_info,#{module => erl_erts_errors}}]},
 {solution,left_max_heights,2,[{file,""solution.erl""},{line,8}]},
 {solution,maximum_sum_of_heights,1,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,35}]},
 {solution,driver,0,[{file,""solution.erl""},{line,23}]},
 {solution,start,0,[{file,""solution.erl""},{line,52}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\beautiful-towers-i\responses\Erlang\response_erlang_2_failed.json,"-spec maximum_sum_of_heights(MaxHeights :: [integer()]) -> integer().
maximum_sum_of_heights(MaxHeights) ->
    LeftMax = left_max_heights(MaxHeights, []),
    RightMax = right_max_heights(lists:reverse(MaxHeights), []),
    CombinedMax = [min(L, R) || {L, R} <- lists:zip(LeftMax, lists:reverse(RightMax))],
    lists:sum(CombinedMax).

left_max_heights([H|T], Acc) when T =/= [] ->
    left_max_heights(T, [max(H, hd(Acc) + 1) | Acc]);
left_max_heights(_, Acc) ->
    lists:reverse(Acc).

right_max_heights([H|T], Acc) when T =/= [] ->
    right_max_heights(T, [max(H, hd(Acc) + 1) | Acc]);
right_max_heights(_, Acc) ->
    lists:reverse(Acc).

max(X, Y) ->
    if X > Y -> X; true -> Y end."
erlang,runtime_error,"Line 3: exception error: function_clause
[{solution,'-maximum_sum_of_heights/1-fun-0-',
              [5,[]],
              [{file,""solution.erl""},{line,3}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,maximum_sum_of_heights,1,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,23}]},
 {solution,driver,0,[{file,""solution.erl""},{line,11}]},
 {solution,start,0,[{file,""solution.erl""},{line,40}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\beautiful-towers-ii\responses\Erlang\response_erlang_2_failed.json,"-spec maximum_sum_of_heights(MaxHeights :: [integer()]) -> integer().
maximum_sum_of_heights(MaxHeights) ->
    Left = [0 | lists:foldl(fun(X, [H|T]) -> [min(X, H+1) | [H|T]] end, [], MaxHeights)],
    Right = lists:reverse([0 | lists:foldl(fun(X, [H|T]) -> [min(X, H+1) | [H|T]] end, [], lists:reverse(MaxHeights))]),
    Heights = lists:zipwith(fun(X, Y) -> min(X, Y) end, Left, Right),
    Sum = lists:zipwith(fun(X, Max) -> min(X-1, Max) end, Heights, MaxHeights),
    lists:sum(Sum)."
erlang,runtime_error,"Line 6: exception error: function_clause
[{solution,'-can_split_array/2-fun-0-',
              [#Fun<solution.0.108865315>,[2,2,1],4,[]],
              [{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,35}]},
 {solution,driver,0,[{file,""solution.erl""},{line,21}]},
 {solution,start,0,[{file,""solution.erl""},{line,52}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\check-if-it-is-possible-to-split-array\responses\Erlang\response_erlang_0_failed.json,"-spec can_split_array(Nums :: [integer()], M :: integer()) -> boolean().
can_split_array(Nums, M) ->
    % Define an inner function to check if it's possible to split the array
    % into subarrays according to the problem's rules.
    % This function will recursively check all possible splits.
    CheckSplit = fun(Check, [], _, _) -> false; % Base case: empty array cannot be split further
                      (Check, [X], _, _) -> true; % Base case: single element array is always valid
                      (Check, SubArray, M, Acc) when length(Acc) >= 1 ->
                          % Calculate the sum of the current subarray
                          Sum = lists:sum(SubArray),
                          % Check if the sum of the subarray meets the requirement
                          % or if we can recursively split the remaining array
                          Sum >= M orelse
                          Check(Check, tl(SubArray), M, [hd(SubArray)|Acc])
                      end,
    % Start checking from the full array and an empty accumulator for the split part
    CheckSplit(CheckSplit, Nums, M, [])."
erlang,runtime_error,"Line 11: exception error: function_clause
[{lists,nth,[0,[20,1,15]],[{file,""lists.erl""},{line,198}]},
 {solution,min_cost,7,[{file,""solution.erl""},{line,11}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,32}]},
 {solution,driver,0,[{file,""solution.erl""},{line,18}]},
 {solution,start,0,[{file,""solution.erl""},{line,49}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\collecting-chocolates\responses\Erlang\response_erlang_2_failed.json,"-spec min_cost(Nums :: [integer()], X :: integer()) -> integer().
min_cost(Nums, X) ->
    N = length(Nums),
    TotalCost = lists:sum(Nums),
    min_cost(Nums, N, X, TotalCost, 0, TotalCost, 0).

min_cost(_Nums, 0, _X, _TotalCost, _CurrentCost, MinCost, _Ops) ->
    MinCost;
min_cost(Nums, N, X, TotalCost, CurrentCost, MinCost, Ops) ->
    NewOps = Ops + 1,
    ShiftCost = (NewOps * X) + lists:nth(NewOps rem N, Nums),
    NewCurrentCost = CurrentCost - TotalCost + ShiftCost,
    NewMinCost = min(MinCost, NewCurrentCost),
    min_cost(Nums, N - 1, X, TotalCost, NewCurrentCost, NewMinCost, NewOps)."
erlang,runtime_error,"Line 15: exception error: badarg
[{lists,split,[-1,[]],[{file,""lists.erl""},{line,1815}]},
 {solution,continuous_subarrays,5,[{file,""solution.erl""},{line,15}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,33}]},
 {solution,driver,0,[{file,""solution.erl""},{line,21}]},
 {solution,start,0,[{file,""solution.erl""},{line,50}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\continuous-subarrays\responses\Erlang\response_erlang_0_failed.json,"-spec continuous_subarrays(Nums :: [integer()]) -> integer().
continuous_subarrays(Nums) ->
    continuous_subarrays(Nums, 0, 0, 0, []).

continuous_subarrays([], Count, _, _, _) ->
    Count;
continuous_subarrays([H|T], Count, Min, Max, Window) ->
    NewMin = min(H, Min),
    NewMax = max(H, Max),
    if
        NewMax - NewMin =< 2 ->
            NewCount = Count + length(Window) + 1,
            continuous_subarrays(T, NewCount, NewMin, NewMax, [H|Window]);
        true ->
            {_, NewWindow} = lists:split(length(Window) - 1, Window),
            continuous_subarrays([H|T], Count, lists:min(NewWindow), lists:max(NewWindow), tl(NewWindow))
    end."
erlang,runtime_error,"Line 6: exception error: undef
[{binary,foldl,[#Fun<solution.1.20365281>,{0,0},<<""b"">>],[]},
 {solution,'-beautiful_substrings/2-fun-3-',3,
              [{file,""solution.erl""},{line,6}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,37}]},
 {solution,driver,0,[{file,""solution.erl""},{line,23}]},
 {solution,start,0,[{file,""solution.erl""},{line,54}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\count-beautiful-substrings-i\responses\Erlang\response_erlang_2_failed.json,"-spec beautiful_substrings(S :: unicode:unicode_binary(), K :: integer()) -> integer().
beautiful_substrings(S, K) ->
    Substrs = [binary:part(S, Start, Length) || Start <- lists:seq(0, byte_size(S) - 1),
                                                Length <- lists:seq(1, byte_size(S) - Start)],
    CountBeautifulSubstrs = fun(Str, Acc) ->
        {Vowels, Consonants} = binary:foldl(fun(Char, {V, C}) ->
            case lists:member(Char, ""aeiou"") of
                true -> {V + 1, C};
                false -> {V, C + 1}
            end
        end, {0, 0}, Str),
        if
            Vowels == Consonants, (Vowels * Consonants) rem K == 0 ->
                Acc + 1;
            true ->
                Acc
        end
    end,
    lists:foldl(CountBeautifulSubstrs, 0, Substrs)."
erlang,runtime_error,"Line 35: exception error: {case_clause,#{0 => 1,1 => 3}}
[{lists,foldl,3,[{file,""lists.erl""},{line,1593}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,35}]},
 {solution,driver,0,[{file,""solution.erl""},{line,19}]},
 {solution,start,0,[{file,""solution.erl""},{line,52}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\count-of-interesting-subarrays\responses\Erlang\response_erlang_1_failed.json,"-spec count_interesting_subarrays(Nums :: [integer()], Modulo :: integer(), K :: integer()) -> integer().
count_interesting_subarrays(Nums, Modulo, K) ->
    PrefixSums = lists:foldl(fun(X, {Sum, Acc}) ->
                                NewSum = (Sum + if X rem Modulo == K -> 1; true -> 0 end) rem Modulo,
                                {NewSum, [NewSum | Acc]}
                             end, {0, [0]}, Nums),
    Counts = lists:foldl(fun(X, Acc) -> maps:update_with(X, fun(V) -> V + 1 end, 1, Acc) end, #{}, element(2, PrefixSums)),
    lists:foldl(fun(X, Acc) ->
                    maps:fold(fun(K, V, InnerAcc) ->
                                if 
                                    X == K -> InnerAcc;
                                    true -> InnerAcc + V * maps:get((X - K + Modulo) rem Modulo, Counts, 0)
                                end
                              end, Acc, Counts)
                end, 0, Counts)."
erlang,runtime_error,"Line 4: exception error: function_clause
[{solution,'-count_pairs/2-inlined-1-',
              [[1,2],0],
              [{file,""solution.erl""},{line,4}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,count_pairs,2,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,27}]},
 {solution,driver,0,[{file,""solution.erl""},{line,13}]},
 {solution,start,0,[{file,""solution.erl""},{line,44}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\count-pairs-of-points-with-distance-k\responses\Erlang\response_erlang_0_failed.json,"-spec count_pairs(Coordinates :: [[integer()]], K :: integer()) -> integer().
count_pairs(Coordinates, K) ->
    lists:foldl(fun({X, Y}, Acc) ->
                    lists:foldl(fun({X1, Y1}, Acc1) ->
                                    Distance = (X bxor X1) + (Y bxor Y1),
                                    if Distance == K -> Acc1 + 1; true -> Acc1 end
                                end, Acc, Coordinates)
                end, 0, lists:zip(Coordinates, lists:seq(1, length(Coordinates))))
    div 2."
erlang,runtime_error,"Line 4: exception error: function_clause
[{solution,'-count_pairs/2-inlined-0-',
              [[1,2],0],
              [{file,""solution.erl""},{line,4}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,32}]},
 {solution,driver,0,[{file,""solution.erl""},{line,18}]},
 {solution,start,0,[{file,""solution.erl""},{line,49}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\count-pairs-of-points-with-distance-k\responses\Erlang\response_erlang_1_failed.json,"-spec count_pairs(Coordinates :: [[integer()]], K :: integer()) -> integer().
count_pairs(Coordinates, K) ->
    Count = fun(Idx, CountAcc) ->
                lists:foldl(fun({X, Y}, Acc) ->
                                case Idx of
                                    {X1, Y1, Idx1} when Idx1 < length(Coordinates) ->
                                        Distance = (X bxor X1) + (Y bxor Y1),
                                        if Distance == K -> Acc + 1; true -> Acc end;
                                    _ ->
                                        Acc
                                end
                            end, CountAcc, Coordinates)
            end,
    lists:foldl(fun({Coord, Idx}, Acc) -> Count({Coord, Idx}, Acc) end, 0, lists:zip(Coordinates, lists:seq(0, length(Coordinates) - 1)))."
erlang,runtime_error,"Line 6: exception error: function_clause
[{lists,seq,[0,-3],[{file,""lists.erl""},{line,280}]},
 {solution,beautiful_indices,4,[{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,31}]},
 {solution,driver,0,[{file,""solution.erl""},{line,13}]},
 {solution,start,0,[{file,""solution.erl""},{line,48}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\find-beautiful-indices-in-the-given-array-i\responses\Erlang\response_erlang_0_failed.json,"-spec beautiful_indices(S :: unicode:unicode_binary(), A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), K :: integer()) -> [integer()].
beautiful_indices(S, A, B, K) ->
    SList = binary:bin_to_list(S),
    AList = binary:bin_to_list(A),
    BList = binary:bin_to_list(B),
    IndicesA = [I || I <- lists:seq(0, length(SList) - length(AList)), AList == lists:sublist(SList, I+1, length(AList))],
    IndicesB = [J || J <- lists:seq(0, length(SList) - length(BList)), BList == lists:sublist(SList, J+1, length(BList))],
    BeautifulIndices = [IdxA || IdxA <- IndicesA, IdxB <- IndicesB, abs(IdxA - IdxB) =< K],
    lists:usort(BeautifulIndices)."
erlang,runtime_error,"Line 4: exception error: badarg
[{erlang,length,[<<""my"">>],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-beautiful_indices/4-fun-1-',2,
              [{file,""solution.erl""},{line,4}]},
 {solution,beautiful_indices,4,[{file,""solution.erl""},{line,8}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,37}]},
 {solution,driver,0,[{file,""solution.erl""},{line,19}]},
 {solution,start,0,[{file,""solution.erl""},{line,54}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\find-beautiful-indices-in-the-given-array-i\responses\Erlang\response_erlang_2_failed.json,"-spec beautiful_indices(S :: unicode:unicode_binary(), A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), K :: integer()) -> [integer()].
beautiful_indices(S, A, B, K) ->
    FindMatches = fun(Pattern, String) ->
                      PatternLen = length(Pattern),
                      [I || I <- lists:seq(0, byte_size(String) - PatternLen),
                       Pattern == binary:part(String, {I, PatternLen})]
                  end,
    IndicesA = FindMatches(A, S),
    IndicesB = FindMatches(B, S),
    FilteredIndicesA = lists:filter(fun(IdxA) ->
                                         lists:any(fun(IdxB) ->
                                                       abs(IdxA - IdxB) =< K
                                                   end, IndicesB)
                                     end, IndicesA),
    lists:sort(FilteredIndicesA)."
erlang,runtime_error,"Line 3: exception error: badarg
[{erlang,bit_size,[[<<0:1>>]],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-can_sort_array/1-lc$^0/1-0-',1,
              [{file,""solution.erl""},{line,3}]},
 {solution,can_sort_array,1,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,22}]},
 {solution,driver,0,[{file,""solution.erl""},{line,10}]},
 {solution,start,0,[{file,""solution.erl""},{line,39}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\find-if-array-can-be-sorted\responses\Erlang\response_erlang_0_failed.json,"-spec can_sort_array(Nums :: [integer()]) -> boolean().
can_sort_array(Nums) ->
    Counts = [erlang:bit_size(erlang:bitstring_to_list(<<X:1>>)) || X <- Nums],
    Sorted = lists:sort(Counts),
    Zipped = lists:zip(Counts, Sorted),
    lists:all(fun({A, B}) -> A == B end, Zipped)."
erlang,runtime_error,"Line 11: exception error: function_clause
[{lists,nth,[0,[5,1,4,1]],[{file,""lists.erl""},{line,198}]},
 {solution,find_pair,6,[{file,""solution.erl""},{line,11}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,44}]},
 {solution,driver,0,[{file,""solution.erl""},{line,28}]},
 {solution,start,0,[{file,""solution.erl""},{line,61}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\find-indices-with-index-and-value-difference-ii\responses\Erlang\response_erlang_0_failed.json,"-spec find_indices(Nums :: [integer()], IndexDifference :: integer(), ValueDifference :: integer()) -> [integer()].
find_indices(Nums, IndexDifference, ValueDifference) ->
    find_indices_helper(Nums, IndexDifference, ValueDifference, 0, length(Nums) - 1).

find_indices_helper(Nums, IndexDifference, ValueDifference, Start, End) when Start =< End ->
    find_pair(Nums, IndexDifference, ValueDifference, Start, Start + IndexDifference, length(Nums));
find_indices_helper(_, _, _, _, _) ->
    [-1, -1].

find_pair(Nums, IndexDifference, ValueDifference, I, J, Len) when J < Len ->
    case abs(Nums -- [lists:nth(I, Nums)] -- [lists:nth(J, Nums)]) >= ValueDifference of
        true -> [I, J];
        false -> 
            case J + 1 < Len of
                true -> find_pair(Nums, IndexDifference, ValueDifference, I, J + 1, Len);
                false ->
                    case I + 1 =< Len - IndexDifference of
                        true -> find_pair(Nums, IndexDifference, ValueDifference, I + 1, I + 1 + IndexDifference, Len);
                        false -> [-1, -1]
                    end
            end
    end;
find_pair(_, _, _, _, _, _) ->
    [-1, -1]."
erlang,runtime_error,"Line 10: exception error: function_clause
[{solution,'-find_max/3-fun-1-',[4],[{file,""solution.erl""},{line,10}]},
 {lists,any,2,[{file,""lists.erl""},{line,1535}]},
 {solution,find_max,3,[{file,""solution.erl""},{line,10}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,43}]},
 {solution,driver,0,[{file,""solution.erl""},{line,31}]},
 {solution,start,0,[{file,""solution.erl""},{line,60}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\find-longest-special-substring-that-occurs-thrice-i\responses\Erlang\response_erlang_2_failed.json,"-spec maximum_length(S :: unicode:unicode_binary()) -> integer().
maximum_length(S) ->
    find_max(S, -1, 1).

find_max(S, Max, Len) when Len =< byte_size(S) div 3 ->
    Occurrences = [begin
                       Sub = binary:part(S, Index, Len),
                       Count = count_occurrences(S, Sub, 0, 0)
                   end || Index <- lists:seq(0, byte_size(S) - Len)],
    NewMax = case lists:any(fun({_, Count}) -> Count >= 3 end, Occurrences) of
                 true -> Len;
                 false -> Max
             end,
    find_max(S, NewMax, Len + 1);
find_max(_S, Max, _Len) ->
    case Max of
        -1 -> -1;
        _ -> Max
    end.

count_occurrences(S, Sub, Index, Count) when Index + byte_size(Sub) =< byte_size(S) ->
    case binary:part(S, Index, byte_size(Sub)) of
        Sub -> count_occurrences(S, Sub, Index + 1, Count + 1);
        _ -> count_occurrences(S, Sub, Index + 1, Count)
    end;
count_occurrences(_S, _Sub, _Index, Count) ->
    Count."
erlang,runtime_error,"Line 7: exception error: function_clause
[{solution,largest_perimeter_helper,
              [[]],
              [{file,""solution.erl""},{line,7}]},
 {solution,largest_perimeter_helper,1,[{file,""solution.erl""},{line,8}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,28}]},
 {solution,driver,0,[{file,""solution.erl""},{line,16}]},
 {solution,start,0,[{file,""solution.erl""},{line,45}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\find-polygon-with-the-largest-perimeter\responses\Erlang\response_erlang_0_failed.json,"-spec largest_perimeter(Nums :: [integer()]) -> integer().
largest_perimeter(Nums) ->
    Sorted = lists:sort(Nums),
    largest_perimeter_helper(Sorted).

-spec largest_perimeter_helper(SortedNums :: [integer()]) -> integer().
largest_perimeter_helper([A, B, C | T]) when A + B > C ->
    max(C + A + B, largest_perimeter_helper([B, C | T]));
largest_perimeter_helper([_, _, _]) ->
    -1;
largest_perimeter_helper([_ | T]) ->
    largest_perimeter_helper(T)."
erlang,runtime_error,"Line 15: exception error: badarg
[{erlang,list_to_integer,
         [<<""0621"">>],
         [{error_info,#{module => erl_erts_errors}}]},
 {solution,'-find_high_access_employees/1-fun-2-',2,
              [{file,""solution.erl""},{line,15}]},
 {lists,any,2,[{file,""lists.erl""},{line,1535}]},
 {lists,'-filter/2-lc$^0/1-0-',2,[{file,""lists.erl""},{line,1627}]},
 {solution,'-find_high_access_employees/1-fun-4-',2,
              [{file,""solution.erl""},{line,12}]},
 {lists,any,2,[{file,""lists.erl""},{line,1535}]},
 {lists,'-filter/2-lc$^0/1-0-',2,[{file,""lists.erl""},{line,1627}]},
 {solution,find_high_access_employees,1,
              [{file,""solution.erl""},{line,10}]}]",../questions/Medium\high-access-employees\responses\Erlang\response_erlang_0_failed.json,"-spec find_high_access_employees(Access_times :: [[unicode:unicode_binary()]]) -> [unicode:unicode_binary()].
find_high_access_employees(Access_times) ->
    Sorted = lists:sort(fun([_, A], [_, B]) -> A < B end, Access_times),
    Groups = lists:foldl(fun(E, Acc) ->
                             case Acc of
                                 [] -> [[E]];
                                 [H | T] -> [ [E | H] | T ]
                             end
                         end, [], Sorted),
    Filt = lists:filter(fun(Group) ->
                            lists:any(fun([Name, _]) ->
                                          Count = length(lists:filter(fun([N, T]) ->
                                                                           N == Name andalso
                                                                           lists:any(fun([_, OT]) ->
                                                                                          TimeDiff = abs(list_to_integer(T) - list_to_integer(OT)),
                                                                                          TimeDiff > 0 andalso TimeDiff < 100
                                                                                      end, Group)
                                                                       end, Group)),
                                          Count >= 3
                                      end, Group)
                        end, Groups),
    lists:usort(lists:map(fun([Name, _]) -> Name end, lists:flatten(Filt)))."
erlang,runtime_error,"Line 28: exception error: function_clause
[{solution,drop_elements,[[],4],[{file,""solution.erl""},{line,28}]},
 {solution,shrink_window,5,[{file,""solution.erl""},{line,20}]},
 {solution,max_subarray_length,5,[{file,""solution.erl""},{line,9}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,47}]},
 {solution,driver,0,[{file,""solution.erl""},{line,33}]},
 {solution,start,0,[{file,""solution.erl""},{line,64}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\length-of-longest-subarray-with-at-most-k-frequency\responses\Erlang\response_erlang_1_failed.json,"-spec max_subarray_length(Nums :: [integer()], K :: integer()) -> integer().
max_subarray_length(Nums, K) ->
    max_subarray_length(Nums, K, #{}, 0, {0,0}).

max_subarray_length([], _K, _Counts, MaxLen, {_Start, End}) ->
    MaxLen;
max_subarray_length([H|T], K, Counts, MaxLen, {Start, End}) ->
    NewCounts = update_counts(Counts, H, 1),
    {NewStart, NewEnd, ValidCounts} = shrink_window(NewCounts, K, [H|T], Start, End),
    NewMaxLen = max(MaxLen, NewEnd - NewStart),
    max_subarray_length(T, K, ValidCounts, NewMaxLen, {NewStart, NewEnd + 1}).

update_counts(Counts, Key, Val) ->
    maps:update_with(Key, fun(C) -> C + Val end, Val, Counts).

shrink_window(Counts, K, Nums, Start, End) ->
    case is_good(Counts, K) of
        true -> {Start, End, Counts};
        false ->
            [First|Rest] = drop_elements(Nums, End - Start),
            NewCounts = update_counts(Counts, First, -1),
            shrink_window(NewCounts, K, Rest, Start + 1, End)
    end.

is_good(Counts, K) ->
    not lists:any(fun({_Key, Val}) -> Val > K end, maps:to_list(Counts)).

drop_elements(Nums, 0) -> Nums;
drop_elements([_H|T], N) when N > 0 -> drop_elements(T, N-1)."
erlang,runtime_error,"Line 12: exception error: function_clause
[{solution,pick_next,[[2,1],[],3],[{file,""solution.erl""},{line,12}]},
 {solution,create_smallest_array,4,[{file,""solution.erl""},{line,9}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,34}]},
 {solution,driver,0,[{file,""solution.erl""},{line,20}]},
 {solution,start,0,[{file,""solution.erl""},{line,51}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\make-lexicographically-smallest-array-by-swapping-elements\responses\Erlang\response_erlang_0_failed.json,"-spec lexicographically_smallest_array(Nums :: [integer()], Limit :: integer()) -> [integer()].
lexicographically_smallest_array(Nums, Limit) ->
    Sorted = lists:sort(Nums),
    create_smallest_array(Nums, Sorted, Limit, []).

create_smallest_array([], _, _, Acc) ->
    lists:reverse(Acc);
create_smallest_array([H|T], Sorted, Limit, Acc) ->
    {Next, Rest} = pick_next([H|T], Sorted, Limit),
    create_smallest_array(T, Rest, Limit, [Next|Acc]).

pick_next(Nums, [H|T], Limit) ->
    case lists:any(fun(X) -> abs(X - H) =< Limit end, Nums) of
        true -> {H, T};
        false -> pick_next(Nums, T, Limit)
    end."
erlang,runtime_error,"Line 4: exception error: function_clause
[{solution,'-maximum_beauty/2-inlined-0-',
              [1,{0,[]}],
              [{file,""solution.erl""},{line,4}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,maximum_beauty,2,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,28}]},
 {solution,driver,0,[{file,""solution.erl""},{line,14}]},
 {solution,start,0,[{file,""solution.erl""},{line,45}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\maximum-beauty-of-an-array-after-applying-operation\responses\Erlang\response_erlang_0_failed.json,"-spec maximum_beauty(Nums :: [integer()], K :: integer()) -> integer().
maximum_beauty(Nums, K) ->
    Sorted = lists:sort(Nums),
    MaxBeauty = lists:foldl(fun(X, {Max, [H|T] = Acc}) ->
                                case X - H =< 2*K of
                                    true -> {Max, [X|Acc]};
                                    false -> {max(Max, length(Acc)), [X|lists:droplast(Acc)]}
                                end
                            end, {0, []}, Sorted),
    max(MaxBeauty, length(Sorted))."
erlang,runtime_error,"Line 8: exception error: {badmatch,{6,4}}
[{solution,'-max_number_of_alloys/6-fun-1-',5,
              [{file,""solution.erl""},{line,8}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,38}]},
 {solution,driver,0,[{file,""solution.erl""},{line,16}]},
 {solution,start,0,[{file,""solution.erl""},{line,55}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\maximum-number-of-alloys\responses\Erlang\response_erlang_0_failed.json,"-spec max_number_of_alloys(N :: integer(), K :: integer(), Budget :: integer(), Composition :: [[integer()]], Stock :: [integer()], Cost :: [integer()]) -> integer().
max_number_of_alloys(N, K, Budget, Composition, Stock, Cost) ->
    MaxAlloys = lists:foldl(fun(MachineComp, Acc) ->
                                TotalCosts = lists:foldl(fun(Req, {Sum, Idx}) ->
                                                             Needed = max(Req - lists:nth(Idx, Stock), 0),
                                                             {Sum + Needed * lists:nth(Idx, Cost), Idx + 1}
                                                         end, {0, 1}, MachineComp),
                                {Cost, _} = TotalCosts,
                                Alloys = if Cost =< Budget -> floor(Budget / Cost); true -> 0 end,
                                max(Acc, Alloys)
                            end, 0, Composition),
    MaxAlloys."
erlang,runtime_error,"exception throw: {invalid_user_return_value,{2,0,6},""integer()""}",../questions/Medium\maximum-number-of-jumps-to-reach-the-last-index\responses\Erlang\response_erlang_1_failed.json,"-spec maximum_jumps(Nums :: [integer()], Target :: integer()) -> integer().
maximum_jumps(Nums, Target) ->
    lists:foldl(fun(Num, {MaxJumps, Jumps, PrevMax}) ->
                        if 
                            Num - PrevMax > Target -> {-1, Jumps + 1, Num};
                            true -> {max(MaxJumps, Jumps + 1), 0, PrevMax}
                        end
                end, {0, 0, hd(Nums)}, tl(Nums))."
erlang,runtime_error,"Line 16: exception error: function_clause
[{solution,check_jumps,
              [[1,3,6,4,1,2],2,[0],[-1,-1,-1,-1,-1,-1],1,0],
              [{file,""solution.erl""},{line,16}]},
 {solution,driver,0,[{file,""solution.erl""},{line,33}]},
 {solution,start,0,[{file,""solution.erl""},{line,64}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\maximum-number-of-jumps-to-reach-the-last-index\responses\Erlang\response_erlang_2_failed.json,"-spec maximum_jumps(Nums :: [integer()], Target :: integer()) -> integer().
maximum_jumps(Nums, Target) ->
    dp(Nums, Target, [0], lists:duplicate(length(Nums), -1), 1, 0).

dp(_Nums, _Target, _, Jumps, _, _) when element(1, hd(Jumps)) == -1 -> 
    -1;
dp(Nums, Target, [{Index, J}|Q], Jumps, I, MaxJ) when I == length(Nums) -> 
    MaxJ;
dp(Nums, Target, Q, Jumps, I, MaxJ) ->
    {Num, NewQ, NewJumps, NewMaxJ} = case lists:nth(I, Jumps) of
        -1 -> check_jumps(Nums, Target, Q, Jumps, I, MaxJ);
        J -> {lists:nth(I, Nums), Q, Jumps, max(MaxJ, J)}
    end,
    dp(Nums, Target, NewQ, NewJumps, I + 1, NewMaxJ).

check_jumps(Nums, Target, [], Jumps, _, MaxJ) -> 
    {lists:last(Nums), [], Jumps, MaxJ};
check_jumps(Nums, Target, [{Index, J}|Q], Jumps, I, MaxJ) ->
    Current = lists:nth(I, Nums),
    Prev = lists:nth(Index + 1, Nums),
    if 
        abs(Current - Prev) =< Target ->
            NewJ = J + 1,
            NewJumps = lists:update_nth(I, fun(_) -> NewJ end, Jumps),
            NewQ = Q ++ [{I - 1, NewJ}],
            check_jumps(Nums, Target, NewQ, NewJumps, I, max(MaxJ, NewJ));
        true -> 
            check_jumps(Nums, Target, Q, Jumps, I, MaxJ)
    end."
erlang,runtime_error,"Line 27: exception error: badarg
[{erlang,bit_size,[[<<1:1>>]],[{error_info,#{module => erl_erts_errors}}]},
 {solution,sum_prices,4,[{file,""solution.erl""},{line,27}]},
 {solution,find_maximum,5,[{file,""solution.erl""},{line,7}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,55}]},
 {solution,driver,0,[{file,""solution.erl""},{line,41}]},
 {solution,start,0,[{file,""solution.erl""},{line,72}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k\responses\Erlang\response_erlang_1_failed.json,"-spec find_maximum_number(K :: integer(), X :: integer()) -> integer().
find_maximum_number(K, X) ->
    find_maximum(0, K, X, 1, K).

find_maximum(Sum, K, X, Low, High) when High >= Low ->
    Mid = Low + (High - Low) div 2,
    CurrentSum = sum_prices(Mid, X),
    if
        CurrentSum == K ->
            Mid;
        CurrentSum < K ->
            find_maximum(CurrentSum, K, X, Mid + 1, High);
        CurrentSum > K ->
            find_maximum(Sum, K, X, Low, Mid - 1)
    end;
find_maximum(_, _, _, _, High) ->
    High.

sum_prices(Num, X) ->
    sum_prices(Num, X, 1, 0).

sum_prices(0, _, _, Acc) ->
    Acc;
sum_prices(Num, X, Index, Acc) ->
    if
        Index rem X == 0 ->
            Bits = bit_size(erlang:bitstring_to_list(<<Num:Index>>)),
            NewAcc = Acc + Bits;
        true ->
            NewAcc = Acc
    end,
    if
        Num == Index ->
            NewAcc;
        true ->
            sum_prices(Num, X, Index + 1, NewAcc)
    end."
erlang,runtime_error,"Line 3: exception error: function_clause
[{solution,'-max_sum/3-fun-0-',
              [#Fun<solution.0.93189031>,[3,1,7],3,4],
              [{file,""solution.erl""},{line,3}]},
 {solution,'-max_sum/3-fun-0-',4,[{file,""solution.erl""},{line,7}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,31}]},
 {solution,driver,0,[{file,""solution.erl""},{line,15}]},
 {solution,start,0,[{file,""solution.erl""},{line,48}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\maximum-sum-of-almost-unique-subarray\responses\Erlang\response_erlang_0_failed.json,"-spec max_sum(Nums :: [integer()], M :: integer(), K :: integer()) -> integer().
max_sum(Nums, M, K) ->
    MaxSum = fun(MaxSum, [_|_] = Nums, M, K) when length(Nums) >= K ->
                Subarray = lists:sublist(Nums, K),
                UniqueCount = length(lists:usort(Subarray)),
                Sum = lists:sum(Subarray),
                NextSum = MaxSum(MaxSum, tl(Nums), M, K),
                if UniqueCount >= M -> max(Sum, NextSum); true -> NextSum end;
             (_, [], _, _) -> 0
    end,
    MaxSum(MaxSum, Nums, M, K)."
erlang,runtime_error,"Line 3: exception error: function_clause
[{solution,'-max_sum/3-fun-0-',
              [#Fun<solution.0.31948021>,[3,1,7],3,4],
              [{file,""solution.erl""},{line,3}]},
 {solution,'-max_sum/3-fun-0-',4,[{file,""solution.erl""},{line,9}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,34}]},
 {solution,driver,0,[{file,""solution.erl""},{line,18}]},
 {solution,start,0,[{file,""solution.erl""},{line,51}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\maximum-sum-of-almost-unique-subarray\responses\Erlang\response_erlang_1_failed.json,"-spec max_sum(Nums :: [integer()], M :: integer(), K :: integer()) -> integer().
max_sum(Nums, M, K) ->
    MaxSum = fun MaxSum(_, [], _, _) -> 0;
                 MaxSum(Self, Nums, M, K) when length(Nums) >= K ->
                    Subarray = lists:sublist(Nums, 1, K),
                    UniqueCount = length(lists:usort(Subarray)),
                    Sum = lists:sum(Subarray),
                    NextNums = tl(Nums),
                    NextSum = Self(Self, NextNums, M, K),
                    if UniqueCount >= M -> max(Sum, NextSum);
                       true -> NextSum
                    end
             end,
    MaxSum(MaxSum, Nums, M, K)."
erlang,runtime_error,"Line 16: exception error: badarith
[{erlang,'-',[infinity],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-maximum_triplet_value/1-fun-3-',3,
              [{file,""solution.erl""},{line,16}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,36}]},
 {solution,driver,0,[{file,""solution.erl""},{line,24}]},
 {solution,start,0,[{file,""solution.erl""},{line,53}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\maximum-value-of-an-ordered-triplet-ii\responses\Erlang\response_erlang_1_failed.json,"-spec maximum_triplet_value(Nums :: [integer()]) -> integer().
maximum_triplet_value(Nums) ->
    MaxK = lists:duplicate(length(Nums), 0),
    MaxKUpdated = lists:foldr(
        fun(X, [H|T]) -> [max(X, H)|[H|T]] end,
        [0],
        lists:reverse(tl(Nums))),
    {MaxIJ, _} = lists:foldl(
        fun(X, {Max, [H|T]}) ->
            {max(Max, X * H), T}
        end,
        {0, MaxKUpdated},
        tl(lists:reverse(Nums))),
    lists:foldl(
        fun(X, Acc) ->
            MaxJ = lists:foldl(fun(Y, Max) -> max(X - Y, Max) end, -infinity, Nums),
            max(MaxJ * X, Acc)
        end,
        MaxIJ,
        tl(Nums))."
erlang,runtime_error,"Line 3: exception error: function_clause
[{lists,foldl,
        [#Fun<solution.0.30668777>,#{},
         [{97,98,2},{98,99,5},{99,98,5},{99,101,1},{101,98,2},{100,101,20}]],
        [{file,""lists.erl""},{line,1592}]},
 {solution,minimum_cost,5,[{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,39}]},
 {solution,driver,0,[{file,""solution.erl""},{line,19}]},
 {solution,start,0,[{file,""solution.erl""},{line,56}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-cost-to-convert-string-i\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [char()], Changed :: [char()], Cost :: [integer()]) -> integer().
minimum_cost(Source, Target, Original, Changed, Cost) ->
    Maps = lists:foldl(fun(O, C, Z, Acc) ->
                           maps:put({O, C}, Z, Acc)
                       end, #{}, lists:zip3(Original, Changed, Cost)),
    try
        lists:foldl(fun({S, T}, Acc) ->
                        case maps:find({S, T}, Maps) of
                            {ok, Cost} -> Acc + Cost;
                            error -> throw({error, impossible})
                        end
                    end, 0, lists:zip(binary_to_list(Source), binary_to_list(Target)))
    catch
        throw:{error, impossible} -> -1
    end."
erlang,runtime_error,"Line 15: exception error: {case_clause,{ok,5}}
[{solution,'-minimum_cost/5-fun-1-',4,[{file,""solution.erl""},{line,15}]},
 {lists,foldl_1,3,[{file,""lists.erl""},{line,1599}]},
 {solution,minimum_cost,5,[{file,""solution.erl""},{line,13}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,46}]},
 {solution,driver,0,[{file,""solution.erl""},{line,26}]},
 {solution,start,0,[{file,""solution.erl""},{line,63}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-cost-to-convert-string-i\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_cost(Source :: unicode:unicode_binary(), Target :: unicode:unicode_binary(), Original :: [char()], Changed :: [char()], Cost :: [integer()]) -> integer().
minimum_cost(Source, Target, Original, Changed, Cost) ->
    Maps = lists:foldl(fun({O, C, Z}, Acc) ->
                           Map = case maps:find({O, C}, Acc) of
                                     {ok, ExistingZ} -> Acc#{ {O, C} => min(ExistingZ, Z) };
                                     error -> Acc#{ {O, C} => Z }
                                 end,
                           Map
                       end, #{}, lists:zip3(Original, Changed, Cost)),
    SourceList = binary_to_list(Source),
    TargetList = binary_to_list(Target),
    try
        lists:foldl(fun({S, T}, Acc) when S == T -> Acc;
                       ({S, T}, Acc) ->
                           case maps:find({S, T}, Maps) of
                               {ok, Cost} -> Acc + Cost;
                               error -> throw({error, impossible})
                           end
                    end, 0, lists:zip(SourceList, TargetList))
    catch
        throw:{error, impossible} -> -1
    end."
erlang,runtime_error,"Line 11: exception error: function_clause
[{solution,'-minimum_cost/1-fun-1-',
              [48,4],
              [{file,""solution.erl""},{line,11}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,minimum_cost,1,[{file,""solution.erl""},{line,11}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,35}]},
 {solution,driver,0,[{file,""solution.erl""},{line,23}]},
 {solution,start,0,[{file,""solution.erl""},{line,52}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-cost-to-make-all-characters-equal\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_cost(S :: unicode:unicode_binary()) -> integer().
minimum_cost(S) ->
    Bin = binary:bin_to_list(S),
    N = length(Bin),
    Counts = lists:foldl(fun(X, {ZeroCount, OneCount}) -> 
                            if 
                                X == $0 -> {ZeroCount + 1, OneCount}; 
                                true -> {ZeroCount, OneCount + 1} 
                            end 
                         end, {0, 0}, Bin),
    MinCost = lists:foldl(fun(X, {Cost, ZeroCount, OneCount}) -> 
                            {NewCost, NewZeroCount, NewOneCount} = 
                                if 
                                    X == $0 -> {Cost + OneCount, ZeroCount + 1, OneCount};
                                    true -> {Cost + ZeroCount, ZeroCount, OneCount - 1}
                                end,
                            min(Cost, NewCost)
                          end, N, Bin),
    min(element(1, Counts), MinCost)."
erlang,runtime_error,"Line 11: exception error: {bad_filter,0}
[{solution,'-minimum_index/1-lc$^3/1-2-',5,
              [{file,""solution.erl""},{line,11}]},
 {solution,minimum_index,1,[{file,""solution.erl""},{line,10}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,34}]},
 {solution,driver,0,[{file,""solution.erl""},{line,22}]},
 {solution,start,0,[{file,""solution.erl""},{line,51}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-index-of-a-valid-split\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_index(Nums :: [integer()]) -> integer().
minimum_index(Nums) ->
    DomElem = lists:max([ {X, length([Y || Y <- Nums, Y == X])} || X <- Nums]),
    DomVal = element(1, DomElem),
    DomFreq = element(2, DomElem),
    Len = length(Nums),
    case DomFreq * 2 > Len of
        false -> -1;
        true ->
            SplitRes = [I || I <- lists:seq(0, Len - 2),
                FreqLeft = length([X || X <- lists:sublist(Nums, I + 1), X == DomVal]),
                FreqRight = DomFreq - FreqLeft,
                FreqLeft * 2 > I + 1 andalso FreqRight * 2 > Len - I - 1],
            case SplitRes of
                [] -> -1;
                [FirstValidSplit|_] -> FirstValidSplit
            end
    end."
erlang,runtime_error,"Line 5: exception error: undef
[{lists,max_by,[#Fun<solution.1.34047085>,[{1,1},{2,3}]],[]},
 {solution,minimum_index,1,[{file,""solution.erl""},{line,5}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,43}]},
 {solution,driver,0,[{file,""solution.erl""},{line,31}]},
 {solution,start,0,[{file,""solution.erl""},{line,60}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-index-of-a-valid-split\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_index(Nums :: [integer()]) -> integer().
minimum_index(Nums) ->
    Count = fun(X, Acc) -> maps:update_with(X, fun(C) -> C + 1 end, 1, Acc) end,
    Freqs = lists:foldl(Count, #{}, Nums),
    {DomElem, _} = lists:max_by(fun({_Key, Value}) -> Value end, maps:to_list(Freqs)),
    Len = length(Nums),
    DomFreq = maps:get(DomElem, Freqs),
    TrySplit = lists:foldl(
        fun(Elem, {Acc, LeftFreq, RightFreq}) ->
            NewLeftFreq = case Elem == DomElem of
                true -> LeftFreq + 1;
                false -> LeftFreq
            end,
            NewRightFreq = RightFreq - 1,
            NewAcc = case NewLeftFreq * 2 > Acc andalso NewRightFreq * 2 > (Len - Acc - 1) of
                true -> Acc;
                false -> Acc + 1
            end,
            {NewAcc, NewLeftFreq, NewRightFreq}
        end,
        {0, 0, DomFreq},
        Nums
    ),
    case TrySplit of
        {Split, _, _} when Split < Len - 1 -> Split;
        _ -> -1
    end."
erlang,runtime_error,"Line 9: exception error: badarg
[{lists,split,[1,[]],[{file,""lists.erl""},{line,1812}]},
 {solution,minimum_coins,3,[{file,""solution.erl""},{line,9}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,26}]},
 {solution,driver,0,[{file,""solution.erl""},{line,14}]},
 {solution,start,0,[{file,""solution.erl""},{line,43}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-number-of-coins-for-fruits\responses\Erlang\response_erlang_0_failed.json,"-spec minimum_coins(Prices :: [integer()]) -> integer().
minimum_coins(Prices) ->
    minimum_coins(Prices, 1, 0).

minimum_coins([], _, Acc) ->
    Acc;
minimum_coins([H|T], Skip, Acc) ->
    NewAcc = Acc + H,
    {_, NewT} = lists:split(Skip, T),
    minimum_coins(NewT, 1, NewAcc)."
erlang,runtime_error,"Line 9: exception error: badarg
[{lists,split,[1,[]],[{file,""lists.erl""},{line,1812}]},
 {solution,minimum_coins,3,[{file,""solution.erl""},{line,9}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,26}]},
 {solution,driver,0,[{file,""solution.erl""},{line,14}]},
 {solution,start,0,[{file,""solution.erl""},{line,43}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-number-of-coins-for-fruits\responses\Erlang\response_erlang_1_failed.json,"-spec minimum_coins(Prices :: [integer()]) -> integer().
minimum_coins(Prices) ->
    minimum_coins(Prices, 1, 0).

minimum_coins([], _, Acc) ->
    Acc;
minimum_coins([H|T], Skip, Acc) when length(T) >= Skip; length(T) == 0 ->
    NewAcc = Acc + H,
    {_, NewT} = lists:split(Skip, T),
    minimum_coins(NewT, 1, NewAcc)."
erlang,runtime_error,"Line 6: exception error: function_clause
[{solution,minimum_added_coins_helper,
              [[],19,26,2],
              [{file,""solution.erl""},{line,6}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,31}]},
 {solution,driver,0,[{file,""solution.erl""},{line,17}]},
 {solution,start,0,[{file,""solution.erl""},{line,48}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\minimum-number-of-coins-to-be-added\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_added_coins(Coins :: [integer()], Target :: integer()) -> integer().
minimum_added_coins(Coins, Target) ->
    SortedCoins = lists:usort(Coins),
    minimum_added_coins_helper(SortedCoins, Target, 1, 0).

minimum_added_coins_helper([], Target, Current, Count) when Current < Target ->
    minimum_added_coins_helper([], Target, Current * 2, Count + 1);
minimum_added_coins_helper([H|T], Target, Current, Count) when Current >= Target ->
    Count;
minimum_added_coins_helper([H|T], Target, Current, Count) when H > Current ->
    minimum_added_coins_helper([H|T], Target, Current * 2, Count + 1);
minimum_added_coins_helper([H|T], Target, Current, Count) when H =< Current ->
    minimum_added_coins_helper(T, Target, Current + H, Count)."
erlang,runtime_error,"Line 7: exception error: badarg
[{erlang,bit_size,[0],[{error_info,#{module => erl_erts_errors}}]},
 {solution,'-min_operations/2-fun-1-',3,
              [{file,""solution.erl""},{line,7}]},
 {lists,foldl,3,[{file,""lists.erl""},{line,1594}]},
 {solution,min_operations,2,[{file,""solution.erl""},{line,7}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,25}]},
 {solution,driver,0,[{file,""solution.erl""},{line,11}]},
 {solution,start,0,[{file,""solution.erl""},{line,42}]},
 {init,start_em,1,[]}]",../questions/Medium\minimum-number-of-operations-to-make-array-xor-equal-to-k\responses\Erlang\response_erlang_0_failed.json,"-spec min_operations(Nums :: [integer()], K :: integer()) -> integer().
min_operations(Nums, K) ->
    Xor = lists:foldl(fun(X, Acc) -> X bxor Acc end, 0, Nums),
    TargetXor = Xor bxor K,
    Bin = integer_to_binary(TargetXor, 2),
    Length = byte_size(Bin),
    lists:foldl(fun(X, Acc) -> Acc + bit_size(X band TargetXor) end, 0, Nums) div Length."
erlang,runtime_error,"Line 22: exception error: badarg
[{erlang,length,[<<""100011001"">>],[{error_info,#{module => erl_erts_errors}}]},
 {solution,shortest_beautiful_substring,2,
              [{file,""solution.erl""},{line,22}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,43}]},
 {solution,driver,0,[{file,""solution.erl""},{line,29}]},
 {solution,start,0,[{file,""solution.erl""},{line,60}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\shortest-and-lexicographically-smallest-beautiful-string\responses\Erlang\response_erlang_0_failed.json,"-spec shortest_beautiful_substring(S :: unicode:unicode_binary(), K :: integer()) -> unicode:unicode_binary().
shortest_beautiful_substring(S, K) ->
    {Result, _} = lists:foldl(
        fun(C, {Acc, {Count, Start, MinLen, MinStart}}) ->
            NewCount = Count + if C =:= $1 -> 1; true -> 0 end,
            case NewCount of
                K ->
                    {NewS, NewStart, NewLen} = case Acc of
                        [] -> {binary:part(S, Start, K), Start, K};
                        _ ->
                            CurrentLen = byte_size(binary:part(S, Start, byte_size(S) - Start)),
                            if CurrentLen < MinLen ->
                                {binary:part(S, Start, CurrentLen), Start, CurrentLen};
                               true ->
                                {MinStart, MinLen}
                            end
                    end,
                    {NewS, {K, NewStart + 1, NewLen, NewStart + 1}};
                _ -> {Acc, {NewCount, Start, MinLen, MinStart}}
            end
        end,
        {<<>>, {0, 0, length(S) + 1, 0}},
        S
    ),
    Result."
erlang,runtime_error,"Line 18: exception error: badarg
[{erlang,binary_part,
         [<<""bca"">>,2],
         [{error_info,#{module => erl_erts_errors}}]},
 {solution,merge_two,2,[{file,""solution.erl""},{line,18}]},
 {solution,merge_strings,1,[{file,""solution.erl""},{line,9}]},
 {lists,map,2,[{file,""lists.erl""},{line,1559}]},
 {solution,minimum_string,3,[{file,""solution.erl""},{line,4}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,38}]},
 {solution,driver,0,[{file,""solution.erl""},{line,22}]},
 {solution,start,0,[{file,""solution.erl""},{line,55}]}]",../questions/Medium\shortest-string-that-contains-three-strings\responses\Erlang\response_erlang_2_failed.json,"-spec minimum_string(A :: unicode:unicode_binary(), B :: unicode:unicode_binary(), C :: unicode:unicode_binary()) -> unicode:unicode_binary().
minimum_string(A, B, C) ->
    Permutations = [[A,B,C], [A,C,B], [B,A,C], [B,C,A], [C,A,B], [C,B,A]],
    Lists = lists:map(fun(X) -> merge_strings(X) end, Permutations),
    Sorted = lists:sort(fun(X,Y) -> {length(X), X} < {length(Y), Y} end, Lists),
    hd(Sorted).

merge_strings([A,B,C]) ->
    AB = merge_two(A,B),
    ABC = merge_two(AB,C),
    ABC.

merge_two(A, B) ->
    ALen = byte_size(A),
    BLen = byte_size(B),
    Prefix = lists:max([0| [I || I <- lists:seq(1, min(ALen, BLen)),
                             binary_part(A, ALen - I, I) == binary_part(B, 0, I)]]),
    <<A/binary, (binary_part(B, Prefix))/binary>>."
erlang,runtime_error,"Line 3: exception error: undef
[{lists,scan,[#Fun<solution.0.2431760>,0,[0,1,0,0,1]],[]},
 {solution,number_of_good_subarray_splits,1,
              [{file,""solution.erl""},{line,3}]},
 {solution,consume_test_cases,2,[{file,""solution.erl""},{line,29}]},
 {solution,driver,0,[{file,""solution.erl""},{line,17}]},
 {solution,start,0,[{file,""solution.erl""},{line,46}]},
 {init,start_em,1,[]},
 {init,do_boot,3,[]}]",../questions/Medium\ways-to-split-array-into-good-subarrays\responses\Erlang\response_erlang_1_failed.json,"-spec number_of_good_subarray_splits(Nums :: [integer()]) -> integer().
number_of_good_subarray_splits(Nums) ->
  PrefixSums = lists:scan(fun(X, Sum) -> X + Sum end, 0, Nums),
  TotalCount = lists:last(PrefixSums),
  CountZeros = length([X || X <- PrefixSums, X == 1]),
  number_of_good_subarray_splits(PrefixSums, TotalCount, CountZeros, 0).

number_of_good_subarray_splits(_, 0, _, Acc) ->
  Acc;
number_of_good_subarray_splits(PrefixSums, TotalCount, CountZeros, Acc) when TotalCount > 0 ->
  GoodSplits = lists:foldl(fun(X, {Count, AccIn}) when X < TotalCount -> {Count + 1, AccIn}; (TotalCount, {Count, AccIn}) -> {Count, AccIn + Count} end, {0, 0}, PrefixSums),
  AccNew = (Acc + element(2, GoodSplits)) rem 1000000007,
  number_of_good_subarray_splits(PrefixSums, TotalCount - 1, CountZeros - 1, AccNew)."
