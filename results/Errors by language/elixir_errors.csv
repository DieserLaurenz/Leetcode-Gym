Language,Error Type,Message,File Path,Code
elixir,compile_error,"error: undefined function &&&/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 15:   Solution.has_trailing_zero?/1
error: undefined function >>>/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 15:   Solution.has_trailing_zero?/1
error: undefined function |||/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 8:   Solution.has_trailing_zeros/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\check-if-bitwise-or-has-trailing-zeros\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec has_trailing_zeros(nums :: [integer]) :: boolean
  def has_trailing_zeros(nums) do
    # Generate all combinations of the array elements, starting from combinations of 2 elements
    for n <- 2..length(nums), combination <- Enum.combination(nums, n), do: combination
    # Reduce each combination with bitwise OR and check for trailing zeros
    |> Enum.any?(fn combination -> 
      or_result = Enum.reduce(combination, &(&1 ||| &2))
      has_trailing_zero?(or_result)
    end)
  end

  defp has_trailing_zero?(0), do: false
  defp has_trailing_zero?(n) do
    if n &&& 1 == 0, do: true, else: has_trailing_zero?(n >>> 1)
  end
end"
elixir,compile_error,"Line 8: Char 52: ** (SyntaxError) syntax error before: 'bor'
    |
  8 |       or_result = Enum.reduce(combination, 0, &(&1 bor &2))
    |                                                    ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Easy\check-if-bitwise-or-has-trailing-zeros\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec has_trailing_zeros(nums :: [integer]) :: boolean
  def has_trailing_zeros(nums) do
    # Generate all combinations of the array elements, starting from combinations of 2 elements
    for n <- 2..length(nums), combination <- Enum.combination(nums, n), do: combination
    # Reduce each combination with bitwise OR and check for trailing zeros
    |> Enum.any?(fn combination -> 
      or_result = Enum.reduce(combination, 0, &(&1 bor &2))
      has_trailing_zero?(or_result)
    end)
  end

  defp has_trailing_zero?(0), do: false
  defp has_trailing_zero?(n) do
    if n band 1 == 0, do: true, else: has_trailing_zero?(n bsr 1)
  end
end"
elixir,compile_error,"Line 5: Char 98: ** (SyntaxError) unexpected expression after keyword list. Keyword lists must always come as the last argument. Therefore, this is not allowed:
    function_call(1, some: :option, 2)
Instead, wrap the keyword in brackets:
    function_call(1, [some: :option], 2)
Syntax error after: ','
    |
  5 |     Enum.any?(for n <- 2..length(nums), combination <- Enum.combination(nums, n), do: combination, fn combination ->
    |                                                                                                  ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Easy\check-if-bitwise-or-has-trailing-zeros\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec has_trailing_zeros(nums :: [integer]) :: boolean
  def has_trailing_zeros(nums) do
    # Generate all combinations of the array elements, starting from combinations of 2 elements
    Enum.any?(for n <- 2..length(nums), combination <- Enum.combination(nums, n), do: combination, fn combination -> 
      # Reduce each combination with bitwise OR and check for trailing zeros
      or_result = Enum.reduce(combination, 0, fn x, acc -> x bor acc end)
      has_trailing_zero?(or_result)
    end)
  end

  defp has_trailing_zero?(0), do: false
  defp has_trailing_zero?(n) do
    if n band 1 == 0, do: true, else: has_trailing_zero?(n bsr 1)
  end
end"
elixir,compile_error,"warning: variable ""count"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 15:   Solution.incremovable_subarray_count/1
warning: variable ""subarray"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 10:   Solution.incremovable_subarray_count/1
** (ArgumentError) cannot pipe nums into Enum.slice(0..(start - 1)) ++ Enum.slice(nums, (finish + 1)..-1), the :++ operator can only take two arguments
    (elixir 1.15.7) lib/macro.ex:376: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 24:     Solution.remove_subarray/3",../questions/Easy\count-the-number-of-incremovable-subarrays-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec incremovable_subarray_count(nums :: [integer]) :: integer
  def incremovable_subarray_count(nums) do
    length = length(nums)
    count = 0

    for start_index <- 0..(length - 1) do
      for end_index <- start_index..(length - 1) do
        # Extract the subarray
        subarray = Enum.slice(nums, start_index..end_index)
        # Remove the subarray from original array
        remaining_nums = remove_subarray(nums, start_index, end_index)
        # Check if the remaining array is strictly increasing
        if is_strictly_increasing(remaining_nums) do
          count = count + 1
        end
      end
    end

    count
  end

  defp remove_subarray(nums, start, finish) do
    nums |> Enum.slice(0..(start - 1)) ++ Enum.slice(nums, (finish + 1)..-1)
  end

  defp is_strictly_increasing(nums) when length(nums) <= 1, do: true
  defp is_strictly_increasing([head | tail]) do
    Enum.reduce_while(tail, {true, head}, fn x, {is_increasing, last_element} ->
      if x > last_element do
        {:cont, {true, x}}
      else
        {:halt, false}
      end
    end) |> elem(0)
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe nums |> (Enum.at(i - 1) + nums) into Enum.at(j - 1) + nums, the :+ operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 15:     Solution.minimum_cost/1
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 15:     Solution.minimum_cost/1",../questions/Easy\divide-an-array-into-subarrays-with-minimum-cost-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_cost(nums :: [integer]) :: integer
  def minimum_cost(nums) do
    # The length of the nums array
    n = length(nums)

    # Initializing the min_cost to a very large number
    min_cost = 1_000_000

    # Iterate over the array to get the first split point
    for i <- 1..(n - 2) do
      # Iterate over the array to get the second split point
      for j <- (i + 1)..(n - 1) do
        # Calculate the cost of the current configuration
        cost = nums |> Enum.at(i - 1) + nums |> Enum.at(j - 1) + nums |> Enum.at(n - 1)

        # Update the minimum cost if a lower cost is found
        min_cost = Enum.min([min_cost, cost])
      end
    end

    # Return the minimum cost found
    min_cost
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe nums |> (Enum.at(i - 1) + nums) into Enum.at(j - 1) + nums, the :+ operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 12:     Solution.minimum_cost/1
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 12:     Solution.minimum_cost/1",../questions/Easy\divide-an-array-into-subarrays-with-minimum-cost-i\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_cost(nums :: [integer]) :: integer
  def minimum_cost(nums) do
    n = length(nums)
    min_cost = 1_000_000

    # Iterate to find the first split point
    for i <- 1..(n - 2) do
      # Iterate to find the second split point
      for j <- (i + 1)..(n - 1) do
        # Correctly calculate the cost
        cost = nums |> Enum.at(i - 1) + nums |> Enum.at(j - 1) + nums |> Enum.at(n - 1)

        # Update the minimum cost
        if cost < min_cost do
          min_cost = cost
        end
      end
    end

    min_cost
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe nums into Enum.at(i) - nums, the :- operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 8:     Solution.find_indices/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 8:     Solution.find_indices/3
    (elixir 1.15.7) expanding macro: Kernel.and/2
Line 8:     Solution.find_indices/3",../questions/Easy\find-indices-with-index-and-value-difference-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]
  def find_indices(nums, index_difference, value_difference) do
    n = length(nums)

    for i <- 0..(n-1) do
      for j <- 0..(n-1) do
        if abs(i - j) >= index_difference and abs(nums |> Enum.at(i) - nums |> Enum.at(j)) >= value_difference do
          return [i, j]
        end
      end
    end

    [-1, -1]
  end
end"
elixir,compile_error,"error: undefined function return/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 9:   Solution.find_indices/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\find-indices-with-index-and-value-difference-i\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]
  def find_indices(nums, index_difference, value_difference) do
    n = length(nums)

    for i <- 0..(n - 1) do
      for j <- 0..(n - 1) do
        if abs(i - j) >= index_difference and abs(Enum.at(nums, i) - Enum.at(nums, j)) >= value_difference do
          return [i, j]
        end
      end
    end

    [-1, -1]
  end
end"
elixir,compile_error,"Line 22: Char 74: ** (SyntaxError) syntax error before: 'div'
    |
 22 |     missing = (sum_squares_difference - sum_difference * sum_difference) div (2 * sum_difference)
    |                                                                          ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Easy\find-missing-and-repeated-values\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_missing_and_repeated_values(grid :: [[integer]]) :: [integer]
  def find_missing_and_repeated_values(grid) do
    # Determine the size of the grid
    n = length(grid)
    total_elements = n * n

    # Calculate the expected sum and sum of squares
    expected_sum = Enum.sum(1..total_elements)
    expected_sum_squares = Enum.sum(Enum.map(1..total_elements, fn x -> x * x end))

    # Flatten the grid and calculate the actual sum and sum of squares
    flattened_grid = for row <- grid, elem <- row, do: elem
    actual_sum = Enum.sum(flattened_grid)
    actual_sum_squares = Enum.sum(Enum.map(flattened_grid, fn x -> x * x end))

    # Calculate the differences
    sum_difference = actual_sum - expected_sum
    sum_squares_difference = actual_sum_squares - expected_sum_squares

    # Solve for the missing and repeated numbers
    missing = (sum_squares_difference - sum_difference * sum_difference) div (2 * sum_difference)
    repeated = missing + sum_difference

    [repeated, missing]
  end
end"
elixir,compile_error,"error: undefined function &&&/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 8:   Solution.find_k_or/2
error: undefined function <<</2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 8:   Solution.find_k_or/2
error: undefined function <<</2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 9:   Solution.find_k_or/2
error: undefined function |||/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 9:   Solution.find_k_or/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\find-the-k-or-of-an-array\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_k_or(nums :: [integer], k :: integer) :: integer
  def find_k_or(nums, k) do
    max_bit_length = Enum.max(nums) |> :math.log2() |> Float.ceil() |> trunc()

    0..(max_bit_length - 1)
    |> Enum.reduce(0, fn bit, acc ->
      count = Enum.count(nums, fn num -> num &&& (1 <<< bit) != 0 end)
      if count >= k, do: acc ||| (1 <<< bit), else: acc
    end)
  end
end"
elixir,compile_error,"warning: missing parentheses for expression following ""do:"" keyword. Parentheses are required to solve ambiguity inside keywords.
This error happens when you have function calls without parentheses inside keywords. For example:
    function(arg, one: nested_call a, b, c)
    function(arg, one: if expr, do: :this, else: :that)
In the examples above, we don't know if the arguments ""b"" and ""c"" apply to the function ""function"" or ""nested_call"". Or if the keywords ""do"" and ""else"" apply to the function ""function"" or ""if"". You can solve this by explicitly adding parentheses:
    function(arg, one: if(expr, do: :this, else: :that))
    function(arg, one: nested_call(a, b, c))
Ambiguity found at:
  solution.ex:13
warning: variable ""num"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 12:   Solution.find_k_or/2
error: undefined function <<</2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 12:   Solution.find_k_or/2
error: undefined function band/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 12:   Solution.find_k_or/2
error: undefined function num/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 12:   Solution.find_k_or/2
error: undefined function <<</2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 13:   Solution.find_k_or/2
error: undefined function acc/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 13:   Solution.find_k_or/2
error: undefined function bor/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 13:   Solution.find_k_or/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\find-the-k-or-of-an-array\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec find_k_or(nums :: [integer], k :: integer) :: integer
  def find_k_or(nums, k) do
    max_bit_length = nums
                     |> Enum.max()
                     |> :math.log2()
                     |> Float.ceil()
                     |> trunc()

    0..(max_bit_length - 1)
    |> Enum.reduce(0, fn bit, acc ->
      count = Enum.count(nums, fn num -> num band (1 <<< bit) != 0 end)
      if count >= k, do: acc bor (1 <<< bit), else: acc
    end)
  end
end"
elixir,compile_error,"Line 12: Char 37: ** (SyntaxError) syntax error before: 'band'
    |
 12 |       count = Enum.count(nums, &(&1 band (1 <<< bit) != 0))
    |                                     ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Easy\find-the-k-or-of-an-array\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_k_or(nums :: [integer], k :: integer) :: integer
  def find_k_or(nums, k) do
    max_bit_length = nums
                     |> Enum.max()
                     |> :math.log2()
                     |> Float.ceil()
                     |> trunc()

    0..(max_bit_length - 1)
    |> Enum.reduce(0, fn bit, acc ->
      count = Enum.count(nums, &(&1 band (1 <<< bit) != 0))
      if count >= k, do: (acc bor (1 <<< bit)), else: acc
    end)
  end
end"
elixir,compile_error,"warning: bitstring specifier ""char"" does not exist and is being expanded to ""char()"", please use parentheses to remove the ambiguity
Line 6:   Solution.find_words_containing/2
error: unknown bitstring specifier: char
Line 6:   Solution.find_words_containing/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\find-words-containing-character\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_words_containing(words :: [String.t], x :: char) :: [integer]
  def find_words_containing(words, x) do
    words
    |> Enum.with_index()
    |> Enum.filter(fn {word, _index} -> String.contains?(word, <<x::char>>) end)
    |> Enum.map(fn {_word, index} -> index end)
  end
end"
elixir,compile_error,"Line 9: Char 25: ** (SyntaxError) syntax error before: do
    |
  9 |         if num % 2 == 0 do
    |                         ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Easy\longest-even-odd-subarray-with-threshold\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec longest_alternating_subarray(nums :: [integer], threshold :: integer) :: integer
  def longest_alternating_subarray(nums, threshold) do
    nums
    |> Enum.with_index()
    |> Enum.filter(fn {num, _} -> num <= threshold end)
    |> Enum.reduce({0, nil}, fn {num, idx}, {max_length, last_even_idx} ->
      if num <= threshold do
        if num % 2 == 0 do
          if last_even_idx == nil or (idx - last_even_idx) % 2 == 1 do
            new_length = if last_even_idx == nil, do: 1, else: idx - last_even_idx + 1
            {max(max_length, new_length), idx}
          else
            {max_length, idx}
          end
        else
          if last_even_idx != nil and (idx - last_even_idx) % 2 == 0 do
            {max_length, last_even_idx}
          else
            {max_length, nil}
          end
        end
      else
        {max_length, nil}
      end
    end)
    |> elem(0)
  end
end"
elixir,compile_error,"** (ArgumentError) cannot invoke defp/2 inside function/macro
    (elixir 1.15.7) lib/kernel.ex:6593: Kernel.assert_no_function_scope/3
    (elixir 1.15.7) lib/kernel.ex:5202: Kernel.define/4
    (elixir 1.15.7) expanding macro: Kernel.defp/2
Line 5:     Solution.find_minimum_operations/3",../questions/Easy\make-three-strings-equal\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec find_minimum_operations(s1 :: String.t, s2 :: String.t, s3 :: String.t) :: integer
  def find_minimum_operations(s1, s2, s3) do
    # Function to recursively check if strings can be made equal and count operations
    defp find_min_ops([h | t], acc) when is_list(h) do
      case Enum.all?(t, fn x -> List.first(x) == List.first(h) end) do
        true -> find_min_ops(Enum.map([h | t], &List.delete_at(&1, 0)), acc + 1)
        false -> find_min_ops(Enum.map([h | t], fn x -> if length(x) > length(h), do: List.delete_at(x, -1), else: x end), acc + 1)
      end
    end
    defp find_min_ops(lists, acc) do
      lengths = Enum.map(lists, &length(&1))
      if Enum.uniq(lengths) == [1], do: acc, else: -1
    end

    # Convert strings to lists of characters for easier manipulation
    lists_of_chars = [s1, s2, s3] |> Enum.map(&String.graphemes/1)

    # Initial check for equal lengths, if so, check if they are already equal
    if Enum.uniq(Enum.map(lists_of_chars, &length(&1))) == [1] and Enum.uniq(lists_of_chars) == [Enum.at(lists_of_chars, 0)] do
      0
    else
      find_min_ops(lists_of_chars, 0)
    end
  end
end"
elixir,compile_error,"error: undefined variable ""break""
Line 20:   Solution.min_operations/2
warning: variable ""ops"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 14:   Solution.min_operations/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\minimum-operations-to-collect-elements\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec min_operations(nums :: [integer], k :: integer) :: integer
  def min_operations(nums, k) do
    # Reverse the list to start processing from the end.
    reversed_nums = Enum.reverse(nums)

    # Initialize variables for the loop: operations count and a set for collected numbers.
    ops = 0
    collected = MapSet.new()

    # Loop through the list until we've collected all numbers from 1 to k.
    for num <- reversed_nums do
      # Increment operations count.
      ops = ops + 1

      # Add the number to the set of collected numbers if it's within the range [1, k].
      collected = if num <= k, do: MapSet.put(collected, num), else: collected

      # Stop if we've collected all numbers from 1 to k.
      if MapSet.size(collected) == k, do: break, else: nil
    end

    # Return the operations count.
    ops
  end
end"
elixir,compile_error,"error: cannot invoke remote function MapSet.member?/2 inside guards
Line 9:   Solution.min_operations/4
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) expanding macro: Kernel.and/2
Line 9:     Solution.min_operations/4",../questions/Easy\minimum-operations-to-collect-elements\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec min_operations([integer], integer) :: integer
  def min_operations(nums, k) do
    min_operations(Enum.reverse(nums), k, MapSet.new(), 0)
  end

  defp min_operations([], _k, _collected, ops), do: ops

  defp min_operations([num | rest], k, collected, ops) when num <= k and not MapSet.member?(collected, num) do
    if MapSet.size(collected) + 1 == k do
      ops + 1
    else
      min_operations(rest, k, MapSet.put(collected, num), ops + 1)
    end
  end

  defp min_operations([_num | rest], k, collected, ops) do
    min_operations(rest, k, collected, ops + 1)
  end
end"
elixir,compile_error,"** (ArgumentError) cannot invoke defp/2 inside function/macro
    (elixir 1.15.7) lib/kernel.ex:6593: Kernel.assert_no_function_scope/3
    (elixir 1.15.7) lib/kernel.ex:5202: Kernel.define/4
    (elixir 1.15.7) expanding macro: Kernel.defp/2
Line 5:     Solution.min_length/1",../questions/Easy\minimum-string-length-after-removing-substrings\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_length(s :: String.t) :: integer
  def min_length(s) do
    # Define a recursive helper function to remove ""AB"" and ""CD"" iteratively
    defp remove_substrings(str) do
      # Try to remove ""AB"" and ""CD"" from the string
      new_str = String.replace(str, ""AB"", """")
      |> String.replace(""CD"", """")

      # If the string changes, call recursively, else return the current string
      if new_str != str do
        remove_substrings(new_str)
      else
        new_str
      end
    end

    # Call the helper with the initial string
    final_str = remove_substrings(s)

    # Return the length of the resulting string
    String.length(final_str)
  end
end"
elixir,compile_error,"error: unsupported option :else given to for
Line 4:   Solution.minimum_sum/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\minimum-sum-of-mountain-triplets-i\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_sum(nums :: [integer]) :: integer
  def minimum_sum(nums) do
    left_mins = for j <- 1..(length(nums) - 2), into: %{}, do: {j, Enum.min(for i <- 0..(j-1), nums[i] < nums[j], do: nums[i], else: [])}
    right_mins = for j <- 1..(length(nums) - 2), into: %{}, do: {j, Enum.min(for k <- (j+1)..(length(nums)-1), nums[k] < nums[j], do: nums[k], else: [])}

    nums
    |> Enum.with_index()
    |> Enum.reduce_while({:infinity, nil}, fn {num, j}, {min_sum, _} ->
      if Map.has_key?(left_mins, j) and Map.has_key?(right_mins, j) and left_mins[j] != [] and right_mins[j] != [],
      do: {:halt, {left_mins[j] + num + right_mins[j], j}},
      else: {:cont, {min_sum, nil}}
    end)
    |> case do
      {:infinity, _} -> -1
      {min_sum, _} -> min_sum
    end
  end
end"
elixir,compile_error,"warning: variable ""left"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 11:   Solution.minimum_sum/1
error: undefined variable ""left""
Line 13:   Solution.minimum_sum/1
error: undefined variable ""left""
Line 14:   Solution.minimum_sum/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\minimum-sum-of-mountain-triplets-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_sum(nums :: [integer]) :: integer
  def minimum_sum(nums) do
    left_min = Enum.scan(nums, fn x, acc -> if acc == nil, do: x, else: min(x, acc) end)
    right_min = Enum.scan(Enum.reverse(nums), fn x, acc -> if acc == nil, do: x, else: min(x, acc) end)
               |> Enum.reverse()

    Enum.with_index(nums)
    |> Enum.reduce(-1, fn {num, idx}, acc ->
      if idx == 0 or idx == length(nums) - 1, do: acc, else:
        left = Enum.at(left_min, idx - 1)
        right = Enum.at(right_min, idx + 1)
        if num > left and num > right do
          sum = left + num + right
          if acc == -1, do: sum, else: min(acc, sum)
        else
          acc
        end
    end)
  end
end"
elixir,compile_error,"warning: variable ""longest_seq"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 12:   Solution.missing_integer/1
warning: variable ""sum"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 11:   Solution.missing_integer/1
error: undefined function while/3 (expected Solution to define such a function or for it to be imported, but none are available)
Line 31:   Solution.while/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Easy\smallest-missing-integer-greater-than-sequential-prefix-sum\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec missing_integer(nums :: [integer]) :: integer
  def missing_integer(nums) do
    # Initialize variables for the longest sequence and its sum
    longest_seq = 0
    sum = 0

    # Calculate the sum of the longest sequential prefix
    Enum.reduce(nums, 0, fn x, prev ->
      if prev == 0 or x == prev + 1 do
        sum = sum + x
        longest_seq = longest_seq + 1
        x
      else
        sum
      end
    end)

    # Adjust the sum if the entire sequence is sequential
    sum = if longest_seq == length(nums), do: Enum.sum(Enum.slice(nums, 0, longest_seq)), else: Enum.sum(Enum.slice(nums, 0, longest_seq - 1))

    # Find the smallest missing integer greater than or equal to the sum
    missing_integer = sum + 1
    while Enum.member?(nums, missing_integer) do
      missing_integer = missing_integer + 1
    end
    missing_integer
  end

  defp while(condition, do: block) do
    if condition, do: block.() |> while(condition, do: block)
  end
end"
elixir,compile_error,"Line 11: Char 5: ** (SyntaxError) syntax error before: rescue. ""rescue"" is a reserved word in Elixir and therefore its usage is limited. For instance, it can't be used as a variable or be defined nor invoked as a regular function
    |
 11 |     rescue
    |     ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Easy\smallest-missing-integer-greater-than-sequential-prefix-sum\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec missing_integer(nums :: [integer]) :: integer
  def missing_integer(nums) do
    # Find the longest sequential prefix and its sum
    {longest_seq_sum, _} = Enum.reduce(nums, {0, nums |> hd() - 1}, fn x, {sum, last} ->
      if x == last + 1 do
        {sum + x, x}
      else
        throw :break
      end
    rescue
      _ -> {sum, last}
    end)

    # Find the smallest missing integer
    missing_integer = Enum.find(longest_seq_sum + 1..50, fn x ->
      not Enum.member?(nums, x)
    end)

    missing_integer
  end
end"
elixir,compile_error,"error: spec for undefined function max_sum/2
  solution.ex:2
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3",../questions/Hard\apply-operations-on-array-to-maximize-sum-of-squares\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec max_sum(nums :: [integer], k :: integer) :: integer do
    nums
    |> Enum.map(&(&1 * &1))
    |> Enum.sort(&>/2)
    |> Enum.take(k)
    |> Enum.sum()
    |> rem(1_000_000_007)
  end
end"
elixir,compile_error,"error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 10:   Solution.max_frequency_score/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Hard\apply-operations-to-maximize-frequency-score\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec max_frequency_score(nums :: [integer], k :: integer) :: integer
  def max_frequency_score(nums, k) do
    nums
    |> Enum.sort()
    |> Enum.reduce({0, 0, 0}, fn x, {max_freq, freq, sum} ->
      freq = freq + 1
      sum = sum + x

      while freq > 1 and sum + k < x * freq do
        sum = sum - Enum.at(nums, -freq)
        freq = freq - 1
      end

      max_freq = max(max_freq, freq)
      {max_freq, freq, sum}
    end)
    |> elem(0)
  end
end"
elixir,compile_error,"Line 10: Char 12: ** (SyntaxError) syntax error before: '='
    |
 10 |         k += nums[right - 1] - nums[left - 1]
    |            ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\apply-operations-to-maximize-frequency-score\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec max_frequency_score(nums :: [integer], k :: integer) :: integer
  def max_frequency_score(nums, k) do
    nums = Enum.sort(nums)
    max_freq = 1
    left = 1

    for right <- 2..length(nums) do
      while left < right and k < (nums[right - 1] - nums[left - 1]) * (right - left) do
        k += nums[right - 1] - nums[left - 1]
        left += 1
      end
      k -= (nums[right - 1] - nums[left - 1]) * (right - left)
      max_freq = max(max_freq, right - left + 1)
    end

    max_freq
  end
end"
elixir,compile_error,"Line 11: Char 12: ** (SyntaxError) syntax error before: '='
    |
 11 |       sum += nums[right - 1]
    |            ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\apply-operations-to-maximize-frequency-score\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_frequency_score(nums :: [integer], k :: integer) :: integer
  def max_frequency_score(nums, k) do
    nums = Enum.sort(nums)
    len = length(nums)
    max_freq = 0
    sum = 0
    left = 1

    for right <- 1..len do
      sum += nums[right - 1]
      while sum + k < nums[right - 1] * (right - left + 1) do
        sum -= nums[left - 1]
        left += 1
      end
      max_freq = max(max_freq, right - left + 1)
    end

    max_freq
  end
end"
elixir,compile_error,"warning: variable ""k"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 21:   Solution.count_combinations_for_char/4
** (ArgumentError) cannot pipe char1 |> String.to_charlist() into hd() - char2, the :- operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 27:     Solution.valid_chars?/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 27:     Solution.valid_chars?/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 27:     Solution.valid_chars?/2",../questions/Hard\count-complete-substrings\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec count_complete_substrings(word :: String.t, k :: integer) :: integer
  def count_complete_substrings(word, k) do
    word
    |> String.graphemes()
    |> Enum.reduce(%{}, fn c, acc ->
      Map.update(acc, c, 1, &(&1 + 1))
    end)
    |> Enum.filter(fn {_key, value} -> rem(value, k) == 0 end)
    |> Enum.map(fn {key, value} -> {key, div(value, k)} end)
    |> count_valid_combinations(k)
  end

  defp count_valid_combinations(char_map, k) do
    char_map
    |> Enum.reduce(0, fn {char, times}, acc ->
      acc + count_combinations_for_char(char_map, char, times, k)
    end)
  end

  defp count_combinations_for_char(char_map, char, times, k),
    do: Enum.reduce(char_map, 0, fn {other_char, other_times}, acc ->
      if valid_chars?(char, other_char) and times == other_times, do: acc + 1, else: acc
    end)

  defp valid_chars?(char1, char2) do
    diff = abs(char1 |> String.to_charlist() |> hd() - char2 |> String.to_charlist() |> hd())
    diff <= 2
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe byte_size(word) |> Kernel.min(i + k - 1, &1) |> Kernel.max(j) into an anonymous function without calling the function; use Kernel.then/2 instead or define the anonymous function as a regular private function
    (elixir 1.15.7) lib/macro.ex:328: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 7:     Solution.count_complete_substrings/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 5:     Solution.count_complete_substrings/2",../questions/Hard\count-complete-substrings\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec count_complete_substrings(word :: String.t, k :: integer) :: integer
  def count_complete_substrings(word, k) do
    1..(byte_size(word) - k + 1)
    |> Enum.reduce(0, fn i, acc ->
      acc + Enum.count(1..(byte_size(word) - k + 1), fn j ->
        substring = byte_size(word) |> Kernel.min(i + k - 1, &1) |> Kernel.max(j) |> fn end_pos -> String.slice(word, j - 1, end_pos - j + 1) end
        valid_substring?(substring, k)
      end)
    end)
  end

  defp valid_substring?(substring, k) do
    counts = Enum.reduce(substring |> String.graphemes(), %{}, fn char, acc ->
      Map.update(acc, char, 1, &(&1 + 1))
    end)

    valid_counts = Enum.all?(counts, fn {_char, count} -> count == k end)
    valid_chars = Enum.all?(String.graphemes(substring), fn char ->
      next_char = String.next_codepoint(char)
      prev_char = String.previous_codepoint(char)

      Enum.any?(String.graphemes(substring), fn other_char ->
        other_char == char || other_char == next_char || other_char == prev_char
      end)
    end)

    valid_counts and valid_chars
  end

  defp String.next_codepoint(char) do
    [codepoint] = char |> String.to_charlist()
    [codepoint + 1] |> List.to_string()
  end

  defp String.previous_codepoint(char) do
    [codepoint] = char |> String.to_charlist()
    [codepoint - 1] |> List.to_string()
  end
end"
elixir,compile_error,"Line 14: Char 90: ** (SyntaxError) syntax error before: ')'
    |
 14 |     char_counts = for <<c::utf8 <- substring>>, into: %{}, do: (c, Map.get(%{}, c, 0) + 1)
    |                                                                                          ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\count-complete-substrings\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec count_complete_substrings(word :: String.t, k :: integer) :: integer
  def count_complete_substrings(word, k) do
    Enum.reduce(0..String.length(word)-1, 0, fn i, acc ->
      acc + 
        Enum.reduce(i..String.length(word)-1, 0, fn j, acc2 ->
          substring = String.slice(word, i, j-i+1)
          if valid_substring?(substring, k), do: acc2+1, else: acc2
        end)
    end)
  end

  defp valid_substring?(substring, k) do
    char_counts = for <<c::utf8 <- substring>>, into: %{}, do: (c, Map.get(%{}, c, 0) + 1)
    all_k = Enum.all?(char_counts, fn {_char, count} -> count == k end)

    if !all_k, do: false, else: valid_char_diff?(substring)
  end

  defp valid_char_diff?(substring) do
    chars = String.graphemes(substring)
    Enum.all?(chars, fn char ->
      char_code = char |> String.to_charlist() |> hd()
      Enum.all?(chars, fn other_char ->
        other_char_code = other_char |> String.to_charlist() |> hd()
        abs(char_code - other_char_code) <= 2
      end)
    end)
  end
end"
elixir,compile_error,"warning: function comb/2 is unused
Line 14:   Solution (module)
error: spec for undefined function count_k_subsequences_with_max_beauty/2
  solution.ex:2
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3",../questions/Hard\count-k-subsequences-of-a-string-with-maximum-beauty\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec count_k_subsequences_with_max_beauty(s :: String.t, k :: integer) :: integer do
    s
    |> String.graphemes()
    |> Enum.frequencies()
    |> Enum.map(fn {_, v} -> v end)
    |> Enum.sort(&>=/2)
    |> Enum.take(k)
    |> Enum.reduce(0, fn x, acc -> acc + x end)
    |> (&(&1 * comb(Enum.count(s) - k, k))).()
    |> rem(1_000_000_007)
  end

  defp comb(n, k) do
    Enum.reduce(1..k, 1, fn i, acc ->
      div(acc * (n - k + i), i)
    end)
  end
end"
elixir,compile_error,"warning: function comb/2 is unused
Line 14:   Solution (module)
error: spec for undefined function count_k_subsequences_with_max_beauty/2
  solution.ex:2
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3",../questions/Hard\count-k-subsequences-of-a-string-with-maximum-beauty\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec count_k_subsequences_with_max_beauty(s :: String.t, k :: integer) :: integer do
    s
    |> String.graphemes()
    |> Enum.frequencies()
    |> Enum.map(fn {_char, freq} -> freq end)
    |> Enum.sort(&>=/2)
    |> Enum.take(k)
    |> Enum.reduce(1, fn freq, acc -> 
      acc * comb(freq, 1) |> rem(1_000_000_007)
    end)
  end

  defp comb(n, k) when n >= k, do: Enum.reduce(0..k-1, 1, fn i, acc -> acc * (n - i) |> rem(1_000_000_007) end)
  defp comb(_, _), do: 0
end"
elixir,compile_error,"Line 5: Char 6: ** (SyntaxError) unexpected reserved word: end
    HINT: the ""{"" on line 5 is missing terminator ""}""
    |
  5 |     {end, _} = Integer.parse(num2)
    |      ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\count-of-integers\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec count(num1 :: String.t, num2 :: String.t, min_sum :: integer, max_sum :: integer) :: integer
  def count(num1, num2, min_sum, max_sum) do
    {start, _} = Integer.parse(num1)
    {end, _} = Integer.parse(num2)
    modulo = 1_000_000_007

    1..(end - start + 1)
    |> Enum.map(&(&1 + start - 1))
    |> Enum.filter(fn x -> 
      digit_sum = Integer.digits(x) |> Enum.sum()
      digit_sum >= min_sum and digit_sum <= max_sum
    end)
    |> length()
    |> rem(modulo)
  end
end"
elixir,compile_error,"Line 10: Char 65: ** (SyntaxError) syntax error before: 'rem'
    |
 10 |           sum = (:array.get(i, acc) + :array.get(i - num, acc)) rem 1_000_000_007
    |                                                                 ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\count-of-sub-multisets-with-bounded-sum\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec count_sub_multisets(nums :: [integer], l :: integer, r :: integer) :: integer
  def count_sub_multisets(nums, l, r) do
    dp = :array.new(20001, default_value: 0)
    dp = :array.set(0, 1, dp)

    for num <- nums do
      dp = Enum.reduce(20000..0, dp, fn i, acc ->
        if i >= num do
          sum = (:array.get(i, acc) + :array.get(i - num, acc)) rem 1_000_000_007
          :array.set(i, sum, acc)
        else
          acc
        end
      end)
    end

    Enum.reduce(l..r, 0, fn i, acc ->
      (acc + :array.get(i, dp)) rem 1_000_000_007
    end)
  end
end"
elixir,compile_error,"Line 10: Char 65: ** (SyntaxError) syntax error before: 'rem'
    |
 10 |           sum = (Map.get(acc, i, 0) + Map.get(acc, i - num, 0)) rem mod
    |                                                                 ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\count-of-sub-multisets-with-bounded-sum\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec count_sub_multisets(nums :: [integer], l :: integer, r :: integer) :: integer
  def count_sub_multisets(nums, l, r) do
    mod = 1_000_000_007
    dp = Enum.reduce(0..20000, %{}, fn _, acc -> Map.put(acc, 0, 1) end)

    for num <- nums do
      dp = Enum.reduce(20000..0, dp, fn i, acc ->
        if i >= num do
          sum = (Map.get(acc, i, 0) + Map.get(acc, i - num, 0)) rem mod
          Map.put(acc, i, sum)
        else
          acc
        end
      end)
    end

    Enum.reduce(l..r, 0, fn i, acc ->
      (acc + Map.get(dp, i, 0)) rem mod
    end)
  end
end"
elixir,compile_error,"error: spec for undefined function number_of_good_partitions/1
  solution.ex:2
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3",../questions/Hard\count-the-number-of-good-partitions\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec number_of_good_partitions(nums :: [integer]) :: integer do
    nums
    |> Enum.reduce({0, 1, Map.new()}, fn num, {last_unique, acc, seen} ->
      if Map.has_key?(seen, num) do
        {num, acc, Map.put(seen, num, true)}
      else
        {num, (acc * 2) |> rem(1_000_000_007), Map.put(seen, num, true)}
      end
    end)
    |> then(fn {_last_unique, acc, _seen} -> acc end)
  end
end"
elixir,compile_error,"Line 8: Char 86: ** (SyntaxError) syntax error before: 'rem'
    |
  8 |       new_count = if Map.get(last_seen, num), do: last_count, else: (last_count * 2) rem @mod
    |                                                                                      ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\count-the-number-of-good-partitions\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @mod 1_000_000_007

  def number_of_good_partitions(nums) do
    nums
    |> Enum.reduce({%{}, 0, 1}, fn num, {last_seen, last_count, total} ->
      new_last_seen = Map.update(last_seen, num, 1, &(&1 + 1))
      new_count = if Map.get(last_seen, num), do: last_count, else: (last_count * 2) rem @mod
      {new_last_seen, new_count, (total + new_count) rem @mod}
    end)
    |> then(fn {_last_seen, _last_count, total} -> total end)
  end
end"
elixir,compile_error,"Line 5: ** (SyntaxError) unexpected comma. Parentheses are required to solve ambiguity inside containers.
This error may happen when you forget a comma in a list or other container:
    [a, b c, d]
Or when you have ambiguous calls:
    [function a, b, c]
In the example above, we don't know if the values ""b"" and ""c"" belongs to the list or the function ""function"". You can solve this by explicitly adding parentheses:
    [one, function(a, b, c)]
Elixir cannot compile otherwise. Syntax error before: ','
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\find-building-where-alice-and-bob-can-meet\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec leftmost_building_queries(heights :: [integer], queries :: [[integer]]) :: [integer]
  def leftmost_building_queries(heights, queries) do
    max_right = Enum.reduce(heights, [], fn x, acc -> 
      [if acc == [], do: x, else: max(x, hd(acc))] ++ acc
    end) |> Enum.reverse()

    Enum.map(queries, fn [a, b] ->
      cond do
        a > b -> -1
        max_right |> Enum.drop(a) |> Enum.take(b - a + 1) |> Enum.find_index(&(heights[a] < &1 and heights[b] < &1)) |> case do
          nil -> -1
          index -> a + index
        end
        true -> if heights[a] < heights[b], do: b, else: -1
      end
    end)
  end
end"
elixir,compile_error,"Line 5: ** (SyntaxError) unexpected comma. Parentheses are required to solve ambiguity inside containers.
This error may happen when you forget a comma in a list or other container:
    [a, b c, d]
Or when you have ambiguous calls:
    [function a, b, c]
In the example above, we don't know if the values ""b"" and ""c"" belongs to the list or the function ""function"". You can solve this by explicitly adding parentheses:
    [one, function(a, b, c)]
Elixir cannot compile otherwise. Syntax error before: ','
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\find-building-where-alice-and-bob-can-meet\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec leftmost_building_queries(heights :: [integer], queries :: [[integer]]) :: [integer]
  def leftmost_building_queries(heights, queries) do
    max_right = Enum.reduce(heights, [], fn x, acc -> 
      [if acc == [], do: x, else: max(x, hd(acc))] ++ acc
    end) |> Enum.reverse()

    Enum.map(queries, fn [a, b] ->
      cond do
        a > b -> -1
        true ->
          Enum.with_index(max_right)
          |> Enum.drop(a)
          |> Enum.take(b - a + 1)
          |> Enum.find_value(-1, fn {value, index} -> 
            if heights[a] < value and heights[b] < value, do: {:cont, a + index}, else: {:cont, -1}
          end)
      end
    end)
  end
end"
elixir,compile_error,"Line 5: ** (SyntaxError) unexpected comma. Parentheses are required to solve ambiguity inside containers.
This error may happen when you forget a comma in a list or other container:
    [a, b c, d]
Or when you have ambiguous calls:
    [function a, b, c]
In the example above, we don't know if the values ""b"" and ""c"" belongs to the list or the function ""function"". You can solve this by explicitly adding parentheses:
    [one, function(a, b, c)]
Elixir cannot compile otherwise. Syntax error before: ','
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\find-building-where-alice-and-bob-can-meet\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec leftmost_building_queries(heights :: [integer], queries :: [[integer]]) :: [integer]
  def leftmost_building_queries(heights, queries) do
    max_right = Enum.reduce(heights, [], fn x, acc -> 
      [if acc == [], do: x, else: max(x, hd(acc))] ++ acc
    end) |> Enum.reverse()

    Enum.map(queries, fn [a, b] ->
      if a > b, do: -1, else:
        Enum.drop(max_right, a)
        |> Enum.take(b - a + 1)
        |> Enum.find_index(&(heights[a] < heights[a + &1] and heights[b] < heights[a + &1]))
        |> (fn 
              nil -> -1
              index -> a + index
            end).()
    end)
  end
end"
elixir,compile_error,"** (ArgumentError) ranges (first..last//step) expect both sides to be integers, got: ~c""a""..~c""z""
    (elixir 1.15.7) lib/kernel.ex:4056: Kernel.validate_range!/2
    (elixir 1.15.7) expanding macro: Kernel.""..""/2
Line 9:     Solution.do_max_partitions_after_operations/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 9:     Solution.do_max_partitions_after_operations/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 10:     Solution.do_max_partitions_after_operations/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2",../questions/Hard\maximize-the-number-of-partitions-after-operations\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec max_partitions_after_operations(s :: String.t(), k :: integer()) :: integer()
  def max_partitions_after_operations(s, k) do
    if k >= 26, do: 1, else: do_max_partitions_after_operations(s, k)
  end

  defp do_max_partitions_after_operations(s, k) do
    1..String.length(s)
    |> Enum.map(fn _ -> Enum.map('a'..'z', fn c -> try_change_and_count_partitions(s, c, k) end) end)
    |> List.flatten()
    |> Enum.max()
  end

  defp try_change_and_count_partitions(s, char, k) do
    0..String.length(s)-1
    |> Enum.map(fn i -> change_char_at(s, i, char) end)
    |> Enum.map(&count_partitions(&1, k))
    |> Enum.max()
  end

  defp change_char_at(s, i, char) do
    String.slice(s, 0, i) <> to_string([char]) <> String.slice(s, i+1, String.length(s)-i-1)
  end

  defp count_partitions(s, k) do
    count_partitions(s, k, 0)
  end

  defp count_partitions("""", _k, count), do: count

  defp count_partitions(s, k, count) do
    prefix = longest_prefix_with_k_distinct(s, k, """")
    count_partitions(String.slice(s, String.length(prefix), String.length(s)), k, count + 1)
  end

  defp longest_prefix_with_k_distinct("""", _k, acc), do: acc

  defp longest_prefix_with_k_distinct(s, k, acc) do
    next_char = String.at(s, 0)
    new_acc = acc <> to_string([next_char])
    if MapSet.size(MapSet.new(String.to_charlist(new_acc))) > k, do: acc, else: longest_prefix_with_k_distinct(String.slice(s, 1, String.length(s)), k, new_acc)
  end
end"
elixir,compile_error,"Line 37: Char 1: ** (SyntaxError) unexpected reserved word: end
    HINT: the ""end"" on line 30 may not have a matching ""do"" defined before it (based on indentation)
    |
 37 | end
    | ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\maximize-the-number-of-partitions-after-operations\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_partitions_after_operations(s :: String.t(), k :: integer()) :: integer()
  def max_partitions_after_operations(s, k) do
    1..String.length(s)
    |> Enum.map(fn _ ->
      Enum.map(?a..?z, fn c ->
        partitions_after_optional_change(String.graphemes(s), c, k)
      end)
    end)
    |> List.flatten()
    |> Enum.max()
  end

  defp partitions_after_optional_change(graphemes, change_char, k) do
    Enum.map(0..length(graphemes) - 1, fn i ->
      changed = List.update_at(graphemes, i, fn _ -> change_char end)
      count_partitions(changed, k, 0, %{})
    end)
    |> Enum.max()
  end

  defp count_partitions([], _k, count, _), do: count

  defp count_partitions([h | t], k, count, chars) when map_size(chars) <= k do
    if Map.has_key?(chars, h), do:
      count_partitions(t, k, count, Map.update(chars, h, 1, &(&1 + 1)))
    else
      count_partitions(t, k, count, Map.put(chars, h, 1))
    end
  end

  defp count_partitions(_rest, k, count, chars) when map_size(chars) > k, do: count + 1

  defp count_partitions(rest, k, count, _chars) do
    count_partitions(rest, k, count + 1, %{})
  end
end"
elixir,compile_error,"error: undefined variable ""k""
Line 20:   Solution.group_items_by_category/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Hard\maximum-elegance-of-a-k-length-subsequence\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_maximum_elegance(items :: [[integer]], k :: integer) :: integer
  def find_maximum_elegance(items, k) do
    with {:ok, grouped_items} <- group_items_by_category(items),
         {:ok, sorted_items} <- sort_items_by_profit(grouped_items),
         {:ok, selected_items} <- select_items(sorted_items, k) do
      calculate_elegance(selected_items)
    else
      _ -> 0
    end
  end

  defp group_items_by_category(items) do
    items
    |> Enum.group_by(fn [_, c] -> c end, fn [p, _] -> p end)
    |> Enum.map(fn {_k, v} -> Enum.sort(v, &>=/2) end)
    |> Enum.sort_by(&Enum.count(&1), :desc)
    |> Enum.map(&Tuple.to_list/1)
    |> Enum.concat()
    |> Enum.take(k)
    |> Enum.frequencies()
    |> Map.to_list()
    |> Enum.reduce([], fn {k, v}, acc -> acc ++ Enum.map(1..v, fn _ -> k end) end)
    |> Enum.sort(&>=/2)
    |> case do
      [] -> {:error, :no_items}
      grouped -> {:ok, grouped}
    end
  end

  defp sort_items_by_profit(grouped_items) do
    grouped_items
    |> Enum.sort(&(&1 >= &2))
    |> case do
      [] -> {:error, :no_items_sorted}
      sorted -> {:ok, sorted}
    end
  end

  defp select_items(sorted_items, count) do
    selected_items = Enum.take(sorted_items, count)
    if Enum.count(selected_items) == count, do: {:ok, selected_items}, else: {:error, :not_enough_items}
  end

  defp calculate_elegance(selected_items) do
    total_profit = Enum.sum(selected_items)
    distinct_categories = Enum.count(selected_items)
    total_profit + distinct_categories * distinct_categories
  end
end"
elixir,compile_error,"error: undefined variable ""i""
Line 36:   Solution.count_factors/4
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Hard\maximum-element-sum-of-a-complete-subset-of-indices\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_sum(nums :: [integer]) :: integer
  def maximum_sum(nums) do
    nums
    |> Enum.map(&prime_factors_count(&1))
    |> group_by_factors()
    |> Map.values()
    |> Enum.map(&Enum.sum(&1))
    |> Enum.max()
  end

  defp prime_factors_count(n) when n > 1 do
    2..:math.sqrt(n)
    |> Enum.reduce_while({n, %{}}, fn i, {m, acc} ->
      if rem(m, i) == 0 do
        {new_m, new_acc} = count_factors(m, i, acc)
        {:cont, {new_m, new_acc}}
      else
        {:cont, {m, acc}}
      end
    end)
    |> finalize_factors()
  end

  defp prime_factors_count(1), do: %{}

  defp count_factors(m, i, acc) do
    count_factors(m, i, acc, 0)
  end

  defp count_factors(m, i, acc, count) when rem(m, i) == 0 do
    count_factors(div(m, i), i, acc, count + 1)
  end

  defp count_factors(m, _, acc, count) when count > 0 do
    {m, Map.update(acc, to_string(%{i => count}), count, &(&1 + count))}
  end

  defp count_factors(m, _, acc, _count), do: {m, acc}

  defp finalize_factors({1, acc}), do: acc
  defp finalize_factors({m, acc}), do: Map.update(acc, to_string(%{m => 1}), 1, &(&1 + 1))

  defp group_by_factors(nums) do
    Enum.reduce(nums, %{}, fn factors, acc ->
      Map.update(acc, Enum.sort(factors |> Enum.filter(fn {_, v} -> rem(v, 2) == 1 end), &(&1 < &2)), [Enum.sum(Map.keys(factors))], &(&1 ++ [Enum.sum(Map.keys(factors))]))
    end)
  end
end"
elixir,compile_error,"error: undefined function div/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 17:   Solution.factorize/1
error: undefined function n/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 17:   Solution.factorize/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Hard\maximum-element-sum-of-a-complete-subset-of-indices\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec maximum_sum(nums :: [integer]) :: integer
  def maximum_sum(nums) do
    nums
    |> Enum.map(&factorize(&1))
    |> Enum.reduce(%{}, fn factors, acc -> 
      key = Enum.sort(factors)
      Map.update(acc, key, Enum.sum(factors), &(&1 + Enum.sum(factors)))
    end)
    |> Map.values()
    |> Enum.max()
  end

  defp factorize(n) do
    2..n
    |> Enum.reduce_while([], fn x, acc ->
      if rem(n, x) == 0 and is_perfect_square(n div x), do: {:halt, [x | acc]}, else: {:cont, acc}
    end)
  end

  defp is_perfect_square(x) do
    square_root = :math.sqrt(x) |> round
    square_root * square_root == x
  end
end"
elixir,compile_error,"error: nested captures are not allowed. You cannot define a function using  the capture operator & inside another function defined via &. Got invalid nested capture: &max/2
Line 11:   Solution.maximum_sum/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (stdlib 5.1.1) lists.erl:1706: :lists.mapfoldl_1/3
    (stdlib 5.1.1) lists.erl:1707: :lists.mapfoldl_1/3
    (elixir 1.15.7) src/elixir_fn.erl:140: :elixir_fn.escape/3
    (elixir 1.15.7) src/elixir_fn.erl:112: :elixir_fn.capture_expr/6
    (elixir 1.15.7) expanding macro: Kernel.|>/2",../questions/Hard\maximum-element-sum-of-a-complete-subset-of-indices\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_sum(nums :: [integer]) :: integer
  def maximum_sum(nums) do
    nums
    |> Enum.map(&factor_counts/1)
    |> Enum.reduce(%{}, fn factors, acc ->
      Map.update(acc, Map.keys(factors) |> Enum.sort(), factors, &merge_factors(&1, factors))
    end)
    |> Map.values()
    |> Enum.map(&Map.values(&1))
    |> Enum.map(&Enum.reduce(&1, 0, &max/2))
    |> Enum.max()
  end

  defp factor_counts(n), do: prime_factors(n, 2, %{})

  defp prime_factors(1, _, acc), do: acc
  defp prime_factors(n, i, acc) when n < i, do: acc
  defp prime_factors(n, i, acc) do
    if rem(n, i) == 0 do
      new_acc = Map.update(acc, i, 1, &(&1 + 1))
      prime_factors(div(n, i), i, new_acc)
    else
      prime_factors(n, i+1, acc)
    end
  end

  defp merge_factors(acc, factors) do
    Map.merge(acc, factors, fn _, v1, v2 -> v1 + v2 end)
  end

  defp max(a, b), do: if(a > b, do: a, else: b)
end"
elixir,compile_error,"warning: missing parentheses for expression following ""do:"" keyword. Parentheses are required to solve ambiguity inside keywords.
This error happens when you have function calls without parentheses inside keywords. For example:
    function(arg, one: nested_call a, b, c)
    function(arg, one: if expr, do: :this, else: :that)
In the examples above, we don't know if the arguments ""b"" and ""c"" apply to the function ""function"" or ""nested_call"". Or if the keywords ""do"" and ""else"" apply to the function ""function"" or ""if"". You can solve this by explicitly adding parentheses:
    function(arg, one: if(expr, do: :this, else: :that))
    function(arg, one: nested_call(a, b, c))
Ambiguity found at:
  solution.ex:43
warning: variable ""dp"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 9:   Solution.minimum_changes/2
warning: variable ""ndp"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 19:   Solution.minimum_changes/2
warning: variable ""dp"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 23:   Solution.minimum_changes/2
warning: variable ""changes"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 35:   Solution.calculate_changes/1
warning: function length/1 is unused
Line 42:   Solution (module)
warning: function min/2 is unused
Line 43:   Solution (module)
error: imported Kernel.min/2 conflicts with local function
Line 43:   Solution (module)
error: imported Kernel.length/1 conflicts with local function
Line 42:   Solution (module)
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Hard\minimum-changes-to-make-k-semi-palindromes\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_changes(s :: String.t, k :: integer) :: integer
  def minimum_changes(s, k) do
    dp = :array.new(fn -> :array.new(fn -> 1000 end, length(s) + 1) end, length(s) + 1)
    dp = :array.set(dp, 0, :array.set(:array.new(length(s) + 1), 0, 0))

    for i <- 1..String.length(s) do
      for j <- i..String.length(s) do
        dp = :array.set(dp, i, :array.set(:array.get(dp, i), j, calculate_changes(String.slice(s, i-1, j-i+1))))
      end
    end

    for _i <- 1..k do
      ndp = :array.new(fn -> 1000 end, length(s) + 1)
      ndp = :array.set(ndp, 0, 0)

      for j <- 1..String.length(s) do
        for l <- 0..j-1 do
          ndp = :array.set(ndp, j, min(:array.get(ndp, j), :array.get(ndp, l) + :array.get(:array.get(dp, l+1), j)))
        end
      end

      dp = :array.new(fn -> ndp end, length(s) + 1)
    end

    :array.get(:array.get(dp, String.length(s)), String.length(s))
  end

  defp calculate_changes(substring) do
    len = String.length(substring)
    changes = 0

    for i <- 0..div(len-1, 2) do
      if String.at(substring, i) != String.at(substring, len-i-1) do
        changes = changes + 1
      end
    end

    changes
  end

  defp length(s), do: String.length(s)
  defp min(a, b), do: if a < b, do: a, else: b
end"
elixir,compile_error,"Line 18: Char 55: ** (SyntaxError) syntax error before: 'div'
    |
 18 |         new_sum = sum - k * div(v, 2) + k * div(v, 2) div 2
    |                                                       ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\minimum-operations-to-form-subsequence-with-target-sum\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec min_operations(nums :: [integer], target :: integer) :: integer
  def min_operations(nums, target) do
    nums
    |> Enum.reduce(%{sum: 0, count: 0, freq: Map.new}, fn x, acc ->
      sum = acc.sum + x
      freq = Map.update(acc.freq, x, 1, &(&1 + 1))
      %{acc | sum: sum, freq: freq}
    end)
    |> find_min_operations(target)
  end

  defp find_min_operations(%{sum: sum, count: count, freq: freq} = acc, target) when sum < target, do: -1
  defp find_min_operations(%{sum: sum, count: count, freq: freq}, target) when sum == target, do: count
  defp find_min_operations(%{sum: sum, count: count, freq: freq} = acc, target) do
    Enum.reduce_while(freq, acc, fn
      {k, v}, %{sum: sum, count: cnt} when sum >= target ->
        new_sum = sum - k * div(v, 2) + k * div(v, 2) div 2
        if new_sum >= target do
          {:cont, %{sum: new_sum, count: cnt + div(v, 2), freq: update_freq(freq, k)}}
        else
          {:halt, cnt + div(v, 2)}
        end
      _, acc ->
        {:cont, acc}
    end)
    |> case do
      %{count: final_count} -> final_count
      count when is_integer(count) -> count
    end
  end

  defp update_freq(freq, k) do
    freq
    |> Map.update(k, 0, &(&1 - div(&1, 2)))
    |> Map.update(k div 2, 0, &(&1 + div(freq[k], 2) * 2))
  end
end"
elixir,compile_error,"warning: variable ""target"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 33:   Solution.result_to_integer/3
error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 13:   Solution.min_operations/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Hard\minimum-operations-to-form-subsequence-with-target-sum\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec min_operations(nums :: [integer], target :: integer) :: integer
  def min_operations(nums, target) do
    nums
    |> Enum.sort(:desc)
    |> Enum.reduce_while({0, target}, fn num, {ops, remaining} ->
      if remaining >= num do
        {:cont, {ops, remaining - num}}
      else
        new_num = num
        ops_acc = ops

        while new_num > remaining and new_num > 1 do
          new_num = div(new_num, 2)
          ops_acc = ops_acc + 1
        end

        if new_num <= remaining do
          {:cont, {ops_acc, remaining - new_num}}
        else
          {:halt, {ops, remaining}}
        end
      end
    end)
    |> case do
      {_, 0} -> :ok
      _ -> :error
    end
    |> result_to_integer(nums, target)
  end

  defp result_to_integer(:ok, _, _), do: 0
  defp result_to_integer(:error, nums, target) do
    nums
    |> Enum.map(&(&1 |> Math.log2() |> trunc()))
    |> Enum.sum()
    |> (&(&1 + 1)).()
  end
end"
elixir,compile_error,"error: misplaced operator ->
This typically means invalid syntax or a macro is not available in scope
Line 6:   Solution.minimum_time/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
Line 3:     (module)",../questions/Hard\minimum-time-to-make-array-sum-at-most-x\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_time(nums1 :: [integer], nums2 :: [integer], x :: integer) :: integer
  def minimum_time(nums1, nums2, x) do
    with {:ok, time} <- try_reduce(nums1, nums2, x, 0),
      do: time,
      else: _ -> -1
  end

  defp try_reduce(nums1, nums2, x, time),
    do: try_reduce(nums1, nums2, x, time, Enum.zip(nums1, nums2), 0)

  defp try_reduce(_, _, x, time, _, sum) when sum > x, do: {:error, time}
  defp try_reduce(_, _, x, _, _, sum) when sum <= x, do: {:ok, 0}
  defp try_reduce(nums1, nums2, x, time, [], sum), do: try_reduce(nums1, nums2, x, time + 1)
  defp try_reduce(nums1, nums2, x, time, [head | tail], sum) do
    {n1, n2} = head
    new_sum = sum + n1 + (n2 * time)
    if new_sum <= x do
      try_reduce(nums1, nums2, x, time, tail, new_sum)
    else
      try_reduce(nums1, nums2, x, time + 1)
    end
  end
end"
elixir,compile_error,"Line 5: Char 27: ** (SyntaxError) syntax error before: 'rem'
    |
  5 |     |> Stream.filter(&(&1 rem k == 0))
    |                           ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\number-of-beautiful-integers-in-the-range\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec number_of_beautiful_integers(low :: integer, high :: integer, k :: integer) :: integer
  def number_of_beautiful_integers(low, high, k) do
    (low..high)
    |> Stream.filter(&(&1 rem k == 0))
    |> Stream.filter(&even_odd_equal?(Integer.digits(&1)))
    |> Enum.count()
  end

  defp even_odd_equal?(digits) do
    counts = Enum.frequencies_by(digits, &rem(&1, 2))
    Map.get(counts, 0, 0) == Map.get(counts, 1, 0)
  end
end"
elixir,compile_error,"error: undefined variable ""n""
Line 8:   Solution.number_of_ways/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Hard\string-transformation\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec number_of_ways(s :: String.t(), t :: String.t(), k :: integer()) :: integer()
  def number_of_ways(s, t, k) do
    mod = 1_000_000_007

    if s == t do
      if k == 1 do
        rem(n - 1, mod)
      else
        rem(2, mod)
      end
    else
      if k == 1 do
        0
      else
        positions = for i <- 1..String.length(s) - 1, do: String.slice(s, -i) <> String.slice(s, 0, String.length(s) - i), into: [], uniq: true
        count = Enum.count(positions, fn p -> p == t end)
        if k == 2 do
          count
        else
          rem(count * pow(2, k - 2, mod), mod)
        end
      end
    end
  end

  defp pow(_base, 0, _mod), do: 1
  defp pow(base, exp, mod) do
    case exp do
      1 -> base
      _ ->
        half_exp = div(exp, 2)
        half_res = pow(base, half_exp, mod)
        if rem(exp, 2) == 0 do
          rem(half_res * half_res, mod)
        else
          rem(half_res * half_res * base, mod)
        end
    end
  end
end"
elixir,compile_error,"Line 11: Char 71: ** (SyntaxError) syntax error before: mod
    |
 11 |         {Map.put(last_seen, x, 0), new_sum, (res + new_sum * new_sum) mod mod}
    |                                                                       ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Hard\subarrays-distinct-element-sum-of-squares-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec sum_counts(nums :: [integer]) :: integer
  def sum_counts(nums) do
    mod = 1_000_000_007

    nums
    |> Enum.reduce({%{}, 0, 0}, fn x, {last_seen, sum, res} ->
      {Map.update(last_seen, x, 0, &(&1 + 1)), sum + 1, res}
      |> then(fn {last_seen, sum, res} ->
        new_sum = sum - (last_seen[x] - 1)
        {Map.put(last_seen, x, 0), new_sum, (res + new_sum * new_sum) mod mod}
      end)
    end)
    |> then(fn {_, _, res} -> res end)
  end
end"
elixir,compile_error,"Line 21: Char 27: ** (SyntaxError) syntax error before: '='
    |
 21 |         total_decrements += actual_num
    |                           ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\apply-operations-to-make-all-array-elements-equal-to-zero\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec check_array(nums :: [integer], k :: integer) :: boolean
  def check_array(nums, k) do
    # Initialize the decrements array with zeros
    decrements = Enum.map(nums, fn _ -> 0 end)
    total_decrements = 0

    # Iterate through nums with index
    for {num, idx} <- Enum.with_index(nums) do
      # Calculate the actual number based on previous decrements
      actual_num = num - total_decrements

      # If the actual_num requires decrements
      if actual_num > 0 do
        if idx + k > length(nums) do
          # If the subarray would go beyond the array bounds, return false
          return false
        end

        # Apply the decrement to the range in the decrements array
        total_decrements += actual_num
        if idx + k < length(nums) do
          decrements = List.replace_at(decrements, idx + k, Enum.at(decrements, idx + k) + actual_num)
        end
      end

      # Subtract the increment at the current position for future iterations
      if idx < length(nums) do
        total_decrements -= Enum.at(decrements, idx)
      end
    end

    # If we've gone through the entire array without returning false, return true
    true
  end
end"
elixir,compile_error,"warning: variable ""operations"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 19:   Solution.check_array/2
error: invalid use of _. _ can only be used inside patterns to ignore values and cannot be used in expressions. Make sure you are inside a pattern or change it accordingly
Line 27:   Solution.check_array/2
error: undefined function return/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 16:   Solution.check_array/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\apply-operations-to-make-all-array-elements-equal-to-zero\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec check_array(nums :: [integer], k :: integer) :: boolean
  def check_array(nums, k) do
    # Initialize a map to keep track of the decrement operations needed
    operations = Map.new()

    nums
    |> Enum.with_index()
    |> Enum.reduce(0, fn {num, idx}, acc ->
      # Calculate the total decrement up to this point
      total_decrement = Map.get(operations, idx, 0) + acc
      actual_num = num - total_decrement

      # If actual_num is greater than 0, schedule future decrements
      if actual_num > 0 do
        if idx + k > length(nums), do: return false
        # Update operations for future elements
        for j <- idx..idx+k-1 do
          operations = Map.update(operations, j, actual_num, &(&1 + actual_num))
        end
        acc + actual_num
      else
        acc
      end
    end)
    |> case do
      _ when _ > 0 -> true
      _ -> false
    end
  end
end"
elixir,compile_error,"warning: variable ""cost"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 23:   Solution.min_operations/3
warning: variable ""i"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 24:   Solution.min_operations/3
warning: variable ""cost"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 15:   Solution.min_operations/3
warning: variable ""i"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 16:   Solution.min_operations/3
error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 9:   Solution.min_operations/3
error: undefined function return/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 20:   Solution.min_operations/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\apply-operations-to-make-two-strings-equal\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_operations(s1 :: String.t, s2 :: String.t, x :: integer) :: integer
  def min_operations(s1, s2, x) do
    diff_pairs = Enum.zip(s1 |> String.graphemes, s2 |> String.graphemes)
                  |> Enum.filter(fn {a, b} -> a != b end)

    cost = 0
    i = 0
    while i < length(diff_pairs) do
      {a, _} = Enum.at(diff_pairs, i)
      {b, _} = Enum.at(diff_pairs, i + 1, {"""", """"})

      if a != b and i < length(diff_pairs) - 1 do
        # Perform the second operation
        cost = cost + 1
        i = i + 2
      else
        if x > 1 do
          # If cost of first operation is more effective
          return -1
        else
          # Perform the first operation
          cost = cost + x
          i = i + 1
        end
      end
    end

    cost
  end
end"
elixir,compile_error,"warning: variable ""acc"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 7:   Solution.min_operations/5
error: cannot invoke remote function String.length/1 inside guards
Line 8:   Solution.min_operations/5
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\apply-operations-to-make-two-strings-equal\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec min_operations(s1 :: String.t, s2 :: String.t, x :: integer) :: integer
  def min_operations(s1, s2, x) do
    min_operations(s1, s2, x, 0, 0)
  end

  defp min_operations(_s1, _s2, _x, -1, acc), do: -1
  defp min_operations(s1, s2, x, i, acc) when i >= String.length(s1), do: acc
  defp min_operations(s1, s2, x, i, acc) do
    if String.at(s1, i) != String.at(s2, i) do
      if i < String.length(s1) - 1 and String.at(s1, i+1) != String.at(s2, i+1) do
        # Flip adjacent if it leads towards the solution and is cheaper or necessary
        min_operations(flip(s1, i, i+1), s2, x, i+2, acc + 1)
      else
        if x > 1 do
          # If flipping two non-adjacent bits is not possible or costlier than flipping adjacent
          -1
        else
          # When x is 1, flipping any two bits or adjacent bits costs the same
          min_operations(flip(s1, i, i), s2, x, i+1, acc + x)
        end
      end
    else
      min_operations(s1, s2, x, i+1, acc)
    end
  end

  defp flip(s, i, j) do
    pre = String.slice(s, 0, i)
    a = flip_char(String.at(s, i))
    middle = if i == j, do: """", else: String.slice(s, i+1, j-i-1)
    b = flip_char(String.at(s, j))
    post = String.slice(s, j+1, String.length(s)-j-1)
    pre <> a <> middle <> b <> post
  end

  defp flip_char(""0""), do: ""1""
  defp flip_char(""1""), do: ""0""
end"
elixir,compile_error,"warning: missing parentheses for expression following ""do:"" keyword. Parentheses are required to solve ambiguity inside keywords.
This error happens when you have function calls without parentheses inside keywords. For example:
    function(arg, one: nested_call a, b, c)
    function(arg, one: if expr, do: :this, else: :that)
In the examples above, we don't know if the arguments ""b"" and ""c"" apply to the function ""function"" or ""nested_call"". Or if the keywords ""do"" and ""else"" apply to the function ""function"" or ""if"". You can solve this by explicitly adding parentheses:
    function(arg, one: if(expr, do: :this, else: :that))
    function(arg, one: nested_call(a, b, c))
Ambiguity found at:
  solution.ex:21
warning: variable ""t"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 6:   Solution.maximum_sum_of_heights/1
warning: variable ""t"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 10:   Solution.maximum_sum_of_heights/1
warning: variable ""n"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 4:   Solution.maximum_sum_of_heights/1
warning: function min/2 is unused
Line 21:   Solution (module)
error: imported Kernel.min/2 conflicts with local function
Line 21:   Solution (module)
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\beautiful-towers-i\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec maximum_sum_of_heights(max_heights :: [integer]) :: integer
  def maximum_sum_of_heights(max_heights) do
    n = length(max_heights)

    left_max = Enum.reduce(max_heights, [hd(max_heights)], fn x, [h | t] = acc ->
      [min(x, h + 1) | acc]
    end) |> Enum.reverse()

    right_max = Enum.reduce(Enum.reverse(max_heights), [hd(max_heights)], fn x, [h | t] = acc ->
      [min(x, h + 1) | acc]
    end) |> Enum.reverse()

    combined = Enum.zip(left_max, right_max)
              |> Enum.map(fn {l, r} -> min(l, r) end)
              |> Enum.sum()

    combined
  end

  defp min(a, b), do: if a < b, do: a, else: b
end"
elixir,compile_error,"warning: function min/2 is unused
Line 16:   Solution (module)
error: imported Kernel.min/2 conflicts with local function
Line 16:   Solution (module)
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\beautiful-towers-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_sum_of_heights(max_heights :: [integer]) :: integer
  def maximum_sum_of_heights(max_heights) do
    left_max = max_heights |> scan_left |> Enum.reverse()
    right_max = max_heights |> Enum.reverse() |> scan_left() |> Enum.reverse()

    Enum.zip(left_max, right_max)
    |> Enum.map(fn {l, r} -> min(l, r) end)
    |> Enum.sum()
  end

  defp scan_left([h | t]) do
    Enum.reduce(t, [h], fn x, [h | _] = acc -> [Enum.min(x, h + 1) | acc] end)
  end

  defp min(a, b), do: Kernel.min(a, b)
end"
elixir,compile_error,"error: undefined variable ""nums""
Line 13:   Solution.can_split_array_helper/4
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\check-if-it-is-possible-to-split-array\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec can_split_array(nums :: [integer], m :: integer) :: boolean
  def can_split_array(nums, m) do
    can_split_array_helper(nums, m, [], 0)
  end

  defp can_split_array_helper([], _m, _current_splits, _current_sum), do: true

  defp can_split_array_helper([head | tail], m, current_splits, current_sum) do
    new_sum = current_sum + head

    # Case 1: Add current element to the ongoing sum/subarray
    if new_sum >= m or Enum.count(current_splits) + Enum.count(tail) + 1 == length(nums) do
      can_split_array_helper(tail, m, [new_sum | current_splits], 0)
    else
      # Case 2: Try to split here if possible and move to the next element
      split_here = can_split_array_helper(tail, m, [new_sum | current_splits], 0)

      # Case 3: Continue adding elements to the current subarray
      continue_adding = can_split_array_helper(tail, m, current_splits, new_sum)

      split_here or continue_adding
    end
  end
end"
elixir,compile_error,"warning: the underscored variable ""_index"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 9:   Solution.dfs/5
warning: the underscored variable ""_nums"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 9:   Solution.dfs/5
warning: the underscored variable ""_subarrays"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 11:   Solution.dfs/5
warning: the underscored variable ""_nums"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 11:   Solution.dfs/5
warning: the underscored variable ""_current_sum"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 11:   Solution.dfs/5
error: undefined variable ""m""
Line 11:   Solution.dfs/5
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\check-if-it-is-possible-to-split-array\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec can_split_array(nums :: [integer], m :: integer) :: boolean
  def can_split_array(nums, m) do
    # Starting with the entire array, attempt to split it down to individual elements
    # or subarrays that meet the sum condition.
    dfs(nums, m, 0, 0, 0)
  end

  defp dfs(_nums, _m, _index, _subarrays, _current_sum) when _index == length(_nums) do
    # If we've reached the end of the array, check if we've met the conditions.
    _subarrays == length(_nums) or _current_sum >= m
  end

  defp dfs(nums, m, index, subarrays, current_sum) do
    # Check if adding the current element to the current sum still allows for a valid split.
    if current_sum + Enum.at(nums, index) < m and subarrays + 1 < length(nums) do
      # Continue adding to the current sum/subarray.
      dfs(nums, m, index + 1, subarrays, current_sum + Enum.at(nums, index))
    else
      # Try to split here by considering this element as the start of a new subarray
      # or including it in the current sum if it doesn't exceed the condition.
      split_here = if current_sum + Enum.at(nums, index) >= m, do: 1, else: 0

      # Option 1: Split and start a new subarray with the current element
      split_and_start_new = dfs(nums, m, index + 1, subarrays + split_here, Enum.at(nums, index))

      # Option 2: Include the current element in the current sum/subarray if not splitting
      include_in_current = if split_here == 0, do: dfs(nums, m, index + 1, subarrays, current_sum + Enum.at(nums, index)), else: false

      split_and_start_new or include_in_current
    end
  end
end"
elixir,compile_error,"error: spec for undefined function check_strings/2
  solution.ex:2
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3",../questions/Medium\check-if-strings-can-be-made-equal-with-operations-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec check_strings(s1 :: String.t(), s2 :: String.t()) :: boolean() do
    s1_even = Enum.filter(0..String.length(s1)-1, &Integer.is_even/1) |> Enum.map(&String.at(s1, &1)) |> Enum.sort()
    s2_even = Enum.filter(0..String.length(s2)-1, &Integer.is_even/1) |> Enum.map(&String.at(s2, &1)) |> Enum.sort()
    s1_odd = Enum.filter(0..String.length(s1)-1, &Integer.is_odd/1) |> Enum.map(&String.at(s1, &1)) |> Enum.sort()
    s2_odd = Enum.filter(0..String.length(s2)-1, &Integer.is_odd/1) |> Enum.map(&String.at(s2, &1)) |> Enum.sort()

    s1_even == s2_even && s1_odd == s2_odd
  end
end"
elixir,compile_error,"warning: variable ""total_subarrays"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 15:   Solution.continuous_subarrays/1
error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 10:   Solution.continuous_subarrays/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\continuous-subarrays\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec continuous_subarrays(nums :: [integer]) :: integer
  def continuous_subarrays(nums) do
    total_subarrays = 0
    start_index = 0

    for end_index <- 0..(length(nums) - 1) do
      # Ensure the subarray [start_index, end_index] is continuous.
      # If not, increment start_index until the subarray becomes continuous.
      while start_index < end_index and not is_continuous?(nums, start_index, end_index) do
        start_index = start_index + 1
      end

      # Add the number of continuous subarrays ending at end_index.
      total_subarrays = total_subarrays + end_index - start_index + 1
    end

    total_subarrays
  end

  defp is_continuous?(nums, start_index, end_index) do
    subarray = Enum.slice(nums, start_index..end_index)
    max_val = Enum.max(subarray)
    min_val = Enum.min(subarray)
    max_val - min_val <= 2
  end
end"
elixir,compile_error,"Line 9: Char 37: ** (SyntaxError) unexpected reserved word: end
    HINT: the ""("" on line 9 is missing terminator "")""
    |
  9 |   defp count_subarrays(nums, start, end, min, max, len) do
    |                                     ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\continuous-subarrays\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec continuous_subarrays(nums :: [integer]) :: integer
  def continuous_subarrays(nums) do
    count_subarrays(nums, 0, 0, 0, 0, length(nums))
  end

  defp count_subarrays(_nums, _start, _end, _min, _max, len) when _end == len, do: 0
  defp count_subarrays(nums, start, _end, _min, _max, len) when _end < start, do: count_subarrays(nums, start, start, hd(nums), hd(nums), len)
  defp count_subarrays(nums, start, end, min, max, len) do
    current = Enum.at(nums, end)
    new_min = min(min, current)
    new_max = max(max, current)

    if new_max - new_min <= 2 do
      # Current subarray is continuous, count it and try to extend it
      1 + count_subarrays(nums, start, end + 1, new_min, new_max, len)
    else
      # Current subarray is not continuous, move start forward
      count_subarrays(nums, start + 1, end, min, max, len)
    end
  end

  defp hd([h | _]), do: h
end"
elixir,compile_error,"** (ArgumentError) invalid right argument for operator ""in"", it expects a compile-time proper list or compile-time range on the right side when used in guard expressions, got: vowels
    (elixir 1.15.7) lib/kernel.ex:4465: Kernel.raise_on_invalid_args_in_2/1
    (elixir 1.15.7) expanding macro: Kernel.in/2
Line 12:     Solution.beautiful_substrings/2",../questions/Medium\count-beautiful-substrings-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec beautiful_substrings(s :: String.t, k :: integer) :: integer
  def beautiful_substrings(s, k) do
    vowels = ""aeiou""
    len = String.length(s)
    count = 0

    for i <- 0..(len-1) do
      for j <- i..(len-1) do
        substring = String.slice(s, i, j-i+1)
        {vowel_count, consonant_count} = Enum.reduce(substring, {0, 0}, fn
          char, {v, c} when char in vowels -> {v + 1, c}
          char, {v, c} -> {v, c + 1}
        end)

        if vowel_count == consonant_count && rem(vowel_count * consonant_count, k) == 0 do
          count = count + 1
        end
      end
    end

    count
  end
end"
elixir,compile_error,"error: invalid expression in guards, anonymous call is not allowed in guards. To learn more about guards, visit: https://hexdocs.pm/elixir/patterns-and-guards.html
  solution.ex:14
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (elixir 1.15.7) src/elixir_fn.erl:17: anonymous fn/4 in :elixir_fn.expand/4",../questions/Medium\count-beautiful-substrings-i\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec beautiful_substrings(s :: String.t, k :: integer) :: integer
  def beautiful_substrings(s, k) do
    is_vowel = fn char -> ""aeiou"" |> String.contains?(char) end
    len = String.length(s)
    count = 0

    for i <- 0..(len-1), reduce: 0 do
      count ->
        for j <- i..(len-1), reduce: count do
          count ->
            substring = String.slice(s, i, j-i+1)
            {vowel_count, consonant_count} = Enum.reduce(substring, {0, 0}, fn
              char, {v, c} when is_vowel.(String.at(char, 0)) -> {v + 1, c}
              char, {v, c} -> {v, c + 1}
            end)

            if vowel_count == consonant_count && rem(vowel_count * consonant_count, k) == 0 do
              count + 1
            else
              count
            end
        end
    end
  end
end"
elixir,compile_error,"** (ArgumentError) invalid right argument for operator ""in"", it expects a compile-time proper list or compile-time range on the right side when used in guard expressions, got: vowels
    (elixir 1.15.7) lib/kernel.ex:4465: Kernel.raise_on_invalid_args_in_2/1
    (elixir 1.15.7) expanding macro: Kernel.in/2
Line 14:     Solution.beautiful_substrings/2",../questions/Medium\count-beautiful-substrings-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec beautiful_substrings(s :: String.t, k :: integer) :: integer
  def beautiful_substrings(s, k) do
    len = String.length(s)
    vowels = ""aeiou""
    count = 0

    for i <- 0..(len - 1), reduce: 0 do
      acc ->
        for j <- i..(len - 1), reduce: acc do
          acc_inner ->
            substring = String.slice(s, i, j - i + 1)
            {vowel_count, consonant_count} = Enum.reduce(substring, {0, 0}, fn
              char, {v, c} when char in vowels -> {v + 1, c}
              _, {v, c} -> {v, c + 1}
            end)

            if vowel_count == consonant_count and rem(vowel_count * consonant_count, k) == 0 do
              acc_inner + 1
            else
              acc_inner
            end
        end
    end
  end
end"
elixir,compile_error,"error: undefined variable ""break""
Line 16:   Solution.count_complete_subarrays/1
warning: variable ""count"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 15:   Solution.count_complete_subarrays/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\count-complete-subarrays-in-an-array\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec count_complete_subarrays(nums :: [integer]) :: integer
  def count_complete_subarrays(nums) do
    distinct_count = Enum.uniq(nums) |> length
    nums_length = length(nums)

    0..(nums_length-1)
    |> Enum.reduce(0, fn left, acc ->
      elements = Map.new()
      count = acc

      for right <- left..(nums_length-1) do
        elements = Map.update(elements, Enum.at(nums, right), 1, &(&1 + 1))
        if map_size(elements) == distinct_count do
          count = count + (nums_length - right)
          break
        end
      end

      count
    end)
  end
end"
elixir,compile_error,"error: undefined variable ""acc_inner""
Line 10:   Solution.count_interesting_subarrays/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\count-of-interesting-subarrays\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec count_interesting_subarrays(nums :: [integer], modulo :: integer, k :: integer) :: integer
  def count_interesting_subarrays(nums, modulo, k) do
    Enum.reduce(0..length(nums) - 1, 0, fn start, acc ->
      acc + Enum.reduce(start..length(nums) - 1, {0, acc}, fn end_, {cnt, acc_inner} ->
        if rem(Enum.at(nums, end_), modulo) == k, do: {cnt + 1, acc_inner}, else: {cnt, acc_inner}
      end)
      |> case do
        {cnt, acc_inner} when rem(cnt, modulo) == k -> acc_inner + 1
        _ -> acc_inner
      end
    end)
  end
end"
elixir,compile_error,"warning: variable ""queries"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 3:   Solution.count_servers/4
error: undefined function queries/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 21:   Solution.count_servers/4
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\count-zero-request-servers\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec count_servers(n :: integer, logs :: [[integer]], x :: integer, queries :: [integer]) :: [integer]
  def count_servers(n, logs, x, queries) do
    logs
    |> Enum.reduce(%{}, fn [server_id, time], acc ->
      Map.update(acc, server_id, [time], fn times -> [time | times] end)
    end)
    |> Enum.map(fn {k, v} -> {k, Enum.sort(v)} end)
    |> Enum.reduce(%{}, fn {server_id, times}, acc ->
      List.foldl(times, acc, fn time, acc ->
        Map.update(acc, time, [server_id], fn servers -> [server_id | servers] end)
      end)
    end)
    |> Enum.group_by(fn {time, _} -> time end, fn {_, servers} -> servers end)
    |> Map.to_list()
    |> Enum.sort()
    |> Enum.reduce(%{}, fn {time, servers_lists}, acc ->
      servers = Enum.flat_map(servers_lists, fn servers -> servers end)
      Map.put(acc, time, Enum.uniq(servers))
    end)
    |> queries |> Enum.map(fn query ->
      active_servers = Enum.flat_map(
        Enum.filter(
          Map.to_list(),
          fn {time, _} -> time > query - x and time <= query end
        ),
        fn {_, servers} -> servers end
      )
      |> Enum.uniq()
      n - Enum.count(active_servers)
    end)
  end
end"
elixir,compile_error,"** (ArgumentError) cannot invoke defp/2 inside function/macro
    (elixir 1.15.7) lib/kernel.ex:6593: Kernel.assert_no_function_scope/3
    (elixir 1.15.7) lib/kernel.ex:5202: Kernel.define/4
    (elixir 1.15.7) expanding macro: Kernel.defp/2
Line 4:     Solution.minimize_concatenated_length/1",../questions/Medium\decremental-string-concatenation\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimize_concatenated_length(words :: [String.t]) :: integer
  def minimize_concatenated_length(words) do
    defp join(a, b) do
      if String.ends_with?(a, String.first(b)), do: a <> String.slice(b, 1..-1), else: a <> b
    end

    defp find_min_length([word], acc), do: acc + String.length(word)
    defp find_min_length([h | t], acc) do
      [next | _] = t
      join1 = join(h, next)
      join2 = join(next, h)
      if String.length(join1) <= String.length(join2) do
        find_min_length(t, acc + String.length(h) - (if String.ends_with?(h, String.first(next)), do: 1, else: 0))
      else
        find_min_length([h | Enum.slice(t, 1..-1)], acc + String.length(next) - (if String.ends_with?(next, String.first(h)), do: 1, else: 0))
      end
    end

    find_min_length(words, 0)
  end
end"
elixir,compile_error,"Line 8: Char 19: ** (SyntaxError) syntax error before: 'div'
    |
  8 |       n * (n + 1) div 2
    |                   ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\determine-the-minimum-sum-of-a-k-avoiding-array\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_sum(n :: integer, k :: integer) :: integer
  def minimum_sum(n, k) do
    if n > div(k, 2) do
      over = n - div(k, 2)
      div(k, 2) * (div(k, 2) - 1) + over * k
    else
      n * (n + 1) div 2
    end
  end
end"
elixir,compile_error,"error: undefined function round/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 6:   Solution.get_good_indices/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\double-modular-exponentiation\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec get_good_indices(variables :: [[integer]], target :: integer) :: [integer]
  def get_good_indices(variables, target) do
    Enum.reduce(0..Enum.count(variables)-1, [], fn i, acc ->
      [a, b, c, m] = Enum.at(variables, i)
      if rem(rem(a * b, 10) |> round(:math.pow(c)), m) == target, do: [i | acc], else: acc
    end)
    |> Enum.reverse()
  end
end"
elixir,compile_error,"error: spec for undefined function min_extra_char/2
  solution.ex:2
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3",../questions/Medium\extra-characters-in-a-string\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_extra_char(s :: String.t(), dictionary :: [String.t()]) :: integer() do
    def min_extra_char(s, dictionary) do
      dp = :array.new(byte_size(s) + 1, {:default, length(s) + 1})
      dp = :array.set(0, 0, dp)

      for i <- 0..byte_size(s) do
        min_val = :array.get(i, dp) + 1
        for word <- dictionary do
          if String.starts_with?(String.slice(s, i..-1), word) do
            j = i + byte_size(word)
            min_val = min(min_val, :array.get(j, dp))
            dp = :array.set(j, min_val, dp)
          end
        end
        dp = :array.set(i + 1, min(min_val, :array.get(i + 1, dp)), dp)
      end

      :array.get(byte_size(s), dp) - 1
    end
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe :math.log2(x1)
|> trunc
|> (Kernel.+() / 1)
|> :math.pow(2)
|> trunc
|> Bitwise.band(x1)
|> :math.log2()
|> floor into Kernel.+() / 1, the :/ operator can only take two arguments
    (elixir 1.15.7) lib/macro.ex:376: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 5:     Solution.can_sort_array/1
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 5:     Solution.can_sort_array/1
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 6:     Solution.can_sort_array/1",../questions/Medium\find-if-array-can-be-sorted\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec can_sort_array(nums :: [integer]) :: boolean
  def can_sort_array(nums) do
    nums
    |> Enum.group_by(&(:math.log2(&1) |> trunc |> Kernel.+/1 |> :math.pow(2) |> trunc |> Bitwise.band(&1) |> :math.log2 |> floor |> Kernel.+/1))
    |> Enum.map(fn {_bit_count, values} -> Enum.sort(values) end)
    |> Enum.concat()
    |> Enum.reduce({true, nil}, fn
      x, {true, nil} -> {true, x}
      x, {true, prev} when x >= prev -> {true, x}
      _, _ -> {false, nil}
    end)
    |> elem(0)
  end
end"
elixir,compile_error,"error: unsupported option :limit given to for
Line 4:   Solution.find_indices/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
Line 3:     (module)",../questions/Medium\find-indices-with-index-and-value-difference-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]
  def find_indices(nums, index_difference, value_difference) do
    for i <- 0..(length(nums) - 1),
        j <- 0..(length(nums) - 1),
        abs(i - j) >= index_difference,
        abs(Enum.at(nums, i) - Enum.at(nums, j)) >= value_difference,
        do: [i, j],
        limit: 1
    |> case do
      [] -> [-1, -1]
      [a] -> a
    end
  end
end"
elixir,compile_error,"warning: variable ""current_k"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 24:   Solution.longest_equal_subarray/2
warning: variable ""current_length"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 27:   Solution.longest_equal_subarray/2
warning: variable ""left"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 28:   Solution.longest_equal_subarray/2
warning: variable ""current_k"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 17:   Solution.longest_equal_subarray/2
warning: variable ""current_length"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 20:   Solution.longest_equal_subarray/2
warning: variable ""right"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 21:   Solution.longest_equal_subarray/2
warning: variable ""max_freq"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 10:   Solution.longest_equal_subarray/2
error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 14:   Solution.longest_equal_subarray/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\find-the-longest-equal-subarray\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec longest_equal_subarray(nums :: [integer], k :: integer) :: integer
  def longest_equal_subarray(nums, k) do
    nums
    |> Enum.reduce({%{}, 0}, fn x, ({freq_map, max_freq}) ->
      new_freq_map = Map.update(freq_map, x, 1, &(&1 + 1))
      new_max_freq = Enum.max([max_freq | Map.values(new_freq_map)])
      {new_freq_map, new_max_freq}
    end)
    |> (fn {freq_map, max_freq} ->
      Enum.reduce(Enum.keys(freq_map), 0, fn x, acc ->
        {left, right, current_k, current_length} = {0, 0, k, 0}

        while right < length(nums) do
          if nums |> Enum.at(right) == x or current_k > 0 do
            if nums |> Enum.at(right) != x do
              current_k = current_k - 1
            end

            current_length = current_length + 1
            right = right + 1
          else
            if nums |> Enum.at(left) != x do
              current_k = current_k + 1
            end

            current_length = current_length - 1
            left = left + 1
          end

          acc = max(acc, current_length)
        end

        acc
      end)
    end).()
  end
end"
elixir,compile_error,"error: undefined function div/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 4:   Solution.minimum_possible_sum/2
error: undefined function target/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 4:   Solution.minimum_possible_sum/2
error: undefined function if/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 6:   Solution.minimum_possible_sum/2
error: undefined function target/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 6:   Solution.minimum_possible_sum/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\find-the-minimum-possible-sum-of-a-beautiful-array\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_possible_sum(n :: integer, target :: integer) :: integer
  def minimum_possible_sum(n, target) do
    if rem(target, 2) == 0 and n >= target div 2 do
      (1..n)
      |> Enum.map(fn x -> if x == target div 2, do: x + 1, else: x end)
      |> Enum.sum()
      |> rem(1_000_000_007)
    else
      Enum.sum(1..n)
      |> rem(1_000_000_007)
    end
  end
end"
elixir,compile_error,"warning: the underscored variable ""_end"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 17:   Solution.max_subarray_length/6
error: undefined variable ""nums""
Line 13:   Solution.max_subarray_length/6
error: cannot invoke remote function Access.get/2 inside guards
Line 21:   Solution.remove_until_valid/4
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\length-of-longest-subarray-with-at-most-k-frequency\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec max_subarray_length(nums :: [integer], k :: integer) :: integer
  def max_subarray_length(nums, k) do
    max_subarray_length(nums, k, %{}, 0, 0, 0)
  end

  defp max_subarray_length([], _k, _freq, max_len, _start, _end), do: max_len
  defp max_subarray_length([head | tail], k, freq, max_len, start, _end) do
    new_freq = Map.update(freq, head, 1, &(&1 + 1))
    if new_freq[head] > k do
      new_start = start + 1
      new_end = start + 1
      {new_freq, new_start} = remove_until_valid(new_freq, nums, new_start, k)
      max_subarray_length(tail, k, new_freq, max_len, new_start, new_end)
    else
      max_len = max(max_len, Enum.count(Map.keys(new_freq)))
      max_subarray_length(tail, k, new_freq, max_len, start, _end + 1)
    end
  end

  defp remove_until_valid(freq, [h | t], start, k) when freq[h] > k do
    new_freq = update_in(freq[h], &(&1 - 1))
    remove_until_valid(new_freq, t, start + 1, k)
  end
  defp remove_until_valid(freq, _, start, _k), do: {freq, start}
end"
elixir,compile_error,"error: cannot invoke remote function :maps.values/1 inside guards
Line 20:   Solution.trim_freq/5
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 20:     Solution.trim_freq/5",../questions/Medium\length-of-longest-subarray-with-at-most-k-frequency\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec max_subarray_length(nums :: [integer], k :: integer) :: integer
  def max_subarray_length(nums, k) do
    {max_len, _, _} = Enum.reduce(nums, {0, %{}, 0}, fn x, {max_len, freq, start} ->
      freq = Map.update(freq, x, 1, &(&1 + 1))
      if Map.values(freq) |> Enum.any?(&(&1 > k)) do
        {new_start, new_freq} = trim_freq(freq, nums, start, k)
        {max_len, new_freq, new_start + 1}
      else
        {max(max_len, Enum.count(freq)), freq, start}
      end
    end)
    max_len
  end

  defp trim_freq(freq, nums, start, k) do
    trim_freq(freq, nums, start, k, start)
  end

  defp trim_freq(freq, _nums, _start, _k, index) when Map.values(freq) |> Enum.all?(&(&1 <= k)), do: {index, freq}

  defp trim_freq(freq, nums, start, k, index) do
    current_element = Enum.at(nums, start)
    updated_freq = Map.update!(freq, current_element, &(&1 - 1))
    if updated_freq[current_element] == 0 do
      updated_freq = Map.delete(updated_freq, current_element)
    end
    if Map.values(updated_freq) |> Enum.any?(&(&1 > k)) do
      trim_freq(updated_freq, nums, start + 1, k, index)
    else
      {start, updated_freq}
    end
  end
end"
elixir,compile_error,"error: undefined variable ""nums""
Line 15:   Solution.do_max_subarray_length/7
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\length-of-longest-subarray-with-at-most-k-frequency\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_subarray_length(nums :: [integer], k :: integer) :: integer
  def max_subarray_length(nums, k) do
    do_max_subarray_length(nums, k, %{}, 0, 0, 0, 0)
  end

  defp do_max_subarray_length([], _k, _freq, max_len, _left, _right, _current_max), do: max_len

  defp do_max_subarray_length([head | tail], k, freq, max_len, left, right, current_max) do
    updated_freq = Map.update(freq, head, 1, &(&1 + 1))
    if updated_freq[head] <= k do
      new_max = max(current_max + 1, max_len)
      do_max_subarray_length(tail, k, updated_freq, new_max, left, right + 1, current_max + 1)
    else
      {new_freq, new_left} = update_left(freq, nums, left, k)
      do_max_subarray_length(tail, k, new_freq, max_len, new_left, right + 1, right - new_left + 1)
    end
  end

  defp update_left(freq, [h | t], left, k) do
    new_freq = Map.update!(freq, h, &(&1 - 1))
    if new_freq[h] == k do
      {new_freq, left + 1}
    else
      update_left(new_freq, t, left + 1, k)
    end
  end
end"
elixir,compile_error,"warning: variable ""dp"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 8:   Solution.length_of_longest_subsequence/2
warning: function max/2 is unused
Line 20:   Solution (module)
error: imported Kernel.max/2 conflicts with local function
Line 20:   Solution (module)
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\length-of-the-longest-subsequence-that-sums-to-target\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec length_of_longest_subsequence(nums :: [integer], target :: integer) :: integer
  def length_of_longest_subsequence(nums, target) do
    dp = :maps.from_list(Enum.map(0..target, fn x -> {x, -1} end))
    dp = Map.put(dp, 0, 0)

    for num <- nums do
      dp = Enum.reduce(Map.keys(dp), dp, fn key, acc ->
        if key + num <= target and acc[key] != -1 do
          Map.update(acc, key + num, acc[key] + 1, &max(&1, acc[key] + 1))
        else
          acc
        end
      end)
    end

    dp[target]
  end

  defp max(a, b) do
    if a > b, do: a, else: b
  end
end"
elixir,compile_error,"Line 12: ** (SyntaxError) unexpected comma. Parentheses are required to solve ambiguity in nested calls.
This error happens when you have nested function calls without parentheses. For example:
    parent_call a, nested_call b, c, d
In the example above, we don't know if the parameters ""c"" and ""d"" apply to the function ""parent_call"" or ""nested_call"". You can solve this by explicitly adding parentheses:
    parent_call a, nested_call(b, c, d)
Or by adding commas (in case a nested call is not intended):
    parent_call a, nested_call, b, c, d
Elixir cannot compile otherwise. Syntax error before: ','
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\longest-non-decreasing-subarray-from-two-arrays\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_non_decreasing_length(nums1 :: [integer], nums2 :: [integer]) :: integer
  def max_non_decreasing_length(nums1, nums2) do
    n = length(nums1)
    dp1 = List.duplicate(0, n)
    dp2 = List.duplicate(0, n)

    dp1 = List.replace_at(dp1, 0, 1)
    dp2 = List.replace_at(dp2, 0, 1)

    for i <- 1..n-1 do
      dp1 = List.replace_at(dp1, i, if nums1[i] >= nums1[i-1], do: dp1 |> Enum.at(i-1) + 1, else: 1)
      dp1 = List.replace_at(dp1, i, if nums1[i] >= nums2[i-1], do: max(dp1 |> Enum.at(i), dp2 |> Enum.at(i-1) + 1), else: dp1 |> Enum.at(i))

      dp2 = List.replace_at(dp2, i, if nums2[i] >= nums2[i-1], do: dp2 |> Enum.at(i-1) + 1, else: 1)
      dp2 = List.replace_at(dp2, i, if nums2[i] >= nums1[i-1], do: max(dp2 |> Enum.at(i), dp1 |> Enum.at(i-1) + 1), else: dp2 |> Enum.at(i))
    end

    max(Enum.max(dp1), Enum.max(dp2))
  end
end"
elixir,compile_error,"error: cannot invoke remote function Access.get/2 inside guards
Line 6:   Solution.get_words_in_longest_subsequence/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\longest-unequal-adjacent-groups-subsequence-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]
  def get_words_in_longest_subsequence(n, words, groups) do
    {_, indices} = Enum.reduce(0..n-1, {nil, []}, fn
      i, {nil, acc} -> {groups[i], [i | acc]}
      i, {prev_group, acc} when groups[i] != prev_group -> {groups[i], [i | acc]}
      _, acc -> acc
    end)

    indices
    |> Enum.reverse()
    |> Enum.map(&Enum.at(words, &1))
  end
end"
elixir,compile_error,"error: invalid args for &, expected one of:
  * &Mod.fun/arity to capture a remote function, such as &Enum.map/2
  * &fun/arity to capture a local or imported function, such as &is_atom/1
  * &some_code(&1, ...) containing at least one argument as &1, such as &List.flatten(&1)
Got: [j | acc[i] || []]
Line 7:   Solution.get_words_in_longest_subsequence/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) src/elixir_fn.erl:17: anonymous fn/4 in :elixir_fn.expand/4
    (stdlib 5.1.1) lists.erl:1706: :lists.mapfoldl_1/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2",../questions/Medium\longest-unequal-adjacent-groups-subsequence-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]
  def get_words_in_longest_subsequence(n, words, groups) do
    paths = for i <- 0..n-1, j <- 0..n-1, i != j, do: {i, j}
    |> Enum.filter(fn {i, j} -> groups[i] != groups[j] and String.length(words[i]) == String.length(words[j]) and hamming_distance(words[i], words[j]) == 1 end)
    |> Enum.reduce(%{}, fn {i, j}, acc ->
      Map.update(acc, i, [j], &[j | acc[i] || []])
    end)
    |> Enum.map(fn {k, v} -> Enum.uniq([k | v]) end)
    |> Enum.max_by(&length/1, [])
    |> Enum.map(&Enum.at(words, &1))

    if paths == [], do: [], else: paths
  end

  defp hamming_distance(s1, s2) do
    s1 |> String.codepoints()
    |> Enum.zip(String.codepoints(s2))
    |> Enum.count(fn {a, b} -> a != b end)
  end
end"
elixir,compile_error,"error: undefined function tuple_elem/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 12:   Solution.get_words_in_longest_subsequence/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\longest-unequal-adjacent-groups-subsequence-ii\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]
  def get_words_in_longest_subsequence(n, words, groups) do
    {max_seq, _} =
      0..n-1
      |> Enum.reduce({[], %{}}, fn i, {max_seq, dp} ->
        Enum.reduce(0..i-1, {max_seq, dp}, fn j, {max_inner, dp_inner} ->
          if groups[i] != groups[j] and String.length(words[i]) == String.length(words[j]) and hamming_distance(words[i], words[j]) == 1 do
            {j_seq, _} = Map.get(dp_inner, j, {[], 0})
            i_seq = [i | j_seq]
            i_len = length(i_seq)
            if i_len > tuple_elem(max_inner, 1) do
              {i_seq, Map.put(dp_inner, i, {i_seq, i_len})}
            else
              {max_inner, Map.put(dp_inner, i, {i_seq, i_len})}
            end
          else
            {max_inner, dp_inner}
          end
        end)
      end)
    Enum.map(max_seq, &Enum.at(words, &1))
  end

  defp hamming_distance(s1, s2) do
    s1 |> String.graphemes()
    |> Enum.zip(String.graphemes(s2))
    |> Enum.count(fn {a, b} -> a != b end)
  end
end"
elixir,compile_error,"warning: variable ""nums"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 13:   Solution.lexicographically_smallest_array/2
warning: variable ""sorted"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 13:   Solution.lexicographically_smallest_array/2
error: cannot invoke remote function Enum.at/3 inside guards
Line 8:   Solution.lexicographically_smallest_array/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 8:     Solution.lexicographically_smallest_array/2
    (elixir 1.15.7) expanding macro: Kernel.and/2
Line 8:     Solution.lexicographically_smallest_array/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 7:     Solution.lexicographically_smallest_array/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 13:     Solution.lexicographically_smallest_array/2",../questions/Medium\make-lexicographically-smallest-array-by-swapping-elements\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec lexicographically_smallest_array(nums :: [integer], limit :: integer) :: [integer]
  def lexicographically_smallest_array(nums, limit) do
    nums
    |> Enum.with_index()
    |> Enum.sort_by(fn {num, _} -> num end)
    |> Enum.reduce({[], 0, []}, fn
      ({num, idx}, {sorted, last_sorted_idx, acc}) when idx >= last_sorted_idx and abs(num - (nums |> Enum.at(last_sorted_idx, 0))) <= limit ->
        {[num | sorted], idx, [idx | acc]}
      ({num, idx}, {sorted, last_sorted_idx, acc}) ->
        {sorted, last_sorted_idx, acc}
    end)
    |> (fn {sorted, _, acc} -> Enum.reverse(acc) |> Enum.each(fn idx -> nums = List.replace_at(nums, idx, List.first(sorted)); sorted = List.delete_at(sorted, 0) end) end).()
    |> (fn -> nums end).()
  end
end"
elixir,compile_error,"warning: variable ""str2"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 11:   Solution.check_subsequence/3
error: undefined variable ""str2""
Line 17:   Solution.check_subsequence/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\make-string-a-subsequence-using-cyclic-increments\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec can_make_subsequence(str1 :: String.t, str2 :: String.t) :: boolean
  def can_make_subsequence(str1, str2) do
    check_subsequence(str1, str2, false)
  end

  defp check_subsequence(_str1, """", _changed), do: true

  defp check_subsequence("""", _str2, _changed), do: false

  defp check_subsequence([h1 | t1], [h2 | t2] = str2, changed) when h1 == h2 do
    check_subsequence(t1, t2, changed)
  end

  defp check_subsequence([h1 | t1], [h2 | t2], false) do
    next_char = if h1 === 'z', do: 'a', else: <<h1 + 1>>
    if next_char === h2, do: check_subsequence(t1, t2, true), else: check_subsequence(t1, str2, false)
  end

  defp check_subsequence([_h1 | t1], str2, true) do
    check_subsequence(t1, str2, true)
  end
end"
elixir,compile_error,"warning: variable ""str2"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 11:   Solution.check_subsequence/3
error: undefined variable ""str2""
Line 17:   Solution.check_subsequence/3
warning: the underscored variable ""_str2"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 21:   Solution.check_subsequence/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\make-string-a-subsequence-using-cyclic-increments\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec can_make_subsequence(str1 :: String.t, str2 :: String.t) :: boolean
  def can_make_subsequence(str1, str2) do
    check_subsequence(str1, str2, false)
  end

  defp check_subsequence(_str1, """", _changed), do: true

  defp check_subsequence("""", _str2, _changed), do: false

  defp check_subsequence([h1 | t1], [h2 | t2] = str2, changed) when h1 == h2 do
    check_subsequence(t1, t2, changed)
  end

  defp check_subsequence([h1 | t1], [h2 | t2], false) do
    next_char = if h1 === 'z', do: 'a', else: <<h1 + 1>>
    if next_char === h2, do: check_subsequence(t1, t2, true), else: check_subsequence(t1, str2, false)
  end

  defp check_subsequence([_h1 | t1], _str2, true) do
    check_subsequence(t1, _str2, true)
  end
end"
elixir,compile_error,"warning: variable ""prev_max"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 9:   Solution.maximize_the_profit/2
error: undefined variable ""prev_max""
Line 10:   Solution.maximize_the_profit/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\maximize-the-profit-as-the-salesman\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec maximize_the_profit(n :: integer, offers :: [[integer]]) :: integer
  def maximize_the_profit(n, offers) do
    sorted_offers = Enum.sort_by(offers, fn [_, e, _] -> e end)
    dp = Enum.reduce(0..n, %{0 => 0}, fn i, acc ->
      max_gold = Map.get(acc, i - 1, 0)
      Enum.reduce(sorted_offers, acc, fn [s, e, g], acc_inner ->
        if e < i, do: acc_inner, else:
          prev_max = Map.get(acc, s - 1, 0)
          new_max = max(Map.get(acc_inner, e, 0), prev_max + g)
          Map.put(acc_inner, e, new_max)
      end)
      |> Map.put(i, max(max_gold, Map.get(acc, i, 0)))
    end)
    Map.values(dp) |> Enum.max()
  end
end"
elixir,compile_error,"error: undefined variable ""comp""
Line 15:   Solution.max_number_of_alloys/6
warning: variable ""machine"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 5:   Solution.max_number_of_alloys/6
warning: variable ""total_cost"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 6:   Solution.max_number_of_alloys/6
warning: variable ""n"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 3:   Solution.max_number_of_alloys/6
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\maximum-number-of-alloys\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec max_number_of_alloys(n :: integer, k :: integer, budget :: integer, composition :: [[integer]], stock :: [integer], cost :: [integer]) :: integer
  def max_number_of_alloys(n, k, budget, composition, stock, cost) do
    1..k
    |> Enum.map(fn machine ->
      total_cost = Enum.with_index(composition)
      |> Enum.map(fn {comp, _index} ->
        Enum.with_index(comp)
        |> Enum.reduce(0, fn {amount, i}, acc ->
          extra_needed = max(0, amount - Enum.at(stock, i))
          acc + extra_needed * Enum.at(cost, i)
        end)
      end)
      |> Enum.map(fn cost_for_machine ->
        if cost_for_machine > budget, do: 0, else: div(budget - cost_for_machine, Enum.sum(Enum.with_index(comp, fn {amount, i} -> Enum.at(cost, i) * amount end)))
      end)
    end)
    |> List.flatten()
    |> Enum.max()
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe nums into Enum.at(j) - nums, the :- operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 9:     Solution.maximum_jumps/2
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 9:     Solution.maximum_jumps/2
    (elixir 1.15.7) expanding macro: Kernel.and/2
Line 9:     Solution.maximum_jumps/2",../questions/Medium\maximum-number-of-jumps-to-reach-the-last-index\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_jumps(nums :: [integer], target :: integer) :: integer
  def maximum_jumps(nums, target) do
    dp = Enum.map(0..(length(nums)-1), fn _ -> -1 end)
    dp = List.replace_at(dp, 0, 0)

    for i <- 0..(length(nums)-2) do
      for j <- (i+1)..(length(nums)-1) do
        if dp |> Enum.at(i) != -1 and abs(nums |> Enum.at(j) - nums |> Enum.at(i)) <= target do
          current_jumps = dp |> Enum.at(j)
          if current_jumps == -1 or current_jumps > dp |> Enum.at(i) + 1 do
            dp = List.replace_at(dp, j, dp |> Enum.at(i) + 1)
          end
        end
      end
    end

    Enum.at(dp, length(nums)-1)
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe jumps into Enum.at(i) + 1, the :+ operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 12:     Solution.maximum_jumps/2
    (elixir 1.15.7) expanding macro: Kernel.if/2
Line 11:     Solution.maximum_jumps/2",../questions/Medium\maximum-number-of-jumps-to-reach-the-last-index\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_jumps(nums :: [integer], target :: integer) :: integer
  def maximum_jumps(nums, target) do
    n = length(nums)
    jumps = Enum.map(0..(n-1), fn _ -> 0 end)
    max_reachable = 0

    for i <- 0..(n-2) do
      max_reachable = max(max_reachable, i)
      for j <- (max_reachable+1)..min(n-1, i + target) do
        if nums[j] - nums[i] <= target do
          jumps = List.update_at(jumps, j, fn _ -> jumps |> Enum.at(i) + 1 end)
          max_reachable = j
        end
      end
    end

    if Enum.at(jumps, n-1) > 0, do: Enum.at(jumps, n-1), else: -1
  end
end"
elixir,compile_error,"error: undefined function &&&/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 18:   Solution.bit_set?/3
error: undefined function <<</2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 18:   Solution.bit_set?/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_maximum_number(k :: integer, x :: integer) :: integer
  def find_maximum_number(k, x) do
    find_maximum_number(0, k, x, 1, 0)
  end

  defp find_maximum_number(num, k, x, bit_pos, total_price) do
    if total_price > k do
      num - 1
    else
      new_total_price = total_price + Enum.count(1..num, fn n -> bit_set?(n, bit_pos, x) end)
      find_maximum_number(num + 1, k, x, bit_pos + x, new_total_price)
    end
  end

  defp bit_set?(n, bit_pos, x) do
    bit = bit_pos - 1
    n &&& (1 <<< bit) != 0 and rem(bit, x) == 0
  end
end"
elixir,compile_error,"warning: variable ""x"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 7:   Solution.max_num/4
warning: function bit_size/1 is unused
Line 18:   Solution (module)
error: imported Kernel.bit_size/1 conflicts with local function
Line 18:   Solution (module)
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec find_maximum_number(k :: integer, x :: integer) :: integer
  def find_maximum_number(k, x) do
    max_num(1, k, x, 0)
  end

  defp max_num(num, k, x, sum) when sum > k, do: num - 2

  defp max_num(num, k, x, sum) do
    new_sum = sum + Enum.count(1..num, fn n -> set_bit_in_position?(n, x) end)
    max_num(num + 1, k, x, new_sum)
  end

  defp set_bit_in_position?(n, x) do
    Enum.any?(0..(bit_size(n) - 1), fn i -> rem(i + 1, x) == 0 && Bitwise.band(n, Bitwise.bsl(1, i)) != 0 end)
  end

  defp bit_size(n) do
    :math.log2(n |> Kernel.abs() |> Kernel.max(1)) |> Float.ceil() |> Kernel.trunc()
  end
end"
elixir,compile_error,"warning: the underscored variable ""_sum"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 7:   Solution.search/5
warning: the underscored variable ""_target"" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore
Line 7:   Solution.search/5
warning: function bit_size/1 is unused
Line 33:   Solution (module)
error: imported Kernel.bit_size/1 conflicts with local function
Line 33:   Solution (module)
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_maximum_number(k :: integer, x :: integer) :: integer
  def find_maximum_number(k, x) do
    search(1, k, x, 0, 1_000_000_000_000_000) # Adjust upper limit as necessary
  end

  defp search(_low, _high, _x, _sum, _target) when _sum > _target, do: -1 # Base case if sum exceeds target

  defp search(low, high, x, k, target) do
    mid = div(low + high, 2)
    sum = Enum.reduce(1..mid, 0, fn n, acc -> acc + count_set_bits(n, x) end)
    if low < high do
      if sum <= k do
        search(mid + 1, high, x, k, target)
      else
        search(low, mid, x, k, target)
      end
    else
      if sum <= k, do: mid, else: mid - 1
    end
  end

  defp count_set_bits(n, x) do
    Enum.reduce(0..(bit_size(n) - 1), 0, fn index, acc ->
      if rem(index + 1, x) == 0 and Bitwise.band(n, Bitwise.bsl(1, index)) != 0 do
        acc + 1
      else
        acc
      end
    end)
  end

  defp bit_size(n) do
    :math.log2(n |> Kernel.abs() |> Kernel.max(1)) |> Float.ceil() |> Kernel.trunc()
  end
end"
elixir,compile_error,"Line 6: Char 35: ** (SyntaxError) syntax error before: 'div'
    |
  6 |     removal_count = length(nums1) div 2
    |                                   ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\maximum-size-of-a-set-after-removals\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_set_size(nums1 :: [integer], nums2 :: [integer]) :: integer
  def maximum_set_size(nums1, nums2) do
    combined = nums1 ++ nums2
    combined_freq = Enum.frequencies(combined)
    removal_count = length(nums1) div 2

    combined_freq
    |> Enum.map(fn {_num, freq} -> div(freq, 2) end)
    |> Enum.sum()
    |> (&(&1 - removal_count)).()
    |> Kernel.max(0)
    |> (&(length(Map.keys(combined_freq)) + &1)).()
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe nums into Enum.at(i) - nums, the :- operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 7:     Solution.maximum_triplet_value/1
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 7:     Solution.maximum_triplet_value/1
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 7:     Solution.maximum_triplet_value/1",../questions/Medium\maximum-value-of-an-ordered-triplet-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec maximum_triplet_value(nums :: [integer]) :: integer
  def maximum_triplet_value(nums) do
    Enum.reduce(0..length(nums)-3, 0, fn i, acc1 ->
      Enum.reduce(i+1..length(nums)-2, acc1, fn j, acc2 ->
        Enum.reduce(j+1..length(nums)-1, acc2, fn k, acc3 ->
          max_value = (nums |> Enum.at(i) - nums |> Enum.at(j)) * nums |> Enum.at(k)
          if max_value > acc3, do: max_value, else: acc3
        end)
      end)
    end)
    |> max(0)
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe :math.pow(2, n) into trunc() - 1, the :- operator can only take one argument
    (elixir 1.15.7) lib/macro.ex:371: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 4:     Solution.maximum_xor_product/3",../questions/Medium\maximum-xor-product\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_xor_product(a :: integer, b :: integer, n :: integer) :: integer
  def maximum_xor_product(a, b, n) do
    max_x = :math.pow(2, n) |> trunc() - 1
    0..max_x
    |> Enum.map(fn x -> rem((a |> Bitwise.bxor(x)) * (b |> Bitwise.bxor(x)), 1_000_000_007) end)
    |> Enum.max()
  end
end"
elixir,compile_error,"error: undefined function <<</2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 5:   Solution.maximum_xor_product/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\maximum-xor-product\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_xor_product(a :: integer, b :: integer, n :: integer) :: integer
  def maximum_xor_product(a, b, n) do
    mod = 1_000_000_007
    x = (1 <<< n) - 1
    rem(((a |> Bitwise.bxor(x)) * (b |> Bitwise.bxor(x))), mod)
  end
end"
elixir,compile_error,"Line 20: Char 42: ** (SyntaxError) syntax error before: '_'
    |
 20 |     |> (fn diff -> case diff do nil -> 0 _ -> diff end end).()
    |                                          ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-absolute-difference-between-elements-with-constraint\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_absolute_difference(nums :: [integer], x :: integer) :: integer
  def min_absolute_difference(nums, x) do
    nums
    |> Enum.with_index()
    |> Enum.sort_by(fn {num, _index} -> num end)
    |> Enum.reduce({nil, nil, nil}, fn ({num, index}, {min_diff, prev_num, prev_index}) ->
      cond do
        prev_index != nil and abs(prev_index - index) >= x ->
          new_diff = abs(prev_num - num)
          case min_diff do
            nil -> {new_diff, num, index}
            _ -> {min(new_diff, min_diff), num, index}
          end
        true ->
          {min_diff, num, index}
      end
    end)
    |> elem(0)
    |> (fn diff -> case diff do nil -> 0 _ -> diff end end).()
  end
end"
elixir,compile_error,"warning: variable ""changed"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 3:   Solution.minimum_cost/5
error: undefined function return/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 21:   Solution.minimum_cost/5
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\minimum-cost-to-convert-string-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_cost(source :: String.t, target :: String.t, original :: [char], changed :: [char], cost :: [integer]) :: integer
  def minimum_cost(source, target, original, changed, cost) do
    source
    |> String.to_charlist()
    |> Enum.with_index()
    |> Enum.reduce(0, fn {source_char, idx}, acc ->
      target_char = String.at(target, idx) |> String.to_charlist() |> hd()

      if source_char == target_char do
        acc
      else
        change_cost = 
          Enum.with_index(original)
          |> Enum.filter(fn {{o, _}, _} -> o == source_char end)
          |> Enum.map(fn {{_, c}, i} -> {c, cost |> Enum.at(i)} end)
          |> Enum.filter(fn {c, _} -> c == target_char end)
          |> Enum.map(fn {_, c} -> c end)
          |> Enum.min()

        if is_nil(change_cost), do: return(-1), else: acc + change_cost
      end
    end)
  end
end"
elixir,compile_error,"Line 13: Char 69: ** (SyntaxError) syntax error before: 'div'
    |
 13 |       (Enum.at(sorted, len div 2 - 1) + Enum.at(sorted, len div 2)) div 2
    |                                                                     ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-cost-to-make-array-equalindromic\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_cost(nums :: [integer]) :: integer
  def minimum_cost(nums) do
    median = find_median(nums)
    Enum.reduce(nums, 0, fn x, acc -> acc + abs(x - median) end)
  end

  defp find_median(list) do
    sorted = Enum.sort(list)
    len = length(list)

    if rem(len, 2) == 0 do
      (Enum.at(sorted, len div 2 - 1) + Enum.at(sorted, len div 2)) div 2
    else
      Enum.at(sorted, len div 2)
    end
  end
end"
elixir,compile_error,"warning: variable ""added_coins"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 11:   Solution.minimum_added_coins/2
warning: variable ""current_sum"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 14:   Solution.minimum_added_coins/2
warning: variable ""current_sum"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 18:   Solution.minimum_added_coins/2
error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 9:   Solution.minimum_added_coins/2
error: undefined function break/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 13:   Solution.minimum_added_coins/2
error: undefined function if/1 (expected Solution to define such a function or for it to be imported, but none are available)
Line 13:   Solution.minimum_added_coins/2
error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 17:   Solution.minimum_added_coins/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\minimum-number-of-coins-to-be-added\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_added_coins(coins :: [integer], target :: integer) :: integer
  def minimum_added_coins(coins, target) do
    coins = Enum.sort(coins)
    current_sum = 0
    added_coins = 0

    for coin <- coins do
      while current_sum < target and current_sum + 1 < coin do
        current_sum = current_sum * 2 + 1
        added_coins = added_coins + 1
      end
      break if current_sum >= target
      current_sum = current_sum + coin
    end

    while current_sum < target do
      current_sum = current_sum * 2 + 1
      added_coins = added_coins + 1
    end

    added_coins
  end
end"
elixir,compile_error,"error: the function ""if"" cannot handle clauses with the -> operator because it is not a macro. Please make sure you are invoking the proper name and that it is a macro
Line 9:   Solution.minimum_added_coins/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) src/elixir_fn.erl:17: anonymous fn/4 in :elixir_fn.expand/4
    (stdlib 5.1.1) lists.erl:1706: :lists.mapfoldl_1/3
    (elixir 1.15.7) src/elixir_fn.erl:23: :elixir_fn.expand/4",../questions/Medium\minimum-number-of-coins-to-be-added\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_added_coins(coins :: [integer], target :: integer) :: integer
  def minimum_added_coins(coins, target) do
    coins = Enum.sort(coins)
    added_coins = 0
    current = 1

    Enum.reduce_while(coins, 0, fn coin, acc ->
      if acc >= target, do: {:halt, added_coins}, else: {:cont, acc}
      |> case do
        {:halt, _} -> {:halt, added_coins}
        _ ->
          while acc < coin and acc < target do
            added_coins = added_coins + 1
            acc = acc + current
            current = acc + 1
          end
          if acc >= target, do: {:halt, added_coins}, else: {:cont, acc + coin}
      end
    end)

    while current <= target do
      added_coins = added_coins + 1
      current = current * 2
    end

    added_coins
  end

  defp while(condition, do: block) do
    if condition, do: [block |> block.(), while(condition, do: block)], else: []
  end
end"
elixir,compile_error,"Line 8: Char 55: ** (SyntaxError) syntax error before: ')'
    |
  8 |     |> Enum.reduce({0, 0}, fn x, (max_groups, prev_max) ->
    |                                                       ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-number-of-groups-to-create-a-valid-assignment\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_groups_for_valid_assignment(nums :: [integer]) :: integer
  def min_groups_for_valid_assignment(nums) do
    nums
    |> Enum.frequencies()
    |> Map.values()
    |> Enum.sort()
    |> Enum.reduce({0, 0}, fn x, (max_groups, prev_max) ->
      new_max = max(prev_max + 1, x)
      {max(max_groups, new_max), new_max}
    end)
    |> elem(0)
  end
end"
elixir,compile_error,"warning: missing parentheses for expression following ""do:"" keyword. Parentheses are required to solve ambiguity inside keywords.
This error happens when you have function calls without parentheses inside keywords. For example:
    function(arg, one: nested_call a, b, c)
    function(arg, one: if expr, do: :this, else: :that)
In the examples above, we don't know if the arguments ""b"" and ""c"" apply to the function ""function"" or ""nested_call"". Or if the keywords ""do"" and ""else"" apply to the function ""function"" or ""if"". You can solve this by explicitly adding parentheses:
    function(arg, one: if(expr, do: :this, else: :that))
    function(arg, one: nested_call(a, b, c))
Ambiguity found at:
  solution.ex:18
Line 18: ** (SyntaxError) unexpected comma. Parentheses are required to solve ambiguity inside containers.
This error may happen when you forget a comma in a list or other container:
    [a, b c, d]
Or when you have ambiguous calls:
    [function a, b, c]
In the example above, we don't know if the values ""b"" and ""c"" belongs to the list or the function ""function"". You can solve this by explicitly adding parentheses:
    [one, function(a, b, c)]
Elixir cannot compile otherwise. Syntax error before: ','
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-number-of-operations-to-make-x-and-y-equal\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_operations_to_make_equal(x :: integer, y :: integer) :: integer
  def minimum_operations_to_make_equal(x, y) do
    explore(x, y, Map.new(), 0)
  end

  defp explore(x, y, visited, steps) when x == y, do: steps

  defp explore(x, y, visited, steps) do
    if Map.has_key?(visited, {x, y}) do
      :infinity
    else
      visited = Map.put(visited, {x, y}, true)

      ops = [
        {:inc, x + 1},
        {:dec, x - 1},
        {:div5, if rem(x, 5) == 0, do: x div 5, else: nil},
        {:div11, if rem(x, 11) == 0, do: x div 11, else: nil}
      ]
      |> Enum.filter(fn {_op, val} -> not is_nil(val) end)
      |> Enum.map(fn {_op, val} -> explore(val, y, visited, steps + 1) end)

      case ops do
        [] -> :infinity
        _ -> Enum.min(ops)
      end
    end
  end
end"
elixir,compile_error,"Line 53: Char 1: ** (TokenMissingError) missing terminator: end (for ""do"" starting at line 18)
    HINT: it looks like the ""do"" on line 18 does not have a matching ""end""
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-operations-to-make-the-integer-zero\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec make_the_integer_zero(num1 :: integer, num2 :: integer) :: integer
  def make_the_integer_zero(num1, num2) do
    operations(0, num1, num2)
  end

  defp operations(61, _, _), do: -1
  defp operations(count, 0, _), do: count
  defp operations(count, num1, num2) do
    with {:ok, i} <- find_i(num1, num2),
         new_num1 <- num1 - (2 |> :math.pow(i) |> round + num2) do
      operations(count + 1, new_num1, num2)
    else
      _ -> -1
    end
  end

  defp find_i(num1, num2) do
    Enum.reduce_while"
elixir,compile_error,"Line 14: Char 66: ** (SyntaxError) unexpected reserved word: end
    HINT: the ""{"" on line 14 is missing terminator ""}""
    |
 14 |       |> Enum.filter(fn {({a, b}, _i) -> a != max1 and b != max2 end)
    |                                                                  ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-operations-to-maximize-last-elements-in-arrays\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_operations(nums1 :: [integer], nums2 :: [integer]) :: integer
  def min_operations(nums1, nums2) do
    max1 = Enum.max(nums1)
    max2 = Enum.max(nums2)

    if max1 == nums1 |> Enum.at(-1) and max2 == nums2 |> Enum.at(-1), do: 0, else: count_swaps(nums1, nums2, max1, max2)
  end

  defp count_swaps(nums1, nums2, max1, max2) do
    swaps =
      Enum.zip(nums1, nums2)
      |> Enum.with_index()
      |> Enum.filter(fn {({a, b}, _i) -> a != max1 and b != max2 end)
      |> Enum.map(fn {({a, b}, i) -> {Enum.abs(max1 - a) + Enum.abs(max2 - b), i} end)
      |> Enum.sort()
      |> Enum.reduce_while({0, max1, max2}, fn {dist, i}, {acc, cur_max1, cur_max2} ->
        if cur_max1 == nums1 |> Enum.at(-1) and cur_max2 == nums2 |> Enum.at(-1), do: {:halt, acc},
        else
          {new_max1, new_max2} = swap_elements(nums1, nums2, i)
          if new_max1 == nums1 |> Enum.at(-1) and new_max2 == nums2 |> Enum.at(-1), do: {:halt, acc + 1},
          else {:cont, {acc + 1, new_max1, new_max2}}
        end
      end)

    case swaps do
      {:halt, acc} -> acc
      _ -> -1
    end
  end

  defp swap_elements(nums1, nums2, i) do
    {List.update_at(nums1, i, &Enum.at(nums2, i)), List.update_at(nums2, i, &Enum.at(nums1, i))}
    |> Tuple.to_list()
    |> then(fn [new_nums1, new_nums2] -> {Enum.max(new_nums1), Enum.max(new_nums2)} end)
  end
end"
elixir,compile_error,"Line 20: Char 76: ** (SyntaxError) unexpected reserved word: end
    HINT: the ""{"" on line 20 is missing terminator ""}""
    |
 20 |           |> Enum.filter(fn {({a, b}, _i) -> not (a == max1 and b == max2) end)
    |                                                                            ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-operations-to-maximize-last-elements-in-arrays\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec min_operations(nums1 :: [integer], nums2 :: [integer]) :: integer
  def min_operations(nums1, nums2) do
    max1 = Enum.max(nums1)
    max2 = Enum.max(nums2)

    if max1 == List.last(nums1) and max2 == List.last(nums2), do: 0, else: count_swaps(nums1, nums2, max1, max2)
  end

  defp count_swaps(nums1, nums2, max1, max2) do
    nums1_end = List.last(nums1)
    nums2_end = List.last(nums2)

    cond do
      max1 == nums1_end and max2 == nums2_end -> 0
      true ->
        swaps = 
          Enum.zip(nums1, nums2)
          |> Enum.with_index()
          |> Enum.filter(fn {({a, b}, _i) -> not (a == max1 and b == max2) end)
          |> Enum.count(fn {({a, b}, _i) -> a == max2 and b == max1 end)

        if Enum.any?(nums1, fn x -> x == max2 end) and Enum.any?(nums2, fn x -> x == max1 end), do: swaps, else: -1
    end
  end
end"
elixir,compile_error,"** (ArgumentError) cannot pipe nums
|> Enum.with_index()
|> Enum.group_by(fn {num, _} -> num end, fn {_, index} -> index end)
|> Enum.map(fn {_, indexes} -> max_distance(indexes, Enum.count(nums)) end)
|> Enum.max()
|> Kernel.+(1) into Kernel./() / 2, the :/ operator can only take two arguments
    (elixir 1.15.7) lib/macro.ex:376: Macro.pipe/3
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 10:     Solution.minimum_seconds/1",../questions/Medium\minimum-seconds-to-equalize-a-circular-array\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_seconds(nums :: [integer]) :: integer
  def minimum_seconds(nums) do
    nums
    |> Enum.with_index()
    |> Enum.group_by(fn {num, _} -> num end, fn {_, index} -> index end)
    |> Enum.map(fn {_, indexes} -> max_distance(indexes, Enum.count(nums)) end)
    |> Enum.max()
    |> Kernel.+(1)
    |> Kernel.//2
  end

  defp max_distance(indexes, count) do
    indexes
    |> Enum.sort()
    |> Enum.concat([List.first(indexes) + count])
    |> Enum.chunk_every(2, 1, :discard)
    |> Enum.map(fn [a, b] -> b - a end)
    |> Enum.max()
    |> Kernel.-(1)
  end
end"
elixir,compile_error,"warning: variable ""min_length"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 24:   Solution.min_size_subarray/2
warning: variable ""start"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 26:   Solution.min_size_subarray/2
warning: variable ""sum"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 25:   Solution.min_size_subarray/2
error: undefined function while/2 (expected Solution to define such a function or for it to be imported, but none are available)
Line 23:   Solution.min_size_subarray/2
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\minimum-size-subarray-in-infinite-array\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec min_size_subarray(nums :: [integer], target :: integer) :: integer
  def min_size_subarray(nums, target) do
    min_length = :infinity
    total_sum = Enum.sum(nums)
    n = length(nums)

    cond do
      total_sum < target ->
        -1

      total_sum == target ->
        n

      true ->
        extended_nums = nums ++ nums
        start = 0
        sum = 0

        for {num, index} <- Enum.with_index(extended_nums) do
          sum = sum + num

          while sum >= target do
            min_length = Enum.min([min_length, index - start + 1])
            sum = sum - Enum.at(extended_nums, start)
            start = start + 1
          end
        end

        if min_length == :infinity, do: -1, else: min_length
    end
  end
end"
elixir,compile_error,"Line 6: Char 32: ** (SyntaxError) syntax error before: 'div'
    |
  6 |     if min_len <= length(nums) div 2, do: min_len, else: -1
    |                                ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\minimum-size-subarray-in-infinite-array\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec min_size_subarray(nums :: [integer], target :: integer) :: integer
  def min_size_subarray(nums, target) do
    nums = nums ++ nums
    min_len = ref_min_length(nums, target)
    if min_len <= length(nums) div 2, do: min_len, else: -1
  end

  defp ref_min_length(nums, target) do
    sum = 0
    start = 0
    min_len = length(nums) + 1

    for {num, i} <- Enum.with_index(nums), reduce: min_len do
      min_len ->
        sum = sum + num
        while sum >= target and start <= i do
          min_len = Enum.min([min_len, i - start + 1])
          sum = sum - Enum.at(nums, start)
          start = start + 1
        end
        min_len
    end
  end

  defp while(true, do: block), do: block.()
  defp while(false, do: _block), do: nil
end"
elixir,compile_error,"Line 22: ** (SyntaxError) unexpected comma. Parentheses are required to solve ambiguity in nested calls.
This error happens when you have nested function calls without parentheses. For example:
    parent_call a, nested_call b, c, d
In the example above, we don't know if the parameters ""c"" and ""d"" apply to the function ""parent_call"" or ""nested_call"". You can solve this by explicitly adding parentheses:
    parent_call a, nested_call(b, c, d)
Or by adding commas (in case a nested call is not intended):
    parent_call a, nested_call, b, c, d
Elixir cannot compile otherwise. Syntax error before: ','
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\partition-string-into-minimum-beautiful-substrings\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_beautiful_substrings(s :: String.t) :: integer
  def minimum_beautiful_substrings(s) do
    memo = :maps.from_list(Enum.map(0..15, fn i -> {i, -1} end))
    dp(0, s, memo)
  end

  defp dp(pos, s, memo) when pos == String.length(s), do: 0
  defp dp(pos, s, memo) do
    case :maps.get(pos, memo) do
      -1 ->
        len = String.length(s)
        min = Enum.reduce(1..(len-pos), {:infinity, memo}, fn i, {min, memo} ->
          substring = String.slice(s, pos, i)
          if valid_and_power_of_5?(substring) do
            {next_min, next_memo} = dp(pos + i, s, memo)
            if next_min != -1, do: {Enum.min([min, 1 + next_min]), next_memo}, else: {min, memo}
          else
            {min, memo}
          end
        end)
        memo = Map.put(min |> elem(1), pos, if min |> elem(0) == :infinity, do: -1, else: min |> elem(0))
        memo |> Map.get(pos)
      min -> min
    end
  end

  defp valid_and_power_of_5?(s) do
    case s do
      ""0"" -> false
      _ -> 
        num = String.to_integer(s, 2)
        is_power_of_5?(num)
    end
  end

  defp is_power_of_5?(1), do: true
  defp is_power_of_5?(n) when n <= 0 or rem(n, 5) != 0, do: false
  defp is_power_of_5?(n), do: is_power_of_5?(div(n, 5))
end"
elixir,compile_error,"Line 22: ** (SyntaxError) unexpected comma. Parentheses are required to solve ambiguity in nested calls.
This error happens when you have nested function calls without parentheses. For example:
    parent_call a, nested_call b, c, d
In the example above, we don't know if the parameters ""c"" and ""d"" apply to the function ""parent_call"" or ""nested_call"". You can solve this by explicitly adding parentheses:
    parent_call a, nested_call(b, c, d)
Or by adding commas (in case a nested call is not intended):
    parent_call a, nested_call, b, c, d
Elixir cannot compile otherwise. Syntax error before: ','
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\partition-string-into-minimum-beautiful-substrings\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_beautiful_substrings(s :: String.t) :: integer
  def minimum_beautiful_substrings(s) do
    memo = :maps.from_list(Enum.map(0..15, fn i -> {i, -1} end))
    dp(0, s, memo)
  end

  defp dp(pos, s, memo) when pos == String.length(s), do: 0
  defp dp(pos, s, memo) do
    case :maps.get(pos, memo) do
      -1 ->
        len = String.length(s)
        min = Enum.reduce(1..(len-pos), {:infinity, memo}, fn i, {min, memo} ->
          substring = String.slice(s, pos, i)
          if valid_and_power_of_5?(substring) do
            {next_min, next_memo} = dp(pos + i, s, memo)
            if next_min != -1, do: {Enum.min([min, 1 + next_min]), next_memo}, else: {min, memo}
          else
            {min, memo}
          end
        end)
        memo = Map.put(min |> elem(1), pos, if (min |> elem(0)) == :infinity, do: -1, else: (min |> elem(0)))
        memo |> Map.get(pos)
      min -> min
    end
  end

  defp valid_and_power_of_5?(s) do
    case s do
      ""0"" -> false
      _ -> 
        num = String.to_integer(s, 2)
        is_power_of_5?(num)
    end
  end

  defp is_power_of_5?(1), do: true
  defp is_power_of_5?(n) when n <= 0 or rem(n, 5) != 0, do: false
  defp is_power_of_5?(n), do: is_power_of_5?(div(n, 5))
end"
elixir,compile_error,"error: cannot invoke remote function String.length/1 inside guards
Line 8:   Solution.dp/3
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\partition-string-into-minimum-beautiful-substrings\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_beautiful_substrings(s :: String.t) :: integer
  def minimum_beautiful_substrings(s) do
    memo = :maps.from_list(Enum.map(0..String.length(s) - 1, &{&1, -1}))
    dp(s, 0, Map.put(memo, String.length(s), 0))
  end

  defp dp(_, pos, memo) when pos == String.length(memo) - 1, do: Map.get(memo, pos)
  defp dp(s, pos, memo) do
    case Map.get(memo, pos) do
      -1 ->
        len = String.length(s)
        {min, new_memo} =
          Enum.reduce_while(1..(len - pos), {nil, memo}, fn i, {min, memo_acc} ->
            substring = String.slice(s, pos, i)
            if valid_and_power_of_5?(substring) do
              next_pos = pos + i
              next_min = dp(s, next_pos, memo_acc)
              cond do
                next_min == -1 -> {:cont, {min, memo_acc}}
                min == nil or next_min + 1 < min -> {:cont, {next_min + 1, Map.put(memo_acc, pos, next_min + 1)}}
                true -> {:cont, {min, memo_acc}}
              end
            else
              {:cont, {min, memo_acc}}
            end
          end)

        case min do
          nil -> Map.put(new_memo, pos, -1)
          _ -> new_memo
        end

      min -> memo
    end
    |> Map.get(pos)
  end

  defp valid_and_power_of_5?(s) do
    with false <- String.starts_with?(s, ""0""),
         {:ok, num} <- Integer.parse(s, 2),
         true <- is_power_of_5?(num) do
      true
    else
      _ -> false
    end
  end

  defp is_power_of_5?(1), do: true
  defp is_power_of_5?(n) when n > 1 and rem(n, 5) == 0, do: is_power_of_5?(div(n, 5))
  defp is_power_of_5?(_), do: false
end"
elixir,compile_error,"error: cannot find or invoke local prev_char/1 inside guards. Only macros can be invoked in a guards and they must be defined before their invocation. Called as: prev_char(x)
Line 10:   Solution.remove_almost_equal_characters/1
error: cannot find or invoke local next_char/1 inside guards. Only macros can be invoked in a guards and they must be defined before their invocation. Called as: next_char(x)
Line 10:   Solution.remove_almost_equal_characters/1
warning: function prev_char/1 is unused
Line 17:   Solution (module)
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\remove-adjacent-almost-equal-characters\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec remove_almost_equal_characters(word :: String.t) :: integer
  def remove_almost_equal_characters(word) do
    word
    |> String.codepoints()
    |> Enum.reduce({0, nil}, fn x, {acc, prev} -> 
      case prev do
        nil -> {acc, x}
        ^x -> {acc + 1, next_char(x)}
        prev when prev in [prev_char(x), next_char(x)] -> {acc + 1, next_char(next_char(x))}
        _ -> {acc, x}
      end
    end)
    |> elem(0)
  end

  defp prev_char(char) do
    [code] = char |> String.to_charlist()
    if code > 97, do: <<code - 1 :: utf8>>, else: <<122 :: utf8>>
  end

  defp next_char(char) do
    [code] = char |> String.to_charlist()
    if code < 122, do: <<code + 1 :: utf8>>, else: <<97 :: utf8>>
  end
end"
elixir,compile_error,"error: cannot invoke remote function String.contains?/2 inside guards
Line 8:   Solution.sort_vowels/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) src/elixir_fn.erl:17: anonymous fn/4 in :elixir_fn.expand/4
    (stdlib 5.1.1) lists.erl:1706: :lists.mapfoldl_1/3",../questions/Medium\sort-vowels-in-a-string\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec sort_vowels(s :: String.t) :: String.t
  def sort_vowels(s) do
    vowels = Enum.filter(s, &String.contains?(""aeiouAEIOU"", &1))
    sorted_vowels = Enum.sort_by(vowels, &(&1))

    Enum.map_join(s, """", fn
      <<char>> when String.contains?(""aeiouAEIOU"", <<char>>) ->
        {vowel, _} = Enum.split(sorted_vowels, 1)
        hd(vowel)
      char ->
        char
    end)
  end
end"
elixir,compile_error,"error: cannot invoke remote function String.contains?/2 inside guards
Line 9:   Solution.sort_vowels/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) expanding macro: Kernel.|>/2
Line 9:     Solution.sort_vowels/1",../questions/Medium\sort-vowels-in-a-string\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec sort_vowels(s :: String.t) :: String.t
  def sort_vowels(s) do
    vowels = Enum.filter(s, fn x -> ""aeiouAEIOU"" |> String.contains?(<<x>>) end)
    sorted_vowels = Enum.sort_by(vowels, &(&1))
    vowels_idx = Stream.with_index(vowels) |> Enum.into(%{})

    Enum.map_join(s, """", fn
      <<char>> = c when ""aeiouAEIOU"" |> String.contains?(c) ->
        {vowel, _rest} = List.pop_at(sorted_vowels, Map.fetch!(vowels_idx, {char, 0}))
        vowels_idx = Map.update!(vowels_idx, {char, 0}, &(&1 + 1))
        vowel
      char ->
        char
    end)
  end
end"
elixir,compile_error,"error: undefined variable ""vowel""
Line 10:   Solution.sort_vowels/1
error: undefined variable ""tail""
Line 10:   Solution.sort_vowels/1
error: undefined variable ""vowel""
Line 10:   Solution.sort_vowels/1
warning: variable ""vowels"" is unused (there is a variable with the same name in the context, use the pin operator (^) to match on it or prefix this variable with underscore if it is not meant to be used)
Line 9:   Solution.sort_vowels/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)",../questions/Medium\sort-vowels-in-a-string\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec sort_vowels(s :: String.t) :: String.t
  def sort_vowels(s) do
    vowels = String.graphemes(s)
             |> Enum.filter(&(&1 in [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""]))
    sorted_vowels = Enum.sort(vowels)

    Enum.reduce(String.graphemes(s), {sorted_vowels, """"}, fn
      char, {vowels, acc} when char in [""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", ""I"", ""O"", ""U""] ->
        {[vowel | tail], acc <> vowel}
      char, {vowels, acc} ->
        {vowels, acc <> char}
    end)
    |> elem(1)
  end
end"
elixir,compile_error,"error: nested captures are not allowed. You cannot define a function using  the capture operator & inside another function defined via &. Got invalid nested capture: &(&1 == &2)
Line 4:   Solution.minimum_operations/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (stdlib 5.1.1) lists.erl:1706: :lists.mapfoldl_1/3
    (stdlib 5.1.1) lists.erl:1707: :lists.mapfoldl_1/3
    (elixir 1.15.7) src/elixir_fn.erl:140: :elixir_fn.escape/3
    (elixir 1.15.7) src/elixir_fn.erl:112: :elixir_fn.capture_expr/6",../questions/Medium\sorting-three-groups\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_operations(nums :: [integer]) :: integer
  def minimum_operations(nums) do
    groups = Enum.group_by(nums, &(&1), &Enum.count(nums, &(&1 == &2)))
    counts = Enum.map(1..3, fn x -> Map.get(groups, x, []) |> length end)
    total = Enum.sum(counts)
    max_seq = Enum.max(counts)

    total - max_seq
  end
end"
elixir,compile_error,"error: nested captures are not allowed. You cannot define a function using  the capture operator & inside another function defined via &. Got invalid nested capture: & &1
Line 5:   Solution.minimum_operations/1
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (stdlib 5.1.1) lists.erl:1706: :lists.mapfoldl_1/3
    (stdlib 5.1.1) lists.erl:1707: :lists.mapfoldl_1/3
    (elixir 1.15.7) src/elixir_fn.erl:140: :elixir_fn.escape/3
    (elixir 1.15.7) src/elixir_fn.erl:112: :elixir_fn.capture_expr/6",../questions/Medium\sorting-three-groups\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_operations(nums :: [integer]) :: integer
  def minimum_operations(nums) do
    groups = for x <- 1..3, do: Enum.filter(nums, fn y -> y == x end)
    sorted_groups = Enum.map(groups, &Enum.sort_by(&1, &(&1)))
    len = Enum.count(nums)
    max_correct = 0

    for i <- 0..(len-1) do
      correct = 0
      for {group, index} <- Enum.with_index(sorted_groups) do
        correct = correct + Enum.count(group, fn x -> x == i end)
        if correct < index+1, do: break, else: max_correct = max(max_correct, correct)
      end
    end

    len - max_correct
  end
end"
elixir,compile_error,"Line 28: Char 39: ** (SyntaxError) unexpectedly reached end of line. The current expression is invalid or incomplete
    |
 28 |     h % next_h == 0 or next_h % h == 0
    |                                       ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\special-permutations\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @mod 1_000_000_007

  @spec special_perm(nums :: [integer]) :: integer
  def special_perm(nums) do
    nums
    |> Enum.sort()
    |> permute([], length(nums), Map.new(), 0)
    |> rem(@mod)
  end

  defp permute([], _len, _dp, count), do: count

  defp permute([h | t], len, dp, count) do
    new_count = Enum.reduce(0..len-1, count, fn i, acc ->
      if Map.get(dp, {i, h}) != nil or can_place?(i, h, t) do
        acc + permute(t -- [h], len, Map.put(dp, {i, h}, true), 1)
      else
        acc
      end
    end)
    permute(t, len, dp, new_count)
  end

  defp can_place?(_i, _h, []), do: true

  defp can_place?(i, h, [next_h | _t]) when i == 0 do
    h % next_h == 0 or next_h % h == 0
  end

  defp can_place?(_i, _h, _), do: false
end"
elixir,compile_error,"Line 26: Char 26: ** (SyntaxError) unexpected token: ]
    HINT: the ""("" on line 26 is missing terminator "")""
    |
 26 |           (sorted_nums|i|] % sorted_nums|index - 1|] == 0 or sorted_nums|index - 1|] % sorted_nums|i|] == 0) do
    |                          ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\special-permutations\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @mod 1_000_000_007

  @spec special_perm(nums :: [integer]) :: integer
  def special_perm(nums) do
    nums
    |> Enum.sort()
    |> count_special_permutations(Map.new(), length(nums))
  end

  defp count_special_permutations(sorted_nums, len) do
    count_special_permutations(sorted_nums, len, 0, 0, Map.new())
  end

  defp count_special_permutations(_sorted_nums, _len, _index, count, _dp) when _index == _len do
    count
  end

  defp count_special_permutations(sorted_nums, len, index, count, dp) do
    Enum.reduce(0..len-1, count, fn i, acc ->
      if Map.get(dp, {index, i}) do
        acc
      else
        new_dp = Map.put(dp, {index, i}, true)
        if index == 0 or 
          (sorted_nums|i|] % sorted_nums|index - 1|] == 0 or sorted_nums|index - 1|] % sorted_nums|i|] == 0) do
          acc + count_special_permutations(sorted_nums, len, index + 1, 1, new_dp)
        else
          acc
        end
      end
    end)
  end
end"
elixir,compile_error,"Line 35: Char 50: ** (SyntaxError) unexpectedly reached end of line. The current expression is invalid or incomplete
    |
 35 |         num % x == 0 or x % num == 0 or dp_x == 1
    |                                                  ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\special-permutations\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @mod 1_000_000_007

  @spec special_perm(nums :: [integer]) :: integer
  def special_perm(nums) do
    len = length(nums)
    nums = Enum.sort(nums)
    dp = :maps.from_list(for x <- nums, do: {x, 0})
    special_perm_helper(nums, dp, len, 0, 1)
  end

  defp special_perm_helper(_nums, _dp, 0, _mask, _res), do: _res
  defp special_perm_helper(nums, dp, len, mask, res) do
    Enum.reduce_while(nums, res, fn num, acc ->
      if (mask &&& (1 <<< Enum.find_index(nums, &(&1 == num)))) == 0 do
        new_mask = mask ||| (1 <<< Enum.find_index(nums, &(&1 == num)))
        if valid_perm?(nums, dp, num, mask) do
          new_res = special_perm_helper(nums, dp, len - 1, new_mask, acc + 1)
          {:cont, new_res}
        else
          {:cont, acc}
        end
      else
        {:cont, acc}
      end
    end) |> rem(@mod)
  end

  defp valid_perm?(_nums, _dp, _num, 0), do: true
  defp valid_perm?(nums, dp, num, mask) do
    Enum.any?(nums, fn x ->
      x_mask = 1 <<< Enum.find_index(nums, &(&1 == x))
      if (mask &&& x_mask) != 0 do
        dp_x = Map.get(dp, x)
        num % x == 0 or x % num == 0 or dp_x == 1
      else
        false
      end
    end)
  end
end"
elixir,compile_error,"warning: variable ""current_score"" is unused (if the variable is not meant to be used, prefix it with an underscore)
Line 7:   Solution.max_score_helper/6
error: cannot invoke remote function MapSet.member?/2 inside guards
Line 9:   Solution.max_score_helper/6
** (CompileError) solution.ex: cannot compile module Solution (errors have been logged)
    (elixir 1.15.7) expanding macro: Kernel.and/2
Line 9:     Solution.max_score_helper/6",../questions/Medium\visit-array-positions-to-maximize-score\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec max_score(nums :: [integer], x :: integer) :: integer
  def max_score(nums, x) do
    max_score_helper(nums, x, 0, MapSet.new(), 0, nums |> hd())
  end

  defp max_score_helper(_nums, _x, _index, _visited, max_score, current_score), do: max_score

  defp max_score_helper(nums, x, index, visited, max_score, current_score) when index < length(nums) and not MapSet.member?(visited, index) do
    new_visited = MapSet.put(visited, index)
    new_score = if index > 0 and rem(Enum.at(nums, index - 1), 2) != rem(Enum.at(nums, index), 2), do: current_score - x, else: current_score
    new_max_score = max(max_score, new_score + Enum.at(nums, index))
    Enum.reduce(index+1..length(nums)-1, new_max_score, fn i, acc ->
      max_score_helper(nums, x, i, new_visited, acc, new_score + Enum.at(nums, i))
    end)
  end

  defp max_score_helper(_nums, _x, _index, _visited, max_score, _current_score), do: max_score
end"
elixir,compile_error,"Line 13: Char 84: ** (SyntaxError) syntax error before: mod
    |
 13 |           dp = :array.set(dp, j, (:array.get(dp, j) + :array.get(dp, j - max_val)) mod @mod)
    |                                                                                    ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\ways-to-express-an-integer-as-sum-of-powers\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @mod 1000000007

  @spec number_of_ways(n :: integer, x :: integer) :: integer
  def number_of_ways(n, x) do
    dp = :array.new(n + 1, default_value: 0)
    dp = :array.set(dp, 0, 1)

    for i <- 1..n do
      max_val = :math.pow(i, x) |> round()
      if max_val <= n do
        for j <- n..max_val, -1 do
          dp = :array.set(dp, j, (:array.get(dp, j) + :array.get(dp, j - max_val)) mod @mod)
        end
      end
    end

    :array.get(dp, n)
  end
end"
elixir,compile_error,"Line 14: Char 69: ** (SyntaxError) syntax error before: mod
    |
 14 |         updated_value = (:array.get(dp, j - i) + :array.get(dp, j)) mod @mod
    |                                                                     ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\ways-to-express-an-integer-as-sum-of-powers\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @mod 1000000007

  @spec number_of_ways(n :: integer, x :: integer) :: integer
  def number_of_ways(n, x) do
    dp = :array.new(n + 1, default_value: 0)
    dp = :array.set(dp, 0, 1)

    1..n
    |> Enum.map(&(:math.pow(&1, x) |> round()))
    |> Enum.filter(&(n >= &1))
    |> Enum.each(fn i ->
      for j <- i..n do
        updated_value = (:array.get(dp, j - i) + :array.get(dp, j)) mod @mod
        dp = :array.set(dp, j, updated_value)
      end
    end)

    :array.get(dp, n)
  end
end"
elixir,compile_error,"Line 6: Char 73: ** (SyntaxError) syntax error before: 'rem'
    |
  6 |       0, {1, ways, total_ways} -> {1, ways + 1, (total_ways + ways + 1) rem 1_000_000_007}
    |                                                                         ^
    (elixir 1.15.7) lib/kernel/parallel_compiler.ex:377: anonymous fn/5 in Kernel.ParallelCompiler.spawn_workers/8",../questions/Medium\ways-to-split-array-into-good-subarrays\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec number_of_good_subarray_splits(nums :: [integer]) :: integer do
    nums
    |> Enum.reduce({0, 0, 0}, fn
      1, {_ones_before, _ways, _total_ways} -> {1, 0, _total_ways}
      0, {1, ways, total_ways} -> {1, ways + 1, (total_ways + ways + 1) rem 1_000_000_007}
      _, acc -> acc
    end)
    |> elem(2)
  end
end"
elixir,compile_error,"error: spec for undefined function number_of_good_subarray_splits/1
  solution.ex:2
** (CompileError) solution.ex: cannot compile file (errors have been logged)
    (stdlib 5.1.1) lists.erl:1594: :lists.foldl/3",../questions/Medium\ways-to-split-array-into-good-subarrays\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec number_of_good_subarray_splits(nums :: [integer]) :: integer do
    nums
    |> Enum.reduce({0, 0, 0}, fn
      1, {_ones_before, _ways, total_ways} -> {1, 0, total_ways}
      0, {1, ways, total_ways} -> {1, ways + 1, rem(total_ways + ways + 1, 1_000_000_007)}
      _, acc -> acc
    end)
    |> elem(2)
  end
end"
elixir,runtime_error,"Line 34: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(1, false)
    solution.ex:34: Solution.is_strictly_increasing/1
    solution.ex:16: Solution.incremovable_subarray_count_for_start/5
    solution.ex:9: Solution.incremovable_subarray_count/4
    solution.ex:52: Driver.consume_test_cases/2
    solution.ex:40: Driver.start/0
    nofile:1: (file)",../questions/Easy\count-the-number-of-incremovable-subarrays-i\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec incremovable_subarray_count(nums :: [integer]) :: integer
  def incremovable_subarray_count(nums) do
    incremovable_subarray_count(nums, 0, length(nums), 0)
  end

  defp incremovable_subarray_count(_nums, _start, 0, count), do: count
  defp incremovable_subarray_count(nums, start, length, count) do
    new_count = incremovable_subarray_count_for_start(nums, start, start, length, count)
    incremovable_subarray_count(nums, start + 1, length - 1, new_count)
  end

  defp incremovable_subarray_count_for_start(_nums, _start, _end, 0, count), do: count
  defp incremovable_subarray_count_for_start(nums, start, end_index, length, count) do
    remaining_nums = remove_subarray(nums, start, end_index)
    new_count = if is_strictly_increasing(remaining_nums), do: count + 1, else: count
    incremovable_subarray_count_for_start(nums, start, end_index + 1, length - 1, new_count)
  end

  defp remove_subarray(nums, start, finish) do
    nums
    |> Enum.slice(0..(start - 1))
    |> Enum.concat(Enum.slice(nums, (finish + 1)..-1))
  end

  defp is_strictly_increasing(nums) when length(nums) <= 1, do: true
  defp is_strictly_increasing([head | tail]) do
    Enum.reduce_while(tail, {true, head}, fn x, {is_increasing, last_element} ->
      if x > last_element do
        {:cont, {true, x}}
      else
        {:halt, false}
      end
    end) |> elem(0)
  end
end"
elixir,runtime_error,"Line 25: ** (Protocol.UndefinedError) protocol Enumerable not implemented for ""string"" of type BitString
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.reduce/3
    solution.ex:25: Driver.consume_test_cases/2
    solution.ex:13: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\faulty-keyboard\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec final_string(s :: String.t) :: String.t
  def final_string(s) do
    Enum.reduce(s, """", fn 
      'i', acc -> String.reverse(acc)
      char, acc -> acc <> to_string([char])
    end)
  end
end"
elixir,runtime_error,"Line 4: ** (Protocol.UndefinedError) protocol Enumerable not implemented for ""string"" of type BitString
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.reduce/3
    solution.ex:4: Solution.final_string/1
    solution.ex:29: Driver.consume_test_cases/2
    solution.ex:17: Driver.start/0
    nofile:1: (file)",../questions/Easy\faulty-keyboard\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec final_string(s :: String.t) :: String.t
  def final_string(s) do
    Enum.reduce(s, {[], false}, fn 
      'i', {acc, false} -> {acc, true}
      'i', {acc, true} -> {List.reverse(acc), false}
      char, {acc, false} -> {[char | acc], false}
      char, {acc, true} -> {acc ++ [char], true}
    end)
    |> elem(0)
    |> List.to_string()
  end
end"
elixir,runtime_error,"Line 7: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:7: anonymous fn/3 in Solution.find_champion/1
    (elixir 1.15.7) lib/enum.ex:4204: Enum.predicate_range/5
    solution.ex:7: anonymous fn/3 in Solution.find_champion/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:30: Driver.consume_test_cases/2
    solution.ex:18: Driver.start/0
    nofile:1: (file)",../questions/Easy\find-champion-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_champion(grid :: [[integer]]) :: integer
  def find_champion(grid) do
    # Iterate through each team
    Enum.reduce(0..length(grid)-1, -1, fn i, acc ->
      # If current team defeats all other teams, return its index
      if Enum.all?(0..length(grid)-1, fn j -> i == j or grid[i][j] == 1 end) do
        i
      else
        acc
      end
    end)
  end
end"
elixir,runtime_error,"Line 7: ** (Protocol.UndefinedError) protocol Enumerable not implemented for {0, 0} of type Tuple
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:1159: Enum.find/3
    solution.ex:7: anonymous fn/6 in Solution.find_indices/3
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:6: Solution.find_indices/3
    solution.ex:31: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Easy\find-indices-with-index-and-value-difference-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]
  def find_indices(nums, index_difference, value_difference) do
    n = length(nums)

    for i <- 0..(n - 1), j <- 0..(n - 1), do: {i, j}
    |> Enum.find([-1, -1], fn {i, j} ->
      abs(i - j) >= index_difference and abs(Enum.at(nums, i) - Enum.at(nums, j)) >= value_difference
    end)
  end
end"
elixir,runtime_error,"Line 9: ** (BadMapError) expected a map, got: [""cd"", ""ac"", ""dc"", ""ca"", ""zz""]
    (elixir 1.15.7) lib/map.ex:535: Map.get([""cd"", ""ac"", ""dc"", ""ca"", ""zz""], ""ac"", 0)
    solution.ex:9: anonymous fn/3 in Solution.maximum_number_of_string_pairs/1
    (stdlib 5.1.1) maps.erl:416: :maps.fold_1/4
    solution.ex:32: Driver.consume_test_cases/2
    solution.ex:20: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\find-maximum-number-of-string-pairs\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_number_of_string_pairs(words :: [String.t]) :: integer
  def maximum_number_of_string_pairs(words) do
    words
    |> Enum.reduce(%{}, fn word, acc ->
      Map.update(acc, String.reverse(word), 1, &(&1 + 1))
    end)
    |> Enum.reduce(0, fn {word, count}, acc ->
      if Map.get(words, word, 0) > 0 and word != String.reverse(word) do
        acc + div(count, 2)
      else
        acc
      end
    end)
  end
end"
elixir,runtime_error,"Line 5: ** (UndefinedFunctionError) function Enum.flatten/1 is undefined or private
    (elixir 1.15.7) Enum.flatten([[1, 3], [2, 2]])
    solution.ex:5: Solution.find_missing_and_repeated_values/1
    solution.ex:44: Driver.consume_test_cases/2
    solution.ex:32: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\find-missing-and-repeated-values\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_missing_and_repeated_values(grid :: [[integer]]) :: [integer]
  def find_missing_and_repeated_values(grid) do
    # Flatten the grid to a list and count occurrences of each number
    counts = Enum.reduce(Enum.flatten(grid), %{}, fn x, acc ->
      Map.update(acc, x, 1, &(&1 + 1))
    end)

    # Find the total number of elements (n^2) using the grid size
    n = length(grid)
    total_elements = n * n

    # Initialize variables for the missing and repeated numbers
    missing = nil
    repeated = nil

    # Check each number from 1 to n^2 to find the missing and repeated ones
    for num <- 1..total_elements do
      case Map.get(counts, num) do
        nil -> missing = num
        2 -> repeated = num
        _ -> :ok
      end
    end

    [repeated, missing]
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) errors were found at the given arguments:
  * 1st argument: not a list
    :erlang.length(""egcfe"")
    solution.ex:6: Solution.make_smallest_palindrome/1
    solution.ex:38: Driver.consume_test_cases/2
    solution.ex:26: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\lexicographically-smallest-palindrome\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec make_smallest_palindrome(s :: String.t) :: String.t
  def make_smallest_palindrome(s) do
    s
    |> String.graphemes()
    |> make_palindrome(0, length(s) - 1)
    |> Enum.join()
  end

  defp make_palindrome(chars, left, right) when left >= right, do: chars

  defp make_palindrome(chars, left, right) do
    if Enum.at(chars, left) == Enum.at(chars, right) do
      make_palindrome(chars, left + 1, right - 1)
    else
      smaller_char = Enum.min([Enum.at(chars, left), Enum.at(chars, right)])
      chars = List.replace_at(chars, left, smaller_char)
      chars = List.replace_at(chars, right, smaller_char)
      make_palindrome(chars, left + 1, right - 1)
    end
  end
end"
elixir,runtime_error,"Line 19: ** (UndefinedFunctionError) function Tuple.first/1 is undefined or private
    (elixir 1.15.7) Tuple.first({2, 2})
    solution.ex:19: Solution.alternating_subarray/1
    solution.ex:41: Driver.consume_test_cases/2
    solution.ex:29: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\longest-alternating-subarray\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec alternating_subarray(nums :: [integer]) :: integer
  def alternating_subarray(nums) do
    nums
    |> Enum.reduce({-1, 0}, fn x, {max_length, current_length} ->
      if current_length == 0 do
        {max_length, 2}
      else
        expected_diff = if rem(current_length, 2) == 0, do: 1, else: -1
        actual_diff = x - Enum.at(nums, -current_length - 1)

        if actual_diff == expected_diff do
          {max(max_length, current_length + 1), current_length + 1}
        else
          {max(max_length, current_length), 2}
        end
      end
    end)
    |> Tuple.first()
    |> case do
      -1 -> -1
      max_length -> max(max_length, 2)
    end
  end
end"
elixir,runtime_error,"Line 23: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(1, 0)
    solution.ex:23: Solution.find_subarray_length/3
    solution.ex:5: anonymous fn/4 in Solution.longest_alternating_subarray/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:45: Driver.consume_test_cases/2
    solution.ex:31: Driver.start/0
    nofile:1: (file)",../questions/Easy\longest-even-odd-subarray-with-threshold\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec longest_alternating_subarray(nums :: [integer], threshold :: integer) :: integer
  def longest_alternating_subarray(nums, threshold) do
    longest = Enum.reduce(0..length(nums)-1, 0, fn i, acc ->
      length = find_subarray_length(nums, threshold, i)
      if length > acc, do: length, else: acc
    end)
    longest
  end

  defp find_subarray_length(nums, threshold, start_index) when start_index < length(nums) do
    nums
    |> Enum.drop(start_index)
    |> Enum.take_while(fn x -> x <= threshold end)
    |> Enum.reduce_while({0, nil}, fn num, {count, prev_parity} ->
      current_parity = rem(num, 2)
      if prev_parity == nil do
        if current_parity == 0, do: {:cont, {count + 1, current_parity}}, else: {:halt, count}
      else
        if prev_parity != current_parity, do: {:cont, {count + 1, current_parity}}, else: {:halt, count}
      end
    end)
    |> elem(0)
  end

  defp find_subarray_length(_, _, _), do: 0
end"
elixir,runtime_error,"Line 5: ** (UndefinedFunctionError) function String.count/2 is undefined or private
    (elixir 1.15.7) String.count(""010"", ""1"")
    solution.ex:5: Solution.maximum_odd_binary_number/1
    solution.ex:29: Driver.consume_test_cases/2
    solution.ex:17: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\maximum-odd-binary-number\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_odd_binary_number(s :: String.t) :: String.t
  def maximum_odd_binary_number(s) do
    # Count the number of '1's in the string
    ones = String.count(s, ""1"")
    # Count the number of '0's in the string
    zeros = String.length(s) - ones
    # Create the maximum odd binary number
    # If there is more than one '1', place all '0's to the left and '1's to the right, except one '1' at the end.
    # If there is exactly one '1', it will automatically be placed at the end.
    result = String.duplicate(""0"", zeros) <> String.duplicate(""1"", ones - 1) <> ""1""
  end
end"
elixir,runtime_error,"Line 9: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:9: anonymous fn/5 in Solution.maximum_triplet_value/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:6: Solution.maximum_triplet_value/1
    solution.ex:31: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)",../questions/Easy\maximum-value-of-an-ordered-triplet-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_triplet_value(nums :: [integer]) :: integer
  def maximum_triplet_value(nums) do
    nums
    |> Enum.with_index()
    |> Enum.reduce(0, fn {num_k, k}, acc ->
      Enum.reduce(0..k-1, acc, fn j, acc_j ->
        Enum.reduce(0..j-1, acc_j, fn i, acc_i ->
          max(acc_i, (nums[i] - nums[j]) * num_k)
        end)
      end)
    end)
    |> max(0)
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:6: anonymous fn/4 in Solution.minimum_sum/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:5: anonymous fn/3 in Solution.minimum_sum/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:4: Solution.minimum_sum/1
    solution.ex:38: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Easy\minimum-sum-of-mountain-triplets-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_sum(nums :: [integer]) :: integer
  def minimum_sum(nums) do
    min_sum = Enum.reduce(1..length(nums)-2, :infinity, fn j, acc ->
      left_min = Enum.reduce(0..j-1, :infinity, fn i, acc_min ->
        if nums[i] < nums[j], do: min(acc_min, nums[i]), else: acc_min
      end)
      
      right_min = Enum.reduce(j+1..length(nums)-1, :infinity, fn k, acc_min ->
        if nums[k] < nums[j], do: min(acc_min, nums[k]), else: acc_min
      end)
      
      if left_min != :infinity and right_min != :infinity do
        min(acc, left_min + nums[j] + right_min)
      else
        acc
      end
    end)
    
    if min_sum == :infinity, do: -1, else: min_sum
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:6: anonymous fn/4 in Solution.count_beautiful_pairs/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:5: anonymous fn/3 in Solution.count_beautiful_pairs/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:39: Driver.consume_test_cases/2
    solution.ex:27: Driver.start/0
    nofile:1: (file)",../questions/Easy\number-of-beautiful-pairs\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec count_beautiful_pairs(nums :: [integer]) :: integer
  def count_beautiful_pairs(nums) do
    Enum.reduce(0..length(nums)-2, 0, fn i, acc ->
      acc + Enum.reduce(i+1..length(nums)-1, 0, fn j, acc_inner ->
        if coprime?(first_digit(nums[i]), last_digit(nums[j])), do: acc_inner + 1, else: acc_inner
      end)
    end)
  end

  defp first_digit(num) do
    Enum.reduce_while(num |> Integer.digits, num, fn digit, _acc ->
      if digit < 10, do: {:halt, digit}, else: {:cont, digit}
    end)
  end

  defp last_digit(num), do: rem(num, 10)

  defp coprime?(x, y), do: gcd(x, y) == 1

  defp gcd(x, 0), do: x
  defp gcd(x, y), do: gcd(y, rem(x, y))
end"
elixir,runtime_error,"Line 16: ** (ArithmeticError) bad argument in arithmetic expression: rem(nil, 10)
    :erlang.rem(nil, 10)
    solution.ex:16: Solution.last_digit/1
    solution.ex:8: anonymous fn/4 in Solution.count_beautiful_pairs/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:6: anonymous fn/3 in Solution.count_beautiful_pairs/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:38: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Easy\number-of-beautiful-pairs\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec count_beautiful_pairs(nums :: [integer]) :: integer
  def count_beautiful_pairs(nums) do
    Enum.with_index(nums)
    |> Enum.reduce(0, fn {num_i, index_i}, acc ->
      acc + Enum.reduce(index_i+1..Enum.count(nums)-1, 0, fn index_j, acc_inner ->
        num_j = Enum.at(nums, index_j)
        if coprime?(first_digit(num_i), last_digit(num_j)), do: acc_inner + 1, else: acc_inner
      end)
    end)
  end

  defp first_digit(num) when num < 10, do: num
  defp first_digit(num), do: first_digit(div(num, 10))

  defp last_digit(num), do: rem(num, 10)

  defp coprime?(x, y), do: gcd(x, y) == 1

  defp gcd(x, 0), do: x
  defp gcd(x, y), do: gcd(y, rem(x, y))
end"
elixir,runtime_error,"Line 8: ** (FunctionClauseError) no function clause matching in anonymous fn/1 in Solution.number_of_points/1
    The following arguments were given to anonymous fn/1 in Solution.number_of_points/1:
        # 1
        [1, 7]
    solution.ex:8: anonymous fn/1 in Solution.number_of_points/1
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:8: Solution.number_of_points/1
    solution.ex:45: Driver.consume_test_cases/2
    solution.ex:33: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\points-that-intersect-with-cars\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec number_of_points(nums :: [[integer]]) :: integer
  def number_of_points(nums) do
    # Sort intervals based on the start point.
    nums
    |> Enum.sort()
    |> reduce_intervals()
    |> Enum.map(fn {start, finish} -> finish - start + 1 end)
    |> Enum.sum()
  end

  defp reduce_intervals(nums) do
    # Use a fold to merge overlapping intervals and collect the total length.
    Enum.reduce(nums, [], fn [start, finish], acc ->
      case acc do
        [] ->
          [[start, finish]]
        
        [[prev_start, prev_finish] | t] = _acc ->
          if start <= prev_finish do
            [[prev_start, max(prev_finish, finish)] | t]
          else
            [[start, finish] | acc]
          end
      end
    end)
    |> Enum.reverse()
  end
end"
elixir,runtime_error,"Line 11: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(2, 0)
    solution.ex:11: Solution.missing_integer/1
    solution.ex:35: Driver.consume_test_cases/2
    solution.ex:23: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Easy\smallest-missing-integer-greater-than-sequential-prefix-sum\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec missing_integer(nums :: [integer]) :: integer
  def missing_integer(nums) do
    # Step 1: Find the sum of the longest sequential prefix
    longest_seq_sum = Enum.reduce_while(nums, {nums |> hd(), 0}, fn x, {prev, sum} ->
      if x == prev + 1 do
        {:cont, {x, sum + x}}
      else
        {:halt, sum}
      end
    end) |> elem(1)

    # Step 2: Find the smallest missing integer greater than or equal to the sum
    Stream.iterate(longest_seq_sum + 1, &(&1 + 1))
    |> Enum.find(fn x ->
      not Enum.member?(nums, x)
    end)
  end
end"
elixir,runtime_error,"Line 4: ** (ArgumentError) errors were found at the given arguments:
  * 1st argument: not a bitstring
    :erlang.bit_size(2)
    solution.ex:4: anonymous fn/1 in Solution.max_sum/2
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:4: Solution.max_sum/2
    solution.ex:28: Driver.consume_test_cases/2
    solution.ex:14: Driver.start/0
    nofile:1: (file)",../questions/Hard\apply-operations-on-array-to-maximize-sum-of-squares\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  def max_sum(nums, k) do
    nums
    |> Enum.map(fn x -> {x, bit_size(x)} end)
    |> Enum.sort_by(fn {_, bits} -> bits end, :desc)
    |> Enum.take(k)
    |> Enum.map(fn {x, _} -> x end)
    |> Enum.reduce(0, fn x, acc -> acc + rem(x * x, 1_000_000_007) end)
  end
end"
elixir,runtime_error,"Line 25: ** (ArgumentError) ranges (first..last) expect both sides to be integers, got: 2..2.0
    (elixir 1.15.7) lib/range.ex:193: Range.new/2
    solution.ex:25: Solution.is_prime/1
    (elixir 1.15.7) lib/enum.ex:1121: anonymous fn/3 in Enum.filter/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:2514: Enum.filter/2
    solution.ex:13: Solution.prime_score/1
    solution.ex:5: anonymous fn/1 in Solution.maximum_score/2
    nofile:1: (file)",../questions/Hard\apply-operations-to-maximize-score\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_score(nums :: [integer], k :: integer) :: integer
  def maximum_score(nums, k) do
    nums
    |> Enum.map(&{prime_score(&1), &1})
    |> Enum.sort_by(&{&1 |> elem(0), &1 |> elem(1)}, &(&1 > &2))
    |> Enum.take(k)
    |> Enum.reduce(1, fn {_, val}, acc -> rem(acc * val, 1_000_000_007) end)
  end

  defp prime_score(n) do
    n
    |> prime_factors
    |> Enum.uniq
    |> length
  end

  defp prime_factors(n) do
    2..n
    |> Enum.filter(fn x -> rem(n, x) == 0 && is_prime(x) end)
  end

  defp is_prime(2), do: true
  defp is_prime(n) when n > 1 do
    Enum.none?(2..:math.sqrt(n), fn x -> rem(n, x) == 0 end)
  end
  defp is_prime(_), do: false
end"
elixir,runtime_error,"Line 23: ** (ArgumentError) ranges (first..last) expect both sides to be integers, got: 2..2.0
    (elixir 1.15.7) lib/range.ex:193: Range.new/2
    solution.ex:23: Solution.is_prime/1
    (elixir 1.15.7) lib/enum.ex:1121: anonymous fn/3 in Enum.filter/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:2514: Enum.filter/2
    solution.ex:5: anonymous fn/1 in Solution.maximum_score/2
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    nofile:1: (file)",../questions/Hard\apply-operations-to-maximize-score\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_score(nums :: [integer], k :: integer) :: integer
  def maximum_score(nums, k) do
    nums
    |> Enum.map(&{&1, prime_factors(&1) |> Enum.uniq |> length})
    |> Enum.sort()
    |> Enum.reverse()
    |> Enum.take(k)
    |> Enum.map(&elem(&1, 0))
    |> Enum.reduce(1, fn x, acc -> rem(acc * x, 1_000_000_007) end)
  end

  defp prime_factors(n) do
    2..n
    |> Enum.filter(&(divides(n, &1) && is_prime(&1)))
  end

  defp divides(n, divisor), do: rem(n, divisor) == 0

  defp is_prime(1), do: false
  defp is_prime(2), do: true
  defp is_prime(n) do
    2..:math.sqrt(n)
    |> Enum.none?(fn x -> rem(n, x) == 0 end)
  end
end"
elixir,runtime_error,"Line 6: ** (FunctionClauseError) no function clause matching in anonymous fn/2 in Solution.beautiful_substrings/2
    The following arguments were given to anonymous fn/2 in Solution.beautiful_substrings/2:
        # 1
        ""a""
        # 2
        0
    solution.ex:6: anonymous fn/2 in Solution.beautiful_substrings/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:6: Solution.beautiful_substrings/2
    solution.ex:42: Driver.consume_test_cases/2
    solution.ex:28: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Hard\count-beautiful-substrings-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec beautiful_substrings(s :: String.t, k :: integer) :: integer
  def beautiful_substrings(s, k) do
    s
    |> String.graphemes()
    |> Enum.reduce({0, %{}}, fn char, {count, acc} ->
      new_acc = Map.update(acc, char, {1, char in [""a"", ""e"", ""i"", ""o"", ""u""]}, fn {c, is_vowel} ->
        {c + 1, is_vowel}
      end)
      count + count_beautiful_substrings(new_acc, k)
    end)
    |> elem(0)
  end

  defp count_beautiful_substrings(acc, k) do
    acc
    |> Enum.reduce({0, 0, 0}, fn {_, {count, is_vowel}}, {total, vowels, consonants} ->
      if is_vowel, do: {total, vowels + count, consonants}, else: {total, vowels, consonants + count}
    end)
    |> (fn {_, vowels, consonants} -> 
      if vowels == consonants and rem(vowels * consonants, k) == 0, do: 1, else: 0
    end).()
  end
end"
elixir,runtime_error,"Line 10: ** (BadMapError) expected a map, got: []
    solution.ex:10: anonymous fn/3 in Solution.beautiful_substrings/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:7: Solution.beautiful_substrings/2
    solution.ex:47: Driver.consume_test_cases/2
    solution.ex:33: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Hard\count-beautiful-substrings-ii\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec beautiful_substrings(s :: String.t, k :: integer) :: integer
  def beautiful_substrings(s, k) do
    s
    |> String.graphemes()
    |> Enum.map(&char_to_tuple/1)
    |> Enum.reduce({0, %{}}, fn {v, c}, {total, acc} ->
      acc = Enum.map(acc, fn {key, {vowels, consonants}} ->
        {key + 1, {vowels + v, consonants + c}}
      end) |> Map.put(0, {v, c})
      beautiful_count = Enum.count(acc, fn {_key, {vowels, consonants}} ->
        vowels == consonants and rem(vowels * consonants, k) == 0
      end)
      {total + beautiful_count, acc}
    end)
    |> elem(0)
  end

  defp char_to_tuple(char) do
    case char do
      ""a"" -> {1, 0}
      ""e"" -> {1, 0}
      ""i"" -> {1, 0}
      ""o"" -> {1, 0}
      ""u"" -> {1, 0}
      _ -> {0, 1}
    end
  end
end"
elixir,runtime_error,"Line 13: ** (ArgumentError) argument error
    (stdlib 5.1.1) array.erl:589: :array.set/3
    solution.ex:13: anonymous fn/2 in Solution.incremovable_subarray_count/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:9: Solution.incremovable_subarray_count/1
    solution.ex:53: Driver.consume_test_cases/2
    solution.ex:41: Driver.start/0
    nofile:1: (file)",../questions/Hard\count-the-number-of-incremovable-subarrays-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec incremovable_subarray_count(nums :: [integer]) :: integer
  def incremovable_subarray_count(nums) do
    len = length(nums)
    left = :array.new(len, {:default, 0})
    right = :array.new(len, {:default, 0})

    nums
    |> Enum.reduce({:infinity, 0, left}, fn x, {prev, idx, left} ->
      if x > prev do
        left = :array.set(left, idx, idx - 1)
      else
        left = :array.set(left, idx, idx)
      end
      {x, idx + 1, left}
    end)
    |> elem(2)

    |> Enum.reduce({:infinity, len - 1, right}, fn x, {prev, idx, right} ->
      if x < prev do
        right = :array.set(right, idx, idx + 1)
      else
        right = :array.set(right, idx, idx)
      end
      {x, idx - 1, right}
    end)
    |> elem(2)

    |> Enum.with_index()
    |> Enum.map(fn {r, idx} ->
      l_val = :array.get(left, idx)
      r - l_val - 1
    end)
    |> Enum.sum()
    |> Kernel.+(len)
  end
end"
elixir,runtime_error,"Line 11: ** (UndefinedFunctionError) function Enum.last/1 is undefined or private
    (elixir 1.15.7) Enum.last([1])
    solution.ex:11: anonymous fn/4 in Solution.incremovable_subarray_count/1
    (elixir 1.15.7) lib/enum.ex:721: anonymous fn/3 in Enum.count/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    solution.ex:6: anonymous fn/4 in Solution.incremovable_subarray_count/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:33: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Hard\count-the-number-of-incremovable-subarrays-ii\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec incremovable_subarray_count(nums :: [integer]) :: integer
  def incremovable_subarray_count(nums) do
    n = length(nums)
    Enum.reduce(1..n, 0, fn i, acc ->
      acc + Enum.count(1..(n-i+1), fn j ->
        subarray = Enum.slice(nums, j-1, i)
        prefix = Enum.slice(nums, 0, j-1)
        suffix = Enum.slice(nums, j-1+i, n-(j-1+i))
        is_incremovable = (prefix == [] or Enum.last(prefix) < hd(subarray)) and
                          (suffix == [] or Enum.last(subarray) < hd(suffix)) and
                          (Enum.sort(subarray) == subarray and Enum.uniq(subarray) == subarray)
        is_incremovable && (prefix ++ suffix |> Enum.sort() == prefix ++ suffix) || i == 1
      end)
    end)
  end
end"
elixir,runtime_error,"Line 8: ** (ArgumentError) errors were found at the given arguments:
  * 1st argument: not a nonempty list
    :erlang.hd(1..5)
    solution.ex:8: anonymous fn/2 in Solution.number_of_sequence/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:8: Solution.number_of_sequence/2
    solution.ex:44: Driver.consume_test_cases/2
    solution.ex:30: Driver.start/0
    nofile:1: (file)",../questions/Hard\count-the-number-of-infection-sequences\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec number_of_sequence(n :: integer, sick :: [integer]) :: integer
  def number_of_sequence(n, sick) do
    mod = 1_000_000_007

    # Calculate factorial and its modular inverse
    factorial = Enum.reduce(0..n, [1], fn x, acc -> [rem(hd(acc) * x, mod) | acc] end) |> Enum.reverse
    inv_factorial = Enum.reduce([1], 1..n, fn x, acc -> [rem(hd(acc) * :math.pow(x, mod - 2, mod), mod) | acc] end) |> Enum.reverse

    calculate_ways = fn (total, sick) ->
      combinations = rem(factorial[total] * inv_factorial[sick] * inv_factorial[total - sick], mod)
      rem(combinations, mod)
    end

    gaps = Enum.zip([-1 | sick], sick ++ [n]) |> Enum.map(fn {a, b} -> b - a - 1 end)
    total_ways = Enum.reduce(gaps, 1, fn gap, acc ->
      if gap <= 0 do
        acc
      else
        rem(acc * calculate_ways.(gap, 1), mod)
      end
    end)

    total_ways
  end
end"
elixir,runtime_error,"Line 6: ** (UndefinedFunctionError) function Tuple.put_element/3 is undefined or private
    (elixir 1.15.7) Tuple.put_element({}, 1, 0)
    (elixir 1.15.7) lib/list.ex:1351: List.do_update_at/3
    solution.ex:6: Solution.minimum_cost/3
    solution.ex:44: Driver.consume_test_cases/2
    solution.ex:28: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Hard\divide-an-array-into-subarrays-with-minimum-cost-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_cost(nums :: [integer], k :: integer, dist :: integer) :: integer
  def minimum_cost(nums, k, dist) do
    n = length(nums)
    dp = for _ <- 0..n, do: :erlang.make_tuple(k + 1, :infinity)
    dp = List.update_at(dp, 0, fn _ -> Tuple.put_element({}, 1, 0) end)

    for i <- 1..n do
      dp = List.update_at(dp, i, fn _ -> Tuple.put_element({}, 1, Enum.at(nums, i - 1)) end)
      for j <- 2..min(i, k) do
        min_cost = :infinity
        for l <- max(1, i - dist)..(i - 1) do
          cost = Tuple.to_list(Enum.at(dp, l))[j - 1] + Enum.at(nums, i - 1)
          min_cost = min(min_cost, cost)
        end
        dp = List.update_at(dp, i, fn current ->
          Tuple.put_element(current, j, min_cost)
        end)
      end
    end

    Tuple.to_list(Enum.at(dp, n))[k]
  end
end"
elixir,runtime_error,"Line 17: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(2, nil)
    solution.ex:17: anonymous fn/7 in Solution.minimum_cost/3
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    solution.ex:15: anonymous fn/6 in Solution.minimum_cost/3
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:12: Solution.minimum_cost/3
    solution.ex:51: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Hard\divide-an-array-into-subarrays-with-minimum-cost-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_cost(nums :: [integer], k :: integer, dist :: integer) :: integer
  def minimum_cost(nums, k, dist) do
    n = length(nums)
    dp = :array.new(n + 1, default: :infinity, fixed: true)
    dp = :array.set(0, 0, dp)

    for i <- 1..n do
      dp = :array.set(i, Enum.at(nums, i - 1), dp)
    end

    for j <- 2..k do
      new_dp = :array.new(n + 1, default: :infinity, fixed: true)
      min_queue = [{0, :array.get(0, dp)}]
      for i <- 1..n do
        min_queue = Enum.drop_while(min_queue, fn {idx, _} -> i - idx > dist end)
        min_cost = elem(List.first(min_queue), 1) + Enum.at(nums, i - 1)
        new_dp = :array.set(i, min_cost, new_dp)
        min_queue = Enum.drop_while(min_queue, fn {_, cost} -> cost >= :array.get(i, dp) end)
        min_queue = min_queue ++ [{i, :array.get(i, dp)}]
      end
      dp = new_dp
    end

    min_val = :infinity
    for i <- (n - dist)..n do
      min_val = min(min_val, :array.get(i, dp))
    end
    min_val
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:6: anonymous fn/4 in Solution.can_traverse_all_pairs/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:4: Solution.can_traverse_all_pairs/1
    solution.ex:69: Driver.consume_test_cases/2
    solution.ex:57: Driver.start/0
    nofile:1: (file)",../questions/Hard\greatest-common-divisor-traversal\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec can_traverse_all_pairs(nums :: [integer]) :: boolean
  def can_traverse_all_pairs(nums) do
    graph = Enum.reduce(0..length(nums)-1, %{}, fn i, acc ->
      Enum.reduce(0..length(nums)-1, acc, fn j, acc2 ->
        if gcd(nums[i], nums[j]) > 1, do: Map.update(acc2, i, [j], &[j | &1]), else: acc2
      end)
    end)

    connected_components = tarjan(graph)

    Enum.all?(connected_components, fn component ->
      length(component) == length(nums)
    end)
  end

  defp gcd(a, 0), do: a
  defp gcd(a, b), do: gcd(b, rem(a, b))

  defp tarjan(graph) do
    {_, _, sccs} = Enum.reduce(graph, {0, %{}, []}, fn {node, _}, {index, indices, sccs} ->
      if Map.has_key?(indices, node), do: {index, indices, sccs}, else: tarjan_visit(node, graph, index, indices, %{}, [], sccs)
    end)
    sccs
  end

  defp tarjan_visit(v, graph, index, indices, lowlinks, stack, sccs) do
    indices = Map.put(indices, v, index)
    lowlinks = Map.put(lowlinks, v, index)
    stack = [v | stack]
    index = index + 1

    neighbors = Map.get(graph, v, [])
    {index, indices, lowlinks, stack} = Enum.reduce(neighbors, {index, indices, lowlinks, stack}, fn w, {index, indices, lowlinks, stack} ->
      if not Map.has_key?(indices, w) do
        {index, indices, lowlinks, stack} = tarjan_visit(w, graph, index, indices, lowlinks, stack, sccs)
        lowlinks = Map.put(lowlinks, v, min(Map.get(lowlinks, v), Map.get(lowlinks, w)))
        {index, indices, lowlinks, stack}
      else
        if Enum.member?(stack, w), do: lowlinks = Map.put(lowlinks, v, min(Map.get(lowlinks, v), indices[w]))
        {index, indices, lowlinks, stack}
      end
    end)

    if indices[v] == lowlinks[v] do
      {component, rest_stack} = Enum.split_while(stack, &(&1 != v))
      sccs = [Enum.reverse([v | component]) | sccs]
      stack = rest_stack
    end

    {index, indices, lowlinks, stack, sccs}
  end
end"
elixir,runtime_error,"Line 6: ** (Protocol.UndefinedError) protocol Enumerable not implemented for {0, 2} of type Tuple
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.reverse/1
    (elixir 1.15.7) lib/enum.ex:1409: Enum.group_by/3
    solution.ex:6: anonymous fn/4 in Solution.can_traverse_all_pairs/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    nofile:1: (file)",../questions/Hard\greatest-common-divisor-traversal\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec can_traverse_all_pairs(nums :: [integer]) :: boolean
  def can_traverse_all_pairs(nums) do
    len = length(nums)
    graph = for i <- 0..len-1, j <- 0..len-1, i != j, gcd(nums |> Enum.at(i), nums |> Enum.at(j)) > 1, do: {i, j}
    |> Enum.group_by(&elem(&1, 0), &elem(&1, 1))
    |> Map.new()

    all_nodes = 0..len-1 |> Enum.into(MapSet.new())
    visited = MapSet.new()
    Enum.all?(all_nodes, fn node ->
      reachable = traverse(graph, node, MapSet.new())
      MapSet.equal?(reachable, all_nodes)
    end)
  end

  defp gcd(a, 0), do: a
  defp gcd(a, b), do: gcd(b, rem(a, b))

  defp traverse(graph, start, visited) do
    if MapSet.member?(visited, start) do
      visited
    else
      neighbors = Map.get(graph, start, [])
      Enum.reduce(neighbors, MapSet.put(visited, start), fn neighbor, acc ->
        traverse(graph, neighbor, acc)
      end)
    end
  end
end"
elixir,runtime_error,"Line 5: ** (Protocol.UndefinedError) protocol Enumerable not implemented for ""cbaaaabc"" of type BitString
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.reduce/3
    solution.ex:5: Solution.longest_valid_substring/2
    solution.ex:32: Driver.consume_test_cases/2
    solution.ex:18: Driver.start/0
    nofile:1: (file)",../questions/Hard\length-of-the-longest-valid-substring\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec longest_valid_substring(word :: String.t, forbidden :: [String.t]) :: integer
  def longest_valid_substring(word, forbidden) do
    word
    |> Enum.reduce({0, 0}, fn char, {max_len, current_len} ->
      new_word = word |> String.slice(-current_len-1..-1) |> Kernel.<>(<<char::utf8>>)
      cond do
        Enum.any?(forbidden, &String.contains?(new_word, &1)) -> {max_len, 0}
        true -> {max(max_len, current_len + 1), current_len + 1}
      end
    end)
    |> elem(0)
  end
end"
elixir,runtime_error,"Line 28: ** (Protocol.UndefinedError) protocol Enumerable not implemented for ""ca"" of type BitString
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.split_while/2
    solution.ex:28: Solution.count_partitions/4
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map_range/4
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    (elixir 1.15.7) lib/enum.ex:1260: anonymous fn/3 in Enum.flat_map/2
    nofile:1: (file)",../questions/Hard\maximize-the-number-of-partitions-after-operations\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec max_partitions_after_operations(s :: String.t(), k :: integer()) :: integer()
  def max_partitions_after_operations(s, k) do
    if k >= 26, do: 1, else: max_partitions_with_change(s, k)
  end

  defp max_partitions_with_change(s, k) do
    0..String.length(s) - 1
    |> Enum.flat_map(fn i -> Enum.map(?a..?z, fn c -> count_partitions(change_char(s, i, c), k) end) end)
    |> Enum.max()
  end

  defp change_char(s, index, char) do
    String.slice(s, 0, index) <> <<char>> <> String.slice(s, index + 1..-1)
  end

  defp count_partitions(s, k) do
    count_partitions(s, k, 0, %{})
  end

  defp count_partitions("""", _k, count, _), do: count

  defp count_partitions(s, k, count, chars) when map_size(chars) <= k do
    if String.length(s) == 0, do: count, else: count_partitions(String.slice(s, 1..-1), k, count + 1, update_chars(chars, String.at(s, 0)))
  end

  defp count_partitions(s, k, count, chars) do
    {prefix, _} = Enum.split_while(s, fn c -> Map.has_key?(chars, c) or map_size(chars) < k end)
    count_partitions(String.slice(s, length(prefix)..-1), k, count + 1, %{})
  end

  defp update_chars(chars, char) do
    Map.update(chars, char, 1, &(&1 + 1))
  end
end"
elixir,runtime_error,"Line 5: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(2, [10, 1])
    solution.ex:5: anonymous fn/1 in Solution.find_maximum_elegance/2
    (elixir 1.15.7) lib/enum.ex:1410: anonymous fn/4 in Enum.group_by/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-group_by/3-lists^foldl/2-0-""/3
    solution.ex:5: Solution.find_maximum_elegance/2
    solution.ex:33: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)",../questions/Hard\maximum-elegance-of-a-k-length-subsequence\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_maximum_elegance(items :: [[integer]], k :: integer) :: integer
  def find_maximum_elegance(items, k) do
    items
    |> Enum.group_by(&elem(&1, 1))
    |> Enum.map(fn {_, v} -> Enum.sort_by(v, &elem(&1, 0), :desc) end)
    |> List.flatten()
    |> Enum.sort_by(&elem(&1, 0), :desc)
    |> Enum.take(k)
    |> Enum.reduce({%{}, 0}, fn [p, c], {cats, sum} ->
      {Map.update(cats, c, 1, &(&1 + 1)), sum + p}
    end)
    |> (fn {cats, sum} -> sum + Map.size(cats) * Map.size(cats) end).()
  end
end"
elixir,runtime_error,"Line 5: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(2, [10, 1])
    solution.ex:5: anonymous fn/1 in Solution.find_maximum_elegance/2
    (elixir 1.15.7) lib/enum.ex:1410: anonymous fn/4 in Enum.group_by/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-group_by/3-lists^foldl/2-0-""/3
    solution.ex:5: Solution.find_maximum_elegance/2
    solution.ex:39: Driver.consume_test_cases/2
    solution.ex:25: Driver.start/0
    nofile:1: (file)",../questions/Hard\maximum-elegance-of-a-k-length-subsequence\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec find_maximum_elegance(items :: [[integer]], k :: integer) :: integer
  def find_maximum_elegance(items, k) do
    items
    |> Enum.group_by(&elem(&1, 1), fn [p, _c] -> p end)
    |> Enum.map(fn {_cat, profits} -> Enum.sort(profits, :desc) end)
    |> Enum.sort_by(&Enum.count(&1), :desc)
    |> Enum.reduce_while({0, 0}, fn profits, {sum, categories} ->
      if categories < k do
        new_sum = Enum.take(profits, min(k - categories, Enum.count(profits))) |> Enum.sum()
        {:cont, {sum + new_sum, categories + 1}}
      else
        {:halt, sum + categories * categories}
      end
    end)
    |> case do
      {sum, categories} when categories == k -> sum + categories * categories
      _ -> 0
    end
  end
end"
elixir,runtime_error,"Line 11: ** (FunctionClauseError) no function clause matching in Solution.max_xor_pair/2
    The following arguments were given to Solution.max_xor_pair/2:
        # 1
        3
        # 2
        [2, 3, 4, 5]
    solution.ex:11: Solution.max_xor_pair/2
    solution.ex:40: Driver.consume_test_cases/2
    solution.ex:28: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Hard\maximum-strong-pair-xor-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_strong_pair_xor(nums :: [integer]) :: integer
  def maximum_strong_pair_xor(nums) do
    nums
    |> Enum.sort()
    |> Enum.uniq()
    |> max_xor_pair(0)

  end

  defp max_xor_pair([], acc), do: acc
  defp max_xor_pair([_], acc), do: acc
  defp max_xor_pair([h | t], acc) do
    t
    |> Enum.reduce(acc, fn x, acc ->
      if abs(h - x) <= min(h, x) do
        max(acc, Bitwise.bxor(h, x))
      else
        acc
      end
    end)
    |> max_xor_pair(t)
  end
end"
elixir,runtime_error,"Line 6: ** (KeyError) key :third not found in: {4, 2, 6}
If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    solution.ex:6: anonymous fn/1 in Solution.maximum_sum_queries/3
    (elixir 1.15.7) lib/enum.ex:3314: anonymous fn/3 in Enum.sort_by/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    (elixir 1.15.7) lib/enum.ex:3314: Enum.sort_by/3
    solution.ex:6: Solution.maximum_sum_queries/3
    solution.ex:38: Driver.consume_test_cases/2
    solution.ex:22: Driver.start/0
    nofile:1: (file)",../questions/Hard\maximum-sum-queries\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec maximum_sum_queries(nums1 :: [integer], nums2 :: [integer], queries :: [[integer]]) :: [integer]
  def maximum_sum_queries(nums1, nums2, queries) do
    nums = Enum.zip(nums1, nums2)
            |> Enum.map(fn {x, y} -> {x, y, x + y} end)
            |> Enum.sort_by(&(&1.third), :desc)

    Enum.map(queries, fn [xi, yi] ->
      Enum.reduce_while(nums, -1, fn {x, y, sum}, acc ->
        if x >= xi and y >= yi do
          {:halt, sum}
        else
          {:cont, acc}
        end
      end)
    end)
  end
end"
elixir,runtime_error,"Line 20: ** (Protocol.UndefinedError) protocol Enumerable not implemented for 1000 of type Integer
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:230: Enumerable.slice/1
    (elixir 1.15.7) lib/enum.ex:4459: Enum.slice_forward/4
    (elixir 1.15.7) lib/enum.ex:476: Enum.at/3
    solution.ex:20: anonymous fn/5 in Solution.minimum_changes/2
    (elixir 1.15.7) lib/list.ex:1351: List.do_update_at/3
    (elixir 1.15.7) lib/list.ex:1355: List.do_update_at/3
    nofile:1: (file)",../questions/Hard\minimum-changes-to-make-k-semi-palindromes\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_changes(s :: String.t, k :: integer) :: integer
  def minimum_changes(s, k) do
    dp = for _ <- 0..String.length(s), do: for _ <- 0..String.length(s), do: 1000
    dp = List.update_at(dp, 0, fn _ -> List.update_at(dp |> hd, 0, fn _ -> 0 end) end)

    for i <- 1..String.length(s), j <- i..String.length(s), reduce: dp do
      dp_acc -> List.update_at(dp_acc, i, fn row ->
        List.update_at(row, j, fn _ -> calculate_changes(String.slice(s, i-1, j-i+1)) end)
      end)
    end

    for _ <- 1..k, reduce: dp do
      dp_acc ->
        ndp = Enum.map(0..String.length(s), fn _ -> 1000 end)
        ndp = List.update_at(ndp, 0, fn _ -> 0 end)

        for j <- 1..String.length(s), l <- 0..j-1, reduce: ndp do
          ndp_acc -> List.update_at(ndp_acc, j, fn current ->
            Enum.min([current, Enum.at(ndp_acc, l) + Enum.at(Enum.at(dp_acc, l+1), j)])
          end)
        end
    end
    |> Enum.at(String.length(s))
    |> Enum.at(String.length(s))
  end

  defp calculate_changes(substring) do
    len = String.length(substring)
    changes = 0

    for i <- 0..div(len-1, 2), reduce: changes do
      changes_acc -> if String.at(substring, i) != String.at(substring, len-i-1), do: changes_acc + 1, else: changes_acc
    end
  end
end"
elixir,runtime_error,"Line 6: ** (Protocol.UndefinedError) protocol Enumerable not implemented for ""a"" of type BitString
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.reduce/3
    solution.ex:6: anonymous fn/4 in Solution.minimum_changes/2
    solution.ex:22: anonymous fn/9 in Solution.minimum_changes/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:35: Solution.minimum_changes/2
    nofile:1: (file)",../questions/Hard\minimum-changes-to-make-k-semi-palindromes\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_changes(s :: String.t, k :: integer) :: integer
  def minimum_changes(s, k) do
    memo = :ets.new(:memo, [:protected, :named_table, read_concurrency: true])
    changes = fn changes, i, j -> 
      s |> String.slice(i, j - i + 1) |> Enum.reduce(0, fn x, acc -> if x === Enum.at(s, j - acc), do: acc, else: acc + 1 end) |> div(2)
    end
    semi_palindrome_changes = fn semi_palindrome_changes, i, j, s ->
      Enum.reduce(1..div(j - i, 2), 0, fn d, acc ->
        if rem(j - i + 1, d) == 0 do
          acc + changes.(s, i, i + d - 1) + semi_palindrome_changes.(i + d, j, s)
        else
          acc
        end
      end)
    end
    dp = fn dp, i, j, s, k ->
      if k == 1 do
        semi_palindrome_changes.(0, String.length(s) - 1, s)
      else
        Enum.reduce(i..j-1, :infinity, fn idx, acc ->
          change = changes.(s, i, idx) + (case :ets.lookup(memo, {idx + 1, k - 1}) do
            [] -> dp.(dp, idx + 1, j, s, k - 1)
            [{_, val}] -> val
          end)
          if change < acc do
            :ets.insert(memo, {{i, k}, change})
            change
          else
            acc
          end
        end)
      end
    end
    result = dp.(dp, 0, String.length(s) - 1, s, k)
    :ets.delete(memo)
    result
  end
end"
elixir,runtime_error,"Line 23: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(3, 0)
    solution.ex:23: anonymous fn/6 in Solution.minimum_cost/5
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:19: anonymous fn/6 in Solution.minimum_cost/5
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    solution.ex:16: anonymous fn/6 in Solution.minimum_cost/5
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    nofile:1: (file)",../questions/Hard\minimum-cost-to-convert-string-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_cost(source :: String.t, target :: String.t, original :: [String.t], changed :: [String.t], cost :: [integer]) :: integer
  def minimum_cost(source, target, original, changed, cost) do
    transform_map = Enum.zip(original, Enum.zip(changed, cost))
    |> Enum.group_by(fn {o, _} -> o end, fn {_, {c, co}} -> {c, co} end)

    dp = for _ <- 0..String.length(source), do: :erlang.make_tuple(String.length(source) + 1, -1)
    dp = List.update_at(dp, 0, fn _ -> :erlang.make_tuple(String.length(source) + 1, 0) end)

    for i <- 0..String.length(source)-1 do
      dp = List.update_at(dp, i + 1, fn _ -> 
        dp_elem = elem(Enum.at(dp, i), i + 1)
        if dp_elem != -1, do: dp_elem, else: 0
      end)

      for j <- i..String.length(source)-1 do
        sub_source = String.slice(source, i, j - i + 1)
        if Map.has_key?(transform_map, sub_source) do
          for {c, co} <- Map.fetch!(transform_map, sub_source) do
            if String.slice(target, i, j - i + 1) == c do
              prev_cost = if elem(Enum.at(dp, i), i) == -1, do: 0, else: elem(Enum.at(dp, i), i)
              new_cost = if prev_cost == -1, do: -1, else: prev_cost + co
              if elem(Enum.at(dp, j + 1), j + 1) == -1 or (new_cost < elem(Enum.at(dp, j + 1), j + 1) and new_cost != -1) do
                dp = List.update_at(dp, j + 1, fn _ -> 
                  :erlang.setelement(i + 1, Enum.at(dp, j + 1), new_cost)
                end)
              end
            end
          end
        end
      end
    end

    if elem(Enum.at(dp, String.length(source)), String.length(source)) == -1, do: -1, else: elem(Enum.at(dp, String.length(source)), String.length(source))
  end
end"
elixir,runtime_error,"Line 6: ** (UndefinedFunctionError) function Array.new/2 is undefined (module Array is not available)
    Array.new(5, #Function<1.93164744/0 in Solution.minimum_cost/5>)
    solution.ex:6: Solution.minimum_cost/5
    solution.ex:59: Driver.consume_test_cases/2
    solution.ex:39: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Hard\minimum-cost-to-convert-string-ii\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_cost(source :: String.t, target :: String.t, original :: [String.t], changed :: [String.t], cost :: [integer]) :: integer
  def minimum_cost(source, target, original, changed, cost) do
    # Create a map of transformations for quick lookup
    transformations = for {o, c, co} <- Enum.zip(original, Enum.zip(changed, cost)), into: %{}, do: {{o, c}, co}
    dp = Array.new(String.length(source) + 1, fn -> Map.new() end)
    dp = Array.set(dp, 0, %{"""" => 0})

    for i <- 0..String.length(source) do
      Enum.each(dp |> Array.get(i), fn {s, cs} ->
        Enum.with_index(target, i-1)
        |> Enum.each(fn {t, j} ->
          if i <= j + 1 do
            to_check = String.slice(target, i-1, j-i+2)
            if Map.has_key?(transformations, {s, to_check}) do
              cost = transformations[{s, to_check}]
              updated_cost = cs + cost
              existing_cost = Map.get(Array.get(dp, j+1), to_check, :infinity)
              if updated_cost < existing_cost do
                new_costs = Map.put(Array.get(dp, j+1), to_check, updated_cost)
                dp = Array.set(dp, j+1, new_costs)
              end
            end
          end
        end)
      end)
    end

    final_costs = Array.get(dp, String.length(target))
    case Map.get(final_costs, target) do
      nil -> -1
      cost -> cost
    end
  end
end"
elixir,runtime_error,"Line 8: ** (ArgumentError) errors were found at the given arguments:
  * 2nd argument: not a tuple
    :erlang.element(2, 2)
    solution.ex:8: Solution.min_operations/2
    solution.ex:38: Driver.consume_test_cases/2
    solution.ex:24: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Hard\minimum-operations-to-form-subsequence-with-target-sum\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_operations(nums :: [integer], target :: integer) :: integer
  def min_operations(nums, target) do
    nums = Enum.sort(nums, :desc)
    {result, _} = Enum.reduce(nums, {0, target}, fn x, {ops, t} ->
      if t == 0, do: {ops, t}, else: reduce_num(x, t, ops)
    end)
    if result > 0 and elem(result, 1) == 0, do: elem(result, 0), else: -1
  end

  defp reduce_num(x, t, ops) when x > t, do: {ops, t}
  defp reduce_num(1, t, ops), do: {ops + 1, t - 1}
  defp reduce_num(x, t, ops) do
    if x <= t, do: {ops + 1, t - x}, else: split_num(x, t, ops)
  end

  defp split_num(x, t, ops) when x > 1 do
    reduce_num(div(x, 2), t, ops + 1)
  end
end"
elixir,runtime_error,"Line 5: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:5: anonymous fn/2 in Solution.minimum_time/3
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:5: Solution.minimum_time/3
    solution.ex:41: Driver.consume_test_cases/2
    solution.ex:25: Driver.start/0
    nofile:1: (file)",../questions/Hard\minimum-time-to-make-array-sum-at-most-x\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_time(nums1 :: [integer], nums2 :: [integer], x :: integer) :: integer
  def minimum_time(nums1, nums2, x) do
    nums_with_index = Enum.with_index(nums1)
    |> Enum.map(fn {n1, idx} -> {n1 + nums2[idx] * 0, idx} end)

    1..length(nums1)
    |> Enum.reduce_while({0, nums_with_index}, fn _, {seconds, nums} ->
      sum = Enum.reduce(nums, 0, fn {n, _}, acc -> n + acc end)
      if sum <= x, do: {:halt, seconds}, else: {:cont, {seconds + 1, update_nums(nums, nums2)}}
    end)
    |> case do
      {seconds, _} when seconds > length(nums1) -> -1
      seconds -> seconds
    end
  end

  defp update_nums(nums, nums2) do
    Enum.map(nums, fn {n, idx} -> {max(n - nums2[idx], 0), idx} end)
  end
end"
elixir,runtime_error,"Line 12: ** (BadArityError) #Function<0.124927518/2 in Solution.can_form_palindrome?/2> with arity 2 called with 1 argument ({""b"", 1})
    (elixir 1.15.7) lib/enum.ex:1590: anonymous fn/3 in Enum.into/3
    (elixir 1.15.7) lib/enum.ex:1590: anonymous fn/3 in Enum.into/3
    (stdlib 5.1.1) maps.erl:416: :maps.fold_1/4
    solution.ex:12: Solution.can_form_palindrome?/2
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:45: Driver.consume_test_cases/2
    solution.ex:31: Driver.start/0
    nofile:1: (file)",../questions/Hard\palindrome-rearrangement-queries\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec can_make_palindrome_queries(s :: String.t, queries :: [[integer]]) :: [boolean]
  def can_make_palindrome_queries(s, queries) do
    queries
    |> Enum.map(fn [ai, bi, ci, di] ->
      {left, right} = {String.slice(s, ai..bi), String.slice(s, ci..di)}
      can_form_palindrome?(left, right)
    end)
  end

  defp can_form_palindrome?(left, right) do
    combined_freqs = frequency(left) |> Enum.into(frequency(right), fn {k, v1}, acc ->
      Map.update(acc, k, v1, &(&1 + v1))
    end)

    odd_counts = Enum.count(combined_freqs, fn {_k, v} -> rem(v, 2) == 1 end)
    odd_counts <= 1
  end

  defp frequency(str) do
    str
    |> String.graphemes()
    |> Enum.reduce(%{}, fn char, acc ->
      Map.update(acc, char, 1, &(&1 + 1))
    end)
  end
end"
elixir,runtime_error,"Line 25: ** (FunctionClauseError) no function clause matching in String.slice/2
    The following arguments were given to String.slice/2:
        # 1
        ""abcd""
        # 2
        -1
    Attempted function clauses (showing 2 out of 2):
        def slice(+string+, -first..last//step = range-) when +is_binary(string)+
        def slice(+string+, -%{__struct__: Range, first: first, last: last} = range-) when +is_binary(string)+
    (elixir 1.15.7) lib/string.ex:2241: String.slice/2
    solution.ex:25: anonymous fn/3 in Solution.number_of_ways/3
    (elixir 1.15.7) lib/enum.ex:4204: Enum.predicate_range/5
    solution.ex:24: Solution.number_of_ways/3
    solution.ex:62: Driver.consume_test_cases/2
    solution.ex:46: Driver.start/0
    nofile:1: (file)",../questions/Hard\string-transformation\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec number_of_ways(s :: String.t(), t :: String.t(), k :: integer()) :: integer()
  def number_of_ways(s, t, k) do
    mod = 1_000_000_007

    if s == t do
      # When s equals t, and k is odd, you can't get s to equal t in k moves
      if rem(k, 2) == 1 do
        0
      else
        # If k is even, there are 2 ways if k is 2 (direct swap or rotate all but one character)
        # For k > 2, it's 2^(k-2) ways for the first k-2 moves, then 2 ways for the last 2 moves
        if k == 2 do
          2
        else
          rem(2 * pow(2, k - 2, mod), mod)
        end
      end
    else
      if k == 1 do
        0
      else
        # When s != t, check if s can be made to equal t in one move
        can_transform_in_one_move = Enum.any?(1..String.length(s)-1, fn i ->
          String.slice(s, -i) <> String.slice(s, 0, String.length(s) - i) == t
        end)

        if can_transform_in_one_move do
          if k == 2 do
            1
          else
            rem(pow(2, k - 2, mod), mod)
          end
        else
          0
        end
      end
    end
  end

  defp pow(a, b, mod), do: :math.pow(a, b) |> round() |> rem(mod)
end"
elixir,runtime_error,"Line 8: ** (ArithmeticError) bad argument in arithmetic expression: nil - 2
    :erlang.-(nil, 2)
    solution.ex:8: anonymous fn/3 in Solution.sum_imbalance_numbers/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:7: anonymous fn/4 in Solution.sum_imbalance_numbers/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:5: anonymous fn/3 in Solution.sum_imbalance_numbers/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    nofile:1: (file)",../questions/Hard\sum-of-imbalance-numbers-of-all-subarrays\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec sum_imbalance_numbers(nums :: [integer]) :: integer
  def sum_imbalance_numbers(nums) do
    Enum.reduce(0..length(nums)-1, 0, fn i, acc ->
      acc + Enum.reduce(i..length(nums)-1, 0, fn j, acc_inner ->
        sarr = Enum.slice(nums, i..j) |> Enum.sort()
        acc_inner + Enum.reduce(0..length(sarr)-2, 0, fn k, acc_imbalance ->
          if Enum.at(sarr, k+1) - Enum.at(sarr, k) > 1, do: acc_imbalance + 1, else: acc_imbalance
        end)
      end)
    end)
  end
end"
elixir,runtime_error,"Line 8: ** (ArithmeticError) bad argument in arithmetic expression: nil - 2
    :erlang.-(nil, 2)
    solution.ex:8: anonymous fn/3 in Solution.sum_imbalance_numbers/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:7: anonymous fn/4 in Solution.sum_imbalance_numbers/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:5: anonymous fn/3 in Solution.sum_imbalance_numbers/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    nofile:1: (file)",../questions/Hard\sum-of-imbalance-numbers-of-all-subarrays\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec sum_imbalance_numbers(nums :: [integer]) :: integer
  def sum_imbalance_numbers(nums) do
    Enum.reduce(0..length(nums)-1, 0, fn i, acc ->
      acc + Enum.reduce(i..length(nums)-1, 0, fn j, acc_inner ->
        sarr = Enum.slice(nums, i..j) |> Enum.sort()
        acc_inner + Enum.reduce(1..length(sarr)-1, 0, fn k, acc_imbalance ->
          if Enum.at(sarr, k) - Enum.at(sarr, k-1) > 1, do: acc_imbalance + 1, else: acc_imbalance
        end)
      end)
    end)
  end
end"
elixir,runtime_error,"Line 5: ** (ArgumentError) errors were found at the given arguments:
  * 1st argument: not a nonempty list
    :erlang.hd([])
    solution.ex:5: anonymous fn/2 in Solution.maximum_sum_of_heights/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:4: Solution.maximum_sum_of_heights/1
    solution.ex:32: Driver.consume_test_cases/2
    solution.ex:20: Driver.start/0
    nofile:1: (file)",../questions/Medium\beautiful-towers-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_sum_of_heights(max_heights :: [integer]) :: integer
  def maximum_sum_of_heights(max_heights) do
    left_max = Enum.reduce(max_heights, [], fn x, acc -> 
      [max(x, hd(acc) || 0) | acc] 
    end) |> Enum.reverse()
    right_max = Enum.reduce(Enum.reverse(max_heights), [], fn x, acc -> 
      [max(x, hd(acc) || 0) | acc] 
    end)

    combined_max = Enum.zip(left_max, Enum.reverse(right_max))
                     |> Enum.map(fn {l, r} -> min(l, r) end)
    
    Enum.sum(combined_max)
  end
end"
elixir,runtime_error,"Line 8: ** (FunctionClauseError) no function clause matching in anonymous fn/1 in Solution.check_strings/2
    The following arguments were given to anonymous fn/1 in Solution.check_strings/2:
        # 1
        ""a""
    solution.ex:8: anonymous fn/1 in Solution.check_strings/2
    (elixir 1.15.7) lib/enum.ex:2333: anonymous fn/3 in Enum.split_with/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-split_with/2-lists^foldl/2-1-""/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.split_with/2
    solution.ex:8: Solution.check_strings/2
    solution.ex:32: Driver.consume_test_cases/2
    solution.ex:18: Driver.start/0
    nofile:1: (file)",../questions/Medium\check-if-strings-can-be-made-equal-with-operations-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  def check_strings(s1, s2) do
    # Split strings into characters
    s1_chars = String.graphemes(s1)
    s2_chars = String.graphemes(s2)

    # Separate even and odd indexed characters
    {s1_even, s1_odd} = Enum.split_with(s1_chars, fn {index, _} -> rem(index, 2) == 0 end)
    {s2_even, s2_odd} = Enum.split_with(s2_chars, fn {index, _} -> rem(index, 2) == 0 end)

    # Sort and compare even and odd indexed characters independently
    Enum.sort(s1_even) == Enum.sort(s2_even) and Enum.sort(s1_odd) == Enum.sort(s2_odd)
  end
end"
elixir,runtime_error,"Line 4: ** (Protocol.UndefinedError) protocol Enumerable not implemented for ""abcdba"" of type BitString
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.map_reduce/3
    (elixir 1.15.7) lib/enum.ex:3841: Enum.with_index/2
    solution.ex:4: Solution.check_strings/2
    solution.ex:30: Driver.consume_test_cases/2
    solution.ex:16: Driver.start/0
    nofile:1: (file)",../questions/Medium\check-if-strings-can-be-made-equal-with-operations-ii\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  def check_strings(s1, s2) do
    # Extract characters at even and odd indices for both strings
    even_s1 = for {char, index} <- Enum.with_index(s1), rem(index, 2) == 0, do: char
    odd_s1 = for {char, index} <- Enum.with_index(s1), rem(index, 2) == 1, do: char
    even_s2 = for {char, index} <- Enum.with_index(s2), rem(index, 2) == 0, do: char
    odd_s2 = for {char, index} <- Enum.with_index(s2), rem(index, 2) == 1, do: char

    # Sort and compare even and odd characters separately
    Enum.sort(even_s1) == Enum.sort(even_s2) and Enum.sort(odd_s1) == Enum.sort(odd_s2)
  end
end"
elixir,runtime_error,"Line 14: ** (UndefinedFunctionError) function Enum.nth/2 is undefined or private
    (elixir 1.15.7) Enum.nth([20, 1, 15], 0)
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:14: Solution.collect_chocolates/2
    solution.ex:6: anonymous fn/4 in Solution.min_cost/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:39: Driver.consume_test_cases/2
    solution.ex:25: Driver.start/0
    nofile:1: (file)",../questions/Medium\collecting-chocolates\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_cost(nums :: [integer], x :: integer) :: integer
  def min_cost(nums, x) do
    Enum.reduce(0..length(nums)-1, Enum.sum(nums), fn i, acc ->
      operation_cost = i * x
      collected_cost = collect_chocolates(nums, i)
      min(acc, collected_cost + operation_cost)
    end)
  end

  defp collect_chocolates(nums, operations) do
    nums
    |> Enum.with_index()
    |> Enum.map(fn {cost, index} ->
      shifted_index = rem(index - operations, length(nums))
      Enum.nth(nums, shifted_index)
    end)
    |> Enum.min()
    |> Kernel.*(length(nums))
  end
end"
elixir,runtime_error,"Line 12: ** (UndefinedFunctionError) function Enum.reduce_with_index/3 is undefined or private. Did you mean:
      * reduce/2
      * reduce/3
      * reduce_while/3
    (elixir 1.15.7) Enum.reduce_with_index([[1, 2], [3, 4]], 1, #Function<2.84577439/3 in Solution.construct_product_matrix/1>)
    solution.ex:12: anonymous fn/3 in Solution.construct_product_matrix/1
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    solution.ex:10: anonymous fn/3 in Solution.construct_product_matrix/1
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    solution.ex:9: Solution.construct_product_matrix/1
    solution.ex:44: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Medium\construct-product-matrix\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec construct_product_matrix(grid :: [[integer]]) :: [[integer]]
  def construct_product_matrix(grid) do
    # Calculate the size of the grid
    n = length(grid)
    m = length(List.first(grid))
    
    # Generate the product matrix
    for i <- 0..(n - 1) do
      for j <- 0..(m - 1) do
        # Calculate the product of all elements except grid[i][j]
        product = Enum.reduce_with_index(grid, 1, fn (row, k, acc) ->
          acc * Enum.reduce_with_index(row, 1, fn (element, l, acc_inner) ->
            if k == i and l == j do
              acc_inner
            else
              rem(acc_inner * element, 12345)
            end
          end)
        end)
        # Store the calculated product modulo 12345
        rem(product, 12345)
      end
      |> Enum.to_list()
    end
    |> Enum.to_list()
  end
end"
elixir,runtime_error,"Line 5: ** (ArithmeticError) bad argument in arithmetic expression: 0 + {1, 2}
    :erlang.+(0, {1, 2})
    solution.ex:5: anonymous fn/5 in Solution.count_interesting_subarrays/3
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:32: Driver.consume_test_cases/2
    solution.ex:16: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\count-of-interesting-subarrays\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec count_interesting_subarrays(nums :: [integer], modulo :: integer, k :: integer) :: integer
  def count_interesting_subarrays(nums, modulo, k) do
    count = Enum.reduce(0..length(nums)-1, 0, fn start, acc ->
      acc + Enum.reduce(start..length(nums)-1, {0, 0}, fn
        end_, {cnt, acc_inner} when rem(cnt, modulo) == k -> {cnt + if(rem(Enum.at(nums, end_), modulo) == k, do: 1, else: 0), acc_inner + 1}
        end_, {cnt, acc_inner} -> {cnt + if(rem(Enum.at(nums, end_), modulo) == k, do: 1, else: 0), acc_inner}
      end) |> elem(1)
    end)
    count
  end
end"
elixir,runtime_error,"Line 5: ** (ArithmeticError) bad argument in arithmetic expression: 0 + {1, 0}
    :erlang.+(0, {1, 0})
    solution.ex:5: anonymous fn/5 in Solution.count_interesting_subarrays/3
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:31: Driver.consume_test_cases/2
    solution.ex:15: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\count-of-interesting-subarrays\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec count_interesting_subarrays(nums :: [integer], modulo :: integer, k :: integer) :: integer
  def count_interesting_subarrays(nums, modulo, k) do
    Enum.reduce(0..length(nums)-1, 0, fn start, acc1 ->
      acc1 + Enum.reduce(start..length(nums)-1, {0, 0}, fn
        end_, {cnt, acc_inner} -> if rem(Enum.at(nums, end_), modulo) == k, do: {cnt + 1, acc_inner}, else: {cnt, acc_inner}
      end)
      |> (fn {cnt, _acc_inner} -> if rem(cnt, modulo) == k, do: 1, else: 0 end).()
    end)
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:6: anonymous fn/5 in Solution.count_pairs/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:5: anonymous fn/4 in Solution.count_pairs/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:30: Driver.consume_test_cases/2
    solution.ex:16: Driver.start/0
    nofile:1: (file)",../questions/Medium\count-pairs-of-points-with-distance-k\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec count_pairs(coordinates :: [[integer]], k :: integer) :: integer
  def count_pairs(coordinates, k) do
    Enum.reduce(0..length(coordinates) - 2, 0, fn i, acc ->
      acc + Enum.reduce(i+1..length(coordinates)-1, 0, fn j, acc_inner ->
        if xor(coordinates[i], coordinates[j]) == k, do: acc_inner + 1, else: acc_inner
      end)
    end)
  end

  defp xor([x1, y1], [x2, y2]), do: Bitwise.bxor(x1, x2) + Bitwise.bxor(y1, y2)
end"
elixir,runtime_error,"Line 40: ** (UndefinedFunctionError) function Enum.none?/2 is undefined or private
    (elixir 1.15.7) Enum.none?([[1, 3], [1, 5]], #Function<3.125524365/1 in Solution.count_servers/4>)
    (elixir 1.15.7) lib/enum.ex:721: anonymous fn/3 in Enum.count/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:40: Driver.consume_test_cases/2
    solution.ex:22: Driver.start/0
    nofile:1: (file)",../questions/Medium\count-zero-request-servers\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec count_servers(n :: integer, logs :: [[integer]], x :: integer, queries :: [integer]) :: [integer]
  def count_servers(n, logs, x, queries) do
    logs_by_server = Enum.group_by(logs, fn [server_id, _time] -> server_id end)
    queries
    |> Enum.map(fn query ->
      Enum.count(1..n, fn server_id ->
        case Map.fetch(logs_by_server, server_id) do
          :error -> true
          {:ok, times} ->
            Enum.none?(times, fn [_server_id, time] ->
              time <= query and time >= query - x
            end)
        end
      end)
    end)
  end
end"
elixir,runtime_error,"Line 5: ** (BadFunctionError) expected a function, got: []
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:5: Solution.minimize_concatenated_length/1
    solution.ex:35: Driver.consume_test_cases/2
    solution.ex:23: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\decremental-string-concatenation\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimize_concatenated_length(words :: [String.t]) :: integer
  def minimize_concatenated_length(words) do
    words
    |> Enum.reduce(fn word, acc -> 
      case acc do
        [] -> [word]
        [h | _] = acc ->
          if String.ends_with?(h, String.first(word)) do
            [String.trim_trailing(h, String.last(h)) <> word | tl(acc)]
          else
            [word | acc]
          end
      end
    end, [])
    |> Enum.reduce("""", &(&1 <> &2))
    |> String.length()
  end
end"
elixir,runtime_error,"Line 6: ** (ArithmeticError) bad argument in arithmetic expression: rem(216.0, 10)
    :erlang.rem(216.0, 10)
    solution.ex:6: anonymous fn/3 in Solution.get_good_indices/2
    (elixir 1.15.7) lib/enum.ex:1121: anonymous fn/3 in Enum.filter/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:2514: Enum.filter/2
    solution.ex:27: Driver.consume_test_cases/2
    solution.ex:13: Driver.start/0
    nofile:1: (file)",../questions/Medium\double-modular-exponentiation\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec get_good_indices(variables :: [[integer]], target :: integer) :: [integer]
  def get_good_indices(variables, target) do
    Enum.filter(0..(length(variables) - 1), fn i ->
      [a, b, c, m] = Enum.at(variables, i)
      rem(rem(a * b, 10) |> :math.pow(c), m) == target
    end)
  end
end"
elixir,runtime_error,"Line 10: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:10: anonymous fn/4 in Solution.min_extra_char/2
    (elixir 1.15.7) lib/enum.ex:984: Enum.""-each/2-lists^foreach/1-0-""/2
    solution.ex:7: anonymous fn/5 in Solution.min_extra_char/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:6: Solution.min_extra_char/2
    solution.ex:40: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Medium\extra-characters-in-a-string\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  def min_extra_char(s, dictionary) do
    dp = for _ <- 0..String.length(s), do: nil
    dp = List.replace_at(dp, 0, 0)

    for i <- 0..(String.length(s) - 1) do
      Enum.each(dictionary, fn word ->
        if String.starts_with?(String.slice(s, i..-1), word) do
          j = i + String.length(word)
          if dp[i] != nil do
            dp = if dp[j] == nil, do: List.replace_at(dp, j, dp[i]), else: List.replace_at(dp, j, min(dp[i], dp[j]))
          end
        end
      end)
    end

    String.length(s) - Enum.reduce(dp, 0, fn
      nil, acc -> acc
      x, acc when not is_nil(x) -> max(acc, x)
    end)
  end
end"
elixir,runtime_error,"Line 5: ** (UndefinedFunctionError) function Bitwise.popcount/1 is undefined or private
    (elixir 1.15.7) Bitwise.popcount(15)
    (elixir 1.15.7) lib/enum.ex:1410: anonymous fn/4 in Enum.group_by/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-group_by/3-lists^foldl/2-0-""/3
    solution.ex:5: Solution.can_sort_array/1
    solution.ex:31: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)",../questions/Medium\find-if-array-can-be-sorted\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec can_sort_array(nums :: [integer]) :: boolean
  def can_sort_array(nums) do
    nums
    |> Enum.group_by(&Bitwise.popcount/1)
    |> Enum.map(fn {_bit_count, values} -> Enum.sort(values) end)
    |> Enum.concat()
    |> Enum.reduce({true, nil}, fn
      x, {true, nil} -> {true, x}
      x, {true, prev} when x >= prev -> {true, x}
      _, _ -> {false, nil}
    end)
    |> elem(0)
  end
end"
elixir,runtime_error,"Line 16: ** (UndefinedFunctionError) function Kernel.bor/2 is undefined or private
    (elixir 1.15.7) Kernel.bor(15, 1)
    solution.ex:16: Solution.bit_count/1
    (elixir 1.15.7) lib/enum.ex:1410: anonymous fn/4 in Enum.group_by/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-group_by/3-lists^foldl/2-0-""/3
    solution.ex:5: Solution.can_sort_array/1
    solution.ex:33: Driver.consume_test_cases/2
    solution.ex:21: Driver.start/0
    nofile:1: (file)",../questions/Medium\find-if-array-can-be-sorted\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec can_sort_array(nums :: [integer]) :: boolean
  def can_sort_array(nums) do
    nums
    |> Enum.group_by(&bit_count/1)
    |> Enum.map(fn {_bit_count, values} -> Enum.sort(values) end)
    |> Enum.concat()
    |> Enum.reduce({true, nil}, fn
      x, {true, nil} -> {true, x}
      x, {true, prev} when x >= prev -> {true, x}
      _, _ -> {false, nil}
    end)
    |> elem(0)
  end

  defp bit_count(num), do: :math.log2(num |> Kernel.bor(1)) |> floor() |> Kernel.to_string() |> String.length()
end"
elixir,runtime_error,"Line 33: ** (BadFunctionError) expected a function, got: [-1, -1]
    (elixir 1.15.7) lib/enum.ex:4279: Enum.find_list/3
    (elixir 1.15.7) lib/enum.ex:4279: Enum.find_list/3
    solution.ex:33: Driver.consume_test_cases/2
    solution.ex:17: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\find-indices-with-index-and-value-difference-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]
  def find_indices(nums, index_difference, value_difference) do
    0..(length(nums) - 1)
    |> Enum.flat_map(fn i ->
      Enum.filter(0..(length(nums) - 1), fn j ->
        abs(i - j) >= index_difference and abs(Enum.at(nums, i) - Enum.at(nums, j)) >= value_difference
      end)
      |> Enum.map(&[i, &1])
    end)
    |> Enum.find(&(&1), [-1, -1])
  end
end"
elixir,runtime_error,"Line 5: ** (FunctionClauseError) no function clause matching in Enumerable.List.reduce/3
    The following arguments were given to Enumerable.List.reduce/3:
        # 1
        [{1, 1}, {4, 2}, {1, 3}]
        # 2
        {[0, 3]}
        # 3
        #Function<0.112424465/2 in Solution.find_indices/3>
    Attempted function clauses (showing 4 out of 4):
        def reduce(+_list+, -{:halt, acc}-, +_fun+)
        def reduce(+list+, -{:suspend, acc}-, +fun+)
        def reduce(-[]-, -{:cont, acc}-, +_fun+)
        def reduce(+[head | tail]+, -{:cont, acc}-, +fun+)
    (elixir 1.15.7) lib/enum.ex:4827: Enumerable.List.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:5: Solution.find_indices/3
    solution.ex:46: Driver.consume_test_cases/2
    solution.ex:30: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\find-indices-with-index-and-value-difference-ii\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_indices(nums :: [integer], index_difference :: integer, value_difference :: integer) :: [integer]
  def find_indices(nums, index_difference, value_difference) do
    Enum.with_index(nums)
    |> Enum.reduce_while([], fn {num, idx}, acc ->
      case acc do
        [] ->
          Enum.with_index(nums)
          |> Enum.find_value([], fn {other_num, other_idx} ->
            if idx != other_idx and
               abs(idx - other_idx) >= index_difference and
               abs(num - other_num) >= value_difference do
              {[idx, other_idx]}
            else
              nil
            end
          end)
        acc -> {:halt, acc}
      end
    end)
    |> case do
      [] -> [-1, -1]
      acc -> acc
    end
  end
end"
elixir,runtime_error,"Line 14: ** (MatchError) no match of right hand side value: ~c""aa""
    solution.ex:14: Solution.valid_special_substring?/2
    solution.ex:7: anonymous fn/4 in Solution.maximum_length/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:4: Solution.maximum_length/1
    solution.ex:34: Driver.consume_test_cases/2
    solution.ex:22: Driver.start/0
    nofile:1: (file)",../questions/Medium\find-longest-special-substring-that-occurs-thrice-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_length(s :: String.t) :: integer
  def maximum_length(s) do
    max_length = Enum.reduce(0..String.length(s)-1, -1, fn start, acc ->
      Enum.reduce(start..String.length(s)-1, acc, fn finish, acc_inner ->
        substring = String.slice(s, start, finish - start + 1)
        if valid_special_substring?(substring, s), do: max(acc_inner, String.length(substring)), else: acc_inner
      end)
    end)
    if max_length >= 3, do: max_length, else: -1
  end

  defp valid_special_substring?(substring, s) do
    [char] = String.to_charlist(substring)
    regex = ~r/#{char}{#{String.length(substring)}}/
    Regex.scan(regex, s) |> length() >= 3
  end
end"
elixir,runtime_error,"Line 6: ** (UndefinedFunctionError) function Map.fold/2 is undefined or private
    (elixir 1.15.7) Map.fold(%{""a"" => [1]}, #Function<2.82754278/3 in Solution.maximum_length/1>)
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:6: Solution.maximum_length/1
    solution.ex:32: Driver.consume_test_cases/2
    solution.ex:20: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\find-longest-special-substring-that-occurs-thrice-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_length(s :: String.t) :: integer
  def maximum_length(s) do
    s
    |> String.graphemes()
    |> Enum.reduce({%{}, 0}, fn
      x, {acc, max_len} ->
        Map.update(acc, x, [1], fn [count] -> [count + 1] end)
        |> Map.fold(fn k, [v], {acc_inner, max_inner} ->
          if v >= 3, do: {acc_inner, max(max_inner, String.length(Enum.join_for(1..v, fn _ -> k end)))}, else: {acc_inner, max_inner}
        end)
    end)
    |> elem(1)
    |> (fn max_len -> if max_len > 0, do: max_len, else: -1 end).()
  end
end"
elixir,runtime_error,"Line 6: ** (FunctionClauseError) no function clause matching in anonymous fn/2 in Solution.largest_perimeter/1
    The following arguments were given to anonymous fn/2 in Solution.largest_perimeter/1:
        # 1
        5
        # 2
        {0, []}
    solution.ex:6: anonymous fn/2 in Solution.largest_perimeter/1
    (elixir 1.15.7) lib/enum.ex:4830: Enumerable.List.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:6: Solution.largest_perimeter/1
    solution.ex:30: Driver.consume_test_cases/2
    solution.ex:18: Driver.start/0
    nofile:1: (file)",../questions/Medium\find-polygon-with-the-largest-perimeter\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec largest_perimeter(nums :: [integer]) :: integer
  def largest_perimeter(nums) do
    nums
    |> Enum.sort(:desc)
    |> Enum.reduce_while({0, []}, fn x, {acc, [a, b | rest]} ->
      if a + b > x, do: {:halt, a + b + x}, else: {:cont, {0, [x, a, b | rest]}}
    end)
    |> case do
      {_, _} -> -1
      perimeter -> perimeter
    end
  end
end"
elixir,runtime_error,"Line 10: ** (Protocol.UndefinedError) protocol Enumerable not implemented for 5 of type Integer
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:3505: Enum.take/2
    solution.ex:10: anonymous fn/2 in Solution.largest_perimeter/1
    (elixir 1.15.7) lib/enum.ex:4830: Enumerable.List.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:31: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Medium\find-polygon-with-the-largest-perimeter\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec largest_perimeter(nums :: [integer]) :: integer
  def largest_perimeter(nums) do
    nums
    |> Enum.sort(:desc)
    |> Enum.reduce_while(-1, fn x, acc ->
      case acc do
        -1 -> {:cont, x}
        _ -> 
          [a, b | _] = Enum.take(acc, 2)
          if a + b > x, do: {:halt, a + b + x}, else: {:cont, [x | acc]}
      end
    end)
  end
end"
elixir,runtime_error,"Line 9: ** (FunctionClauseError) no function clause matching in String.graphemes/1
    The following arguments were given to String.graphemes/1:
        # 1
        [""2"", ""2"", ""3"", ""3""]
    Attempted function clauses (showing 1 out of 1):
        def graphemes(+string+) when -is_binary(string)-
    (elixir 1.15.7) lib/string.ex:1934: String.graphemes/1
    solution.ex:9: Solution.longest/6
    solution.ex:43: Driver.consume_test_cases/2
    solution.ex:31: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\find-the-longest-semi-repetitive-substring\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec longest_semi_repetitive_substring(s :: String.t) :: integer
  def longest_semi_repetitive_substring(s) do
    longest(s, 0, 0, 0, nil, false)
  end

  defp longest("""", max_len, _, _, _, _), do: max_len
  defp longest(s, max_len, cur_len, rep_count, prev_char, has_pair) do
    [cur_char | rest] = String.graphemes(s)
    new_len = 
      if cur_char == prev_char do
        if rep_count == 1 && !has_pair do
          cur_len + 1
        else
          1
        end
      else
        cur_len + 1
      end

    new_max_len = max(max_len, new_len)
    new_rep_count = if cur_char == prev_char, do: rep_count + 1, else: 1
    new_has_pair = has_pair || new_rep_count == 2

    longest(rest, new_max_len, new_len, new_rep_count, cur_char, new_has_pair)
  end
end"
elixir,runtime_error,"Line 5: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:5: anonymous fn/2 in Solution.find_value_of_partition/1
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    solution.ex:5: Solution.find_value_of_partition/1
    solution.ex:24: Driver.consume_test_cases/2
    solution.ex:12: Driver.start/0
    nofile:1: (file)",../questions/Medium\find-the-value-of-the-partition\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_value_of_partition(nums :: [integer]) :: integer
  def find_value_of_partition(nums) do
    sorted = Enum.sort(nums)
    min_diffs = for i <- 1..(length(sorted)-1), do: abs(sorted[i-1] - sorted[i])
    Enum.min(min_diffs)
  end
end"
elixir,runtime_error,"Line 12: ** (FunctionClauseError) no function clause matching in :lists.max/2
    The following arguments were given to :lists.max/2:
        # 1
        2
        # 2
        3
    (stdlib 5.1.1) lists.erl:367: :lists.max/2
    solution.ex:12: Solution.max_array_value_helper/1
    solution.ex:31: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\largest-element-in-an-array-after-merge-operations\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_array_value(nums :: [integer]) :: integer
  def max_array_value(nums) do
    max_array_value_helper(Enum.reverse(nums))
  end

  defp max_array_value_helper([head | []]), do: head
  defp max_array_value_helper([first, second | tail]) when second >= first do
    max_array_value_helper([first + second | tail])
  end
  defp max_array_value_helper([first | tail]) do
    [first | max_array_value_helper(tail)]
    |> Enum.max()
  end
end"
elixir,runtime_error,"Line 8: ** (UndefinedFunctionError) function Integer.max/2 is undefined or private
    (elixir 1.15.7) Integer.max(-1, 1)
    (elixir 1.15.7) lib/map.ex:676: Map.update/4
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:8: anonymous fn/4 in Solution.length_of_longest_subsequence/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:7: Solution.length_of_longest_subsequence/2
    solution.ex:37: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Medium\length-of-the-longest-subsequence-that-sums-to-target\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec length_of_longest_subsequence(nums :: [integer], target :: integer) :: integer
  def length_of_longest_subsequence(nums, target) do
    dp = :maps.from_list(Enum.map(0..target, fn x -> {x, -1} end))
    dp = Map.put(dp, 0, 0)

    for num <- nums do
      dp = Enum.reduce(Map.keys(dp), dp, fn key, acc ->
        if key + num <= target and acc[key] != -1 do
          Map.update(acc, key + num, acc[key] + 1, &Integer.max(&1, acc[key] + 1))
        else
          acc
        end
      end)
    end

    dp[target]
  end
end"
elixir,runtime_error,"Line 4: ** (ArgumentError) argument error
    (stdlib 5.1.1) :maps.from_list([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1])
    solution.ex:4: Solution.length_of_longest_subsequence/2
    solution.ex:38: Driver.consume_test_cases/2
    solution.ex:24: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\length-of-the-longest-subsequence-that-sums-to-target\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec length_of_longest_subsequence(nums :: [integer], target :: integer) :: integer
  def length_of_longest_subsequence(nums, target) do
    dp = for _ <- 0..target, do: -1, into: %{}
    dp = Map.put(dp, 0, 0)

    for num <- nums, reduce: dp do
      acc ->
        Enum.reduce(acc, acc, fn {k, v}, acc2 ->
          if k + num <= target and v >= 0 do
            Map.update(acc2, k + num, v + 1, &Kernel.max(&1, v + 1))
          else
            acc2
          end
        end)
    end

    Map.get(dp, target, -1)
  end
end"
elixir,runtime_error,"Line 10: ** (FunctionClauseError) no function clause matching in Solution.char_shift/1
    The following arguments were given to Solution.char_shift/1:
        # 1
        99
    solution.ex:10: Solution.char_shift/1
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:6: Solution.smallest_string/1
    solution.ex:28: Driver.consume_test_cases/2
    solution.ex:16: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\lexicographically-smallest-string-after-substring-operation\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec smallest_string(s :: String.t) :: String.t
  def smallest_string(s) do
    s
    |> String.to_charlist()
    |> Enum.map(&char_shift/1)
    |> List.to_string()
  end

  defp char_shift(char) when char > 'a', do: char - 1
  defp char_shift('a'), do: 'z'
end"
elixir,runtime_error,"Line 11: ** (FunctionClauseError) no function clause matching in String.slice/2
    The following arguments were given to String.slice/2:
        # 1
        ""cbabc""
        # 2
        1
    Attempted function clauses (showing 2 out of 2):
        def slice(+string+, -first..last//step = range-) when +is_binary(string)+
        def slice(+string+, -%{__struct__: Range, first: first, last: last} = range-) when +is_binary(string)+
    (elixir 1.15.7) lib/string.ex:2241: String.slice/2
    solution.ex:11: anonymous fn/3 in Solution.smallest_string/1
    (elixir 1.15.7) lib/enum.ex:4830: Enumerable.List.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:33: Driver.consume_test_cases/2
    solution.ex:21: Driver.start/0
    nofile:1: (file)",../questions/Medium\lexicographically-smallest-string-after-substring-operation\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec smallest_string(s :: String.t) :: String.t
  def smallest_string(s) do
    s
    |> String.graphemes()
    |> Enum.with_index()
    |> Enum.reduce_while("""", fn {char, index}, acc ->
      new_char = 
        if index == 0 or (char != ""a"" and acc <> String.at(s, index - 1) < char), do: shift_char(char), else: char
        
      if new_char < char, do: {:halt, acc <> new_char <> String.slice(s, index + 1)}, else: {:cont, acc <> char}
    end)
  end

  defp shift_char(""a""), do: ""z""
  defp shift_char(char), do: String.to_charlist(char) |> Enum.map(&(&1 - 1)) |> List.to_string()
end"
elixir,runtime_error,"Line 7: ** (ArgumentError) ranges (first..last) expect both sides to be integers, got: ""c""..""c""
    (elixir 1.15.7) lib/range.ex:193: Range.new/2
    solution.ex:7: anonymous fn/3 in Solution.smallest_string/1
    (elixir 1.15.7) lib/enum.ex:4830: Enumerable.List.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:33: Driver.consume_test_cases/2
    solution.ex:21: Driver.start/0
    nofile:1: (file)",../questions/Medium\lexicographically-smallest-string-after-substring-operation\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec smallest_string(s :: String.t) :: String.t
  def smallest_string(s) do
    s
    |> String.graphemes()
    |> Enum.reduce_while("""", fn char, acc ->
      if char == ""a"", do: {:cont, acc <> ""a""}, else: {:halt, acc <> Enum.map_join(char..char, """", &shift_char/1) <> String.slice(s, String.length(acc) + 1)}
    end)
  end

  defp shift_char(""a""), do: ""z""
  defp shift_char(char) do
    [char]
    |> Enum.map(&(&1 - 1))
    |> List.to_string()
  end
end"
elixir,runtime_error,"Line 12: ** (ArgumentError) the Access module does not support accessing lists by index, got: 1
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:12: anonymous fn/5 in Solution.max_non_decreasing_length/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:8: Solution.max_non_decreasing_length/2
    solution.ex:56: Driver.consume_test_cases/2
    solution.ex:42: Driver.start/0
    nofile:1: (file)",../questions/Medium\longest-non-decreasing-subarray-from-two-arrays\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec max_non_decreasing_length(nums1 :: [integer], nums2 :: [integer]) :: integer
  def max_non_decreasing_length(nums1, nums2) do
    n = length(nums1)
    dp = :array.new(n, default: {0, 0})
    dp = :array.set(0, {1, 1}, dp)

    for i <- 1..n-1 do
      {prev1, prev2} = :array.get(i-1, dp)
      {cur1, cur2} = {1, 1}

      if nums1[i] >= nums1[i-1] do
        cur1 = max(cur1, prev1 + 1)
      end

      if nums2[i] >= nums2[i-1] do
        cur2 = max(cur2, prev2 + 1)
      end

      if nums1[i] >= nums2[i-1] do
        cur1 = max(cur1, prev2 + 1)
      end

      if nums2[i] >= nums1[i-1] do
        cur2 = max(cur2, prev1 + 1)
      end

      dp = :array.set(i, {cur1, cur2}, dp)
    end

    max_vals = Enum.map(0..n-1, fn i -> 
      {v1, v2} = :array.get(i, dp)
      max(v1, v2)
    end)

    Enum.max(max_vals)
  end
end"
elixir,runtime_error,"Line 11: ** (ArgumentError) the Access module does not support accessing lists by index, got: 1
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:11: anonymous fn/4 in Solution.max_non_decreasing_length/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:9: Solution.max_non_decreasing_length/2
    solution.ex:40: Driver.consume_test_cases/2
    solution.ex:26: Driver.start/0
    nofile:1: (file)",../questions/Medium\longest-non-decreasing-subarray-from-two-arrays\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec max_non_decreasing_length(nums1 :: [integer], nums2 :: [integer]) :: integer
  def max_non_decreasing_length(nums1, nums2) do
    len = length(nums1)
    dp = Enum.map(0..len-1, fn _ -> {0, 0} end)

    dp = List.replace_at(dp, 0, {1, 1})

    dp = Enum.reduce(1..len-1, dp, fn i, acc ->
      {prev1, prev2} = Enum.at(acc, i - 1)
      cur1 = if nums1[i] >= nums1[i - 1], do: prev1 + 1, else: 1
      cur2 = if nums2[i] >= nums2[i - 1], do: prev2 + 1, else: 1
      cur1 = if nums1[i] >= nums2[i - 1], do: max(cur1, prev2 + 1), else: cur1
      cur2 = if nums2[i] >= nums1[i - 1], do: max(cur2, prev1 + 1), else: cur2
      List.replace_at(acc, i, {cur1, cur2})
    end)

    dp
    |> Enum.map(fn {a, b} -> max(a, b) end)
    |> Enum.max()
  end
end"
elixir,runtime_error,"Line 4: ** (ArgumentError) the Access module does not support accessing lists by index, got: 1
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:4: anonymous fn/2 in Solution.get_words_in_longest_subsequence/3
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    solution.ex:4: Solution.get_words_in_longest_subsequence/3
    solution.ex:28: Driver.consume_test_cases/2
    solution.ex:12: Driver.start/0
    nofile:1: (file)",../questions/Medium\longest-unequal-adjacent-groups-subsequence-i\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]
  def get_words_in_longest_subsequence(n, words, groups) do
    indices = for i <- 1..n-1, do: if groups[i] != groups[i-1], do: i, else: nil
    indices = [0 | indices] |> Enum.filter(&(&1 != nil))
    Enum.map(indices, fn i -> words[i] end)
  end
end"
elixir,runtime_error,"Line 5: ** (ArgumentError) the Access module does not support accessing lists by index, got: 1
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:5: anonymous fn/3 in Solution.get_words_in_longest_subsequence/3
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:4: Solution.get_words_in_longest_subsequence/3
    solution.ex:29: Driver.consume_test_cases/2
    solution.ex:13: Driver.start/0
    nofile:1: (file)",../questions/Medium\longest-unequal-adjacent-groups-subsequence-i\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]
  def get_words_in_longest_subsequence(n, words, groups) do
    indices = Enum.reduce(1..n-1, [0], fn i, acc ->
      if groups[i] != groups[Enum.at(acc, -1)], do: acc ++ [i], else: acc
    end)
    Enum.map(indices, &Enum.at(words, &1))
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:6: anonymous fn/5 in Solution.get_words_in_longest_subsequence/3
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:4: Solution.get_words_in_longest_subsequence/3
    solution.ex:42: Driver.consume_test_cases/2
    solution.ex:26: Driver.start/0
    nofile:1: (file)",../questions/Medium\longest-unequal-adjacent-groups-subsequence-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec get_words_in_longest_subsequence(n :: integer, words :: [String.t], groups :: [integer]) :: [String.t]
  def get_words_in_longest_subsequence(n, words, groups) do
    Enum.reduce(0..n-2, [], fn i, acc ->
      Enum.reduce(i+1..n-1, acc, fn j, acc_inner ->
        if groups[i] != groups[j] and String.length(words[i]) == String.length(words[j]) and hamming_distance(words[i], words[j]) == 1 do
          [words[i], words[j]] |> Enum.concat(acc_inner) |> Enum.uniq()
        else
          acc_inner
        end
      end)
    end)
    |> Enum.chunk_every(2)
    |> Enum.max_by(&length/1, [])
  end

  defp hamming_distance(s1, s2) do
    String.codepoints(s1)
    |> Enum.zip(String.codepoints(s2))
    |> Enum.count(fn {a, b} -> a != b end)
  end
end"
elixir,runtime_error,"Line 12: ** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 1} of type Tuple
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.sort/2
    solution.ex:12: anonymous fn/3 in Solution.lexicographically_smallest_array/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:37: Driver.consume_test_cases/2
    solution.ex:23: Driver.start/0
    nofile:1: (file)",../questions/Medium\make-lexicographically-smallest-array-by-swapping-elements\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec lexicographically_smallest_array(nums :: [integer], limit :: integer) :: [integer]
  def lexicographically_smallest_array(nums, limit) do
    nums
    |> Enum.with_index()
    |> Enum.sort_by(fn {num, _index} -> num end)
    |> Enum.map(fn {_num, index} -> index end)
    |> Enum.reduce(nums, fn index, acc ->
      smallest = Enum.min_by(acc, fn x -> x end)
      if abs(Enum.at(acc, index) - smallest) <= limit do
        {Enum.at(acc, index), smallest}
        |> Enum.sort()
        |> (fn [a, b] -> List.replace_at(List.replace_at(acc, index, b), Enum.find_index(acc, fn x -> x == smallest end), a) end).()
      else
        acc
      end
    end)
  end
end"
elixir,runtime_error,"Line 7: ** (FunctionClauseError) no function clause matching in Solution.check_subsequence/3
    The following arguments were given to Solution.check_subsequence/3:
        # 1
        ""abc""
        # 2
        ""ad""
        # 3
        false
    solution.ex:7: Solution.check_subsequence/3
    solution.ex:41: Driver.consume_test_cases/2
    solution.ex:27: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\make-string-a-subsequence-using-cyclic-increments\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec can_make_subsequence(str1 :: String.t, str2 :: String.t) :: boolean
  def can_make_subsequence(str1, str2) do
    check_subsequence(str1, str2, false)
  end

  defp check_subsequence(_str1, """", _changed), do: true

  defp check_subsequence("""", _str2, _changed), do: false

  defp check_subsequence([h1 | t1], [h2 | t2] = str2, changed) when h1 == h2 do
    check_subsequence(t1, t2, changed)
  end

  defp check_subsequence([h1 | t1], [h2 | t2] = str2, false) do
    next_char = if h1 === 'z', do: 'a', else: <<h1 + 1>>
    if next_char === h2, do: check_subsequence(t1, t2, true), else: check_subsequence(t1, str2, false)
  end

  defp check_subsequence([_ | t1], str2, true) do
    check_subsequence(t1, str2, true)
  end
end"
elixir,runtime_error,"Line 8: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:8: anonymous fn/4 in Solution.maximum_beauty/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:7: Solution.maximum_beauty/2
    solution.ex:35: Driver.consume_test_cases/2
    solution.ex:21: Driver.start/0
    nofile:1: (file)",../questions/Medium\maximum-beauty-of-an-array-after-applying-operation\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec maximum_beauty(nums :: [integer], k :: integer) :: integer
  def maximum_beauty(nums, k) do
    nums = Enum.map(nums, &(&1 - k))
    |> Enum.sort()

    max_beauty = Enum.reduce(nums, {0, 0}, fn x, {max_beauty, first} ->
      if x - nums[first] > 2 * k do
        {max_beauty, first + 1}
      else
        {max(max_beauty, Enum.count(first..(length(nums) - 1))), first}
      end
    end)

    elem(max_beauty, 0)
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:6: anonymous fn/5 in Solution.max_number_of_alloys/6
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:4: Solution.max_number_of_alloys/6
    solution.ex:41: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)",../questions/Medium\maximum-number-of-alloys\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec max_number_of_alloys(n :: integer, k :: integer, budget :: integer, composition :: [[integer]], stock :: [integer], cost :: [integer]) :: integer
  def max_number_of_alloys(n, k, budget, composition, stock, cost) do
    Enum.map(composition, fn machine ->
      Enum.reduce(0..n-1, budget, fn i, acc ->
        needed = Enum.at(machine, i) * max(0, -stock[i])
        acc - needed * Enum.at(cost, i)
      end)
    end)
    |> Enum.map(fn remaining_budget ->
      if remaining_budget < 0, do: 0, else: div(remaining_budget, Enum.min(Enum.zip_with(composition, cost, fn comp, c -> Enum.sum(Enum.map(comp, &(&1 * c))) end)))
    end)
    |> Enum.max()
  end
end"
elixir,runtime_error,"Line 12: ** (ArithmeticError) bad argument in arithmetic expression: {:cont, 0} + 1
    :erlang.+({:cont, 0}, 1)
    solution.ex:12: anonymous fn/6 in Solution.max_number_of_alloys/6
    (elixir 1.15.7) lib/range.ex:526: Enumerable.Range.reduce/5
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:6: anonymous fn/5 in Solution.max_number_of_alloys/6
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    solution.ex:4: Solution.max_number_of_alloys/6
    nofile:1: (file)",../questions/Medium\maximum-number-of-alloys\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_number_of_alloys(n :: integer, k :: integer, budget :: integer, composition :: [[integer]], stock :: [integer], cost :: [integer]) :: integer
  def max_number_of_alloys(_n, k, budget, composition, stock, cost) do
    Enum.map(0..k-1, fn machine_index ->
      machine_composition = Enum.at(composition, machine_index)
      max_alloys = Enum.reduce_while(1..budget, {:cont, 0}, fn _alloy_attempt, acc ->
        total_cost = Enum.reduce(0..Enum.count(machine_composition)-1, 0, fn i, cost_acc ->
          metal_needed = Enum.at(machine_composition, i) - Enum.at(stock, i, 0)
          metal_needed = if metal_needed > 0, do: metal_needed, else: 0
          cost_acc + metal_needed * Enum.at(cost, i)
        end)
        if total_cost <= budget, do: {:cont, acc + 1}, else: {:halt, acc}
      end)
      |> elem(1)
    end)
    |> Enum.max()
  end
end"
elixir,runtime_error,"Line 7: ** (UndefinedFunctionError) function Enum.values/1 is undefined or private
    (elixir 1.15.7) Enum.values(%{1 => 6, 2 => 2})
    solution.ex:7: Solution.maximum_set_size/2
    solution.ex:30: Driver.consume_test_cases/2
    solution.ex:16: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\maximum-size-of-a-set-after-removals\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_set_size(nums1 :: [integer], nums2 :: [integer]) :: integer
  def maximum_set_size(nums1, nums2) do
    nums1
    |> Enum.concat(nums2)
    |> Enum.frequencies()
    |> Enum.values()
    |> Enum.sort(:desc)
    |> Enum.with_index()
    |> Enum.reduce(0, fn {freq, idx}, acc -> acc + Enum.min([freq, div(length(nums1), 2) - idx]) end)
  end
end"
elixir,runtime_error,"Line 11: ** (UndefinedFunctionError) function Map.from_list/1 is undefined or private. Did you mean:
      * from_keys/2
      * from_struct/1
      * to_list/1
    (elixir 1.15.7) Map.from_list([{1, 1}, {2, 1}, {1, 1}, {2, 1}])
    solution.ex:11: Solution.maximum_set_size/2
    solution.ex:31: Driver.consume_test_cases/2
    solution.ex:17: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\maximum-size-of-a-set-after-removals\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec maximum_set_size(nums1 :: [integer], nums2 :: [integer]) :: integer
  def maximum_set_size(nums1, nums2) do
    nums1
    |> Enum.concat(nums2)
    |> Enum.frequencies()
    |> Map.values()
    |> Enum.sort(:desc)
    |> Enum.take(div(length(nums1), 2))
    |> Enum.sum()
    |> Kernel.+(Enum.count(Map.from_list(Enum.zip(nums1, nums2)) |> Map.keys()))
  end
end"
elixir,runtime_error,"Line 5: ** (UndefinedFunctionError) function Enum.each_cons/2 is undefined or private. Did you mean:
      * each/2
    (elixir 1.15.7) Enum.each_cons([2, 6, 7, 3, 1, 7], 4)
    solution.ex:5: Solution.max_sum/3
    solution.ex:30: Driver.consume_test_cases/2
    solution.ex:14: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\maximum-sum-of-almost-unique-subarray\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec max_sum(nums :: [integer], m :: integer, k :: integer) :: integer
  def max_sum(nums, m, k) do
    nums
    |> Enum.each_cons(k)
    |> Enum.filter(fn subarray -> Enum.uniq(subarray) |> length() >= m end)
    |> Enum.map(&Enum.sum/1)
    |> Enum.max(0)
  end
end"
elixir,runtime_error,"Line 32: ** (FunctionClauseError) no function clause matching in Enum.max_sort_fun/1
    The following arguments were given to Enum.max_sort_fun/1:
        # 1
        0
    Attempted function clauses (showing 2 out of 2):
        defp max_sort_fun(+sorter+) when -is_function(sorter, 2)-
        defp max_sort_fun(+module+) when -is_atom(module)-
    (elixir 1.15.7) lib/enum.ex:1898: Enum.max_sort_fun/1
    (elixir 1.15.7) lib/enum.ex:1895: Enum.max/3
    solution.ex:32: Driver.consume_test_cases/2
    solution.ex:16: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\maximum-sum-of-almost-unique-subarray\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec max_sum(nums :: [integer], m :: integer, k :: integer) :: integer
  def max_sum(nums, m, k) do
    nums
    |> Enum.with_index()
    |> Enum.filter(fn {_, index} -> index <= length(nums) - k end)
    |> Enum.map(fn {_, index} -> Enum.slice(nums, index, k) end)
    |> Enum.filter(fn subarray -> Enum.uniq(subarray) |> length() >= m end)
    |> Enum.map(&Enum.sum/1)
    |> Enum.max(0)
  end
end"
elixir,runtime_error,"Line 30: ** (FunctionClauseError) no function clause matching in Enum.max_sort_fun/1
    The following arguments were given to Enum.max_sort_fun/1:
        # 1
        0
    Attempted function clauses (showing 2 out of 2):
        defp max_sort_fun(+sorter+) when -is_function(sorter, 2)-
        defp max_sort_fun(+module+) when -is_atom(module)-
    (elixir 1.15.7) lib/enum.ex:1898: Enum.max_sort_fun/1
    (elixir 1.15.7) lib/enum.ex:1895: Enum.max/3
    solution.ex:30: Driver.consume_test_cases/2
    solution.ex:14: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\maximum-sum-of-almost-unique-subarray\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_sum(nums :: [integer], m :: integer, k :: integer) :: integer
  def max_sum(nums, m, k) do
    0..(length(nums) - k)
    |> Enum.map(fn i -> Enum.slice(nums, i, k) end)
    |> Enum.filter(fn subarray -> Enum.uniq(subarray) |> length() >= m end)
    |> Enum.map(&Enum.sum/1)
    |> Enum.max(0)
  end
end"
elixir,runtime_error,"Line 7: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:7: anonymous fn/5 in Solution.maximum_triplet_value/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:29: Driver.consume_test_cases/2
    solution.ex:17: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\maximum-value-of-an-ordered-triplet-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec maximum_triplet_value(nums :: [integer]) :: integer
  def maximum_triplet_value(nums) do
    Enum.reduce(0..length(nums)-1, 0, fn i, acc ->
      Enum.reduce(i+1..length(nums)-1, acc, fn j, acc_inner ->
        Enum.reduce(j+1..length(nums)-1, acc_inner, fn k, acc_inner_inner ->
          max = max(acc_inner_inner, (nums[i] - nums[j]) * nums[k])
          if max > acc_inner_inner, do: max, else: acc_inner_inner
        end)
      end)
    end)
  end
end"
elixir,runtime_error,"Line 7: ** (Protocol.UndefinedError) protocol Enumerable not implemented for {1000000001} of type Tuple
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:7: Solution.min_absolute_difference/2
    solution.ex:39: Driver.consume_test_cases/2
    solution.ex:25: Driver.start/0
    nofile:1: (file)",../questions/Medium\minimum-absolute-difference-between-elements-with-constraint\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec min_absolute_difference(nums :: [integer], x :: integer) :: integer
  def min_absolute_difference(nums, x) do
    nums
    |> Enum.with_index()
    |> Enum.sort()
    |> Enum.reduce({1_000_000_001}, fn ({num, idx}, acc) ->
      Enum.reduce_while(acc, acc, fn ({prev_num, prev_idx}, acc_inner) ->
        if abs(idx - prev_idx) >= x do
          diff = abs(num - prev_num)
          new_acc = [{num, idx} | acc_inner]
          {:halt, [diff | new_acc]}
        else
          {:cont, [{prev_num, prev_idx} | acc_inner]}
        end
      end)
    end)
    |> hd()
    |> (fn min_diff -> if min_diff == 1_000_000_001, do: 0, else: min_diff end).()
  end
end"
elixir,runtime_error,"Line 9: ** (FunctionClauseError) no function clause matching in Enum.min_sort_fun/1
    The following arguments were given to Enum.min_sort_fun/1:
        # 1
        [-1]
    Attempted function clauses (showing 2 out of 2):
        defp min_sort_fun(+sorter+) when -is_function(sorter, 2)-
        defp min_sort_fun(+module+) when -is_atom(module)-
    (elixir 1.15.7) lib/enum.ex:2078: Enum.min_sort_fun/1
    (elixir 1.15.7) lib/enum.ex:2075: Enum.min/3
    solution.ex:9: anonymous fn/3 in Solution.minimum_cost/5
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:48: Driver.consume_test_cases/2
    solution.ex:28: Driver.start/0
    nofile:1: (file)",../questions/Medium\minimum-cost-to-convert-string-i\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_cost(source :: String.t, target :: String.t, original :: [char], changed :: [char], cost :: [integer]) :: integer
  def minimum_cost(source, target, original, changed, cost) do
    changes = Enum.zip(original, Enum.zip(changed, cost))
    |> Enum.group_by(fn {orig, _} -> orig end, fn {_, {chg, c}} -> {chg, c} end)

    Enum.zip(String.to_charlist(source), String.to_charlist(target))
    |> Enum.reduce(0, fn {s, t}, acc ->
      if s == t, do: acc, else: acc + min_cost(s, t, changes)
    end)
  end

  defp min_cost(_source, _target, _changes) when is_nil(_changes), do: -1
  defp min_cost(source, target, changes) do
    case changes[source] do
      nil -> -1
      list ->
        list
        |> Enum.filter(fn {chg, _} -> chg == target end)
        |> Enum.map(fn {_, cost} -> cost end)
        |> Enum.min([-1])
    end
  end
end"
elixir,runtime_error,"Line 6: ** (FunctionClauseError) no function clause matching in anonymous fn/2 in Solution.minimum_cost/1
    The following arguments were given to anonymous fn/2 in Solution.minimum_cost/1:
        # 1
        48
        # 2
        {0, 0, 0}
    solution.ex:6: anonymous fn/2 in Solution.minimum_cost/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:6: Solution.minimum_cost/1
    solution.ex:28: Driver.consume_test_cases/2
    solution.ex:16: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\minimum-cost-to-make-all-characters-equal\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_cost(s :: String.t) :: integer
  def minimum_cost(s) do
    s
    |> String.to_charlist()
    |> Enum.reduce({0, 0, 0}, fn
      '0', {zeros, ones, cost} -> {zeros + 1, ones, cost + ones}
      '1', {zeros, ones, cost} -> {zeros, ones + 1, cost + zeros}
    end)
    |> (fn {_, _, cost} -> cost end).()
  end
end"
elixir,runtime_error,"Line 5: ** (FunctionClauseError) no function clause matching in anonymous fn/2 in Solution.minimum_cost/1
    The following arguments were given to anonymous fn/2 in Solution.minimum_cost/1:
        # 1
        48
        # 2
        0
    solution.ex:5: anonymous fn/2 in Solution.minimum_cost/1
    (elixir 1.15.7) lib/enum.ex:4426: Enum.scan_list/3
    solution.ex:5: Solution.minimum_cost/1
    solution.ex:29: Driver.consume_test_cases/2
    solution.ex:17: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\minimum-cost-to-make-all-characters-equal\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_cost(s :: String.t) :: integer
  def minimum_cost(s) do
    n = String.length(s)
    prefix_ones = Enum.scan(String.to_charlist(s), 0, fn '0', acc -> acc; '1', acc -> acc + 1 end)
    suffix_zeros = Enum.scan(String.to_charlist(s) |> Enum.reverse(), 0, fn '1', acc -> acc; '0', acc -> acc + 1 end) |> Enum.reverse()

    Enum.zip(prefix_ones, suffix_zeros)
    |> Enum.map(fn {ones, zeros} -> ones + zeros end)
    |> Enum.min()
    |> min(n)
  end
end"
elixir,runtime_error,"Line 13: ** (ArithmeticError) bad argument in arithmetic expression: nil * 2
    :erlang.*(nil, 2)
    solution.ex:13: anonymous fn/5 in Solution.minimum_index/1
    (elixir 1.15.7) lib/range.ex:526: Enumerable.Range.reduce/5
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:38: Driver.consume_test_cases/2
    solution.ex:26: Driver.start/0
    nofile:1: (file)",../questions/Medium\minimum-index-of-a-valid-split\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_index(nums :: [integer]) :: integer
  def minimum_index(nums) do
    total_count = Enum.frequencies(nums)
    dominant = Enum.find(total_count, fn {_k, v} -> v * 2 > length(nums) end) |> elem(0)

    left_count = %{}
    valid_split = Enum.reduce_while(0..(length(nums) - 2), -1, fn i, acc ->
      left_count = Map.update(left_count, Enum.at(nums, i), 1, &(&1 + 1))
      right_dominant_freq = total_count[dominant] - Map.get(left_count, dominant, 0)

      cond do
        left_count[dominant] * 2 > i + 1 and right_dominant_freq * 2 > length(nums) - i - 1 ->
          {:halt, i + 1}
        true ->
          {:cont, acc}
      end
    end)

    valid_split
  end
end"
elixir,runtime_error,"Line 22: ** (ArgumentError) errors were found at the given arguments:
  * 1st argument: not a list
    :erlang.length(""1001"")
    solution.ex:22: anonymous fn/2 in Solution.min_changes/1
    solution.ex:40: Driver.consume_test_cases/2
    solution.ex:28: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\minimum-number-of-changes-to-make-binary-string-beautiful\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec min_changes(s :: String.t) :: integer
  def min_changes(s) do
    s
    |> String.graphemes()
    |> Enum.with_index()
    |> Enum.reduce({0, 0}, fn {char, index}, {zeros, ones} ->
      if rem(index, 2) == 0 do
        if char == ""0"" do
          {zeros + 1, ones}
        else
          {zeros, ones + 1}
        end
      else
        if char == ""0"" do
          {zeros, ones + 1}
        else
          {zeros + 1, ones}
        end
      end
    end)
    |> (fn {zeros, ones} -> div(length(s), 2) - min(zeros, ones) end).()
  end
end"
elixir,runtime_error,"Line 6: ** (ArgumentError) errors were found at the given arguments:
  * 1st argument: not a list
    :erlang.length(""2245047"")
    solution.ex:6: Solution.minimum_operations/1
    solution.ex:33: Driver.consume_test_cases/2
    solution.ex:21: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\minimum-operations-to-make-a-special-number\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_operations(num :: String.t) :: integer
  def minimum_operations(num) do
    suffixes = [""00"", ""25"", ""50"", ""75""]
    num |> String.graphemes()
        |> Enum.reduce({length(num), 0}, fn digit, {min_ops, idx} ->
          Enum.reduce(suffixes, min_ops, fn suffix, acc ->
            if String.ends_with?(Enum.slice(num, 0..idx), suffix) do
              ops = length(num) - idx - 2
              if ops < acc, do: ops, else: acc
            else
              acc
            end
          end)
        end) |> elem(0)
  end
end"
elixir,runtime_error,"Line 8: ** (FunctionClauseError) no function clause matching in anonymous fn/2 in Solution.minimum_operations/1
    The following arguments were given to anonymous fn/2 in Solution.minimum_operations/1:
        # 1
        {""2"", 1}
        # 2
        7
    solution.ex:8: anonymous fn/2 in Solution.minimum_operations/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:8: Solution.minimum_operations/1
    solution.ex:36: Driver.consume_test_cases/2
    solution.ex:24: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\minimum-operations-to-make-a-special-number\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_operations(num :: String.t) :: integer
  def minimum_operations(num) do
    suffixes = [""00"", ""25"", ""50"", ""75""]
    num
    |> String.graphemes()
    |> Enum.with_index()
    |> Enum.reduce({String.length(num), 0}, fn {digit, idx}, {min_ops, _} ->
      Enum.reduce(suffixes, min_ops, fn suffix, acc ->
        if String.ends_with?(String.slice(num, 0..idx), suffix) do
          ops = String.length(num) - idx - 2
          if ops < acc, do: ops, else: acc
        else
          acc
        end
      end)
    end)
    |> elem(0)
  end
end"
elixir,runtime_error,"Line 41: ** (FunctionClauseError) no function clause matching in Enumerable.Range.reduce/5
    The following arguments were given to Enumerable.Range.reduce/5:
        # 1
        3
        # 2
        60
        # 3
        -1
        # 4
        #Function<0.33365137/2 in Solution.solve/3>
        # 5
        1
    Attempted function clauses (showing 4 out of 4):
        defp reduce(+_first+, +_last+, -{:halt, acc}-, +_fun+, +_step+)
        defp reduce(+first+, +last+, -{:suspend, acc}-, +fun+, +step+)
        defp reduce(+first+, +last+, -{:cont, acc}-, +fun+, +step+) when +step > 0+ and +first <= last+ when -step < 0- and -first >= last-
        defp reduce(+_+, +_+, -{:cont, acc}-, +_fun+, +_up+)
    (elixir 1.15.7) lib/range.ex:515: Enumerable.Range.reduce/5
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    solution.ex:41: Driver.consume_test_cases/2
    solution.ex:27: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\minimum-operations-to-make-the-integer-zero\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec make_the_integer_zero(num1 :: integer, num2 :: integer) :: integer
  def make_the_integer_zero(num1, num2) do
    solve(num1, num2, 0)
  end

  defp solve(0, _, _), do: 0
  defp solve(_, _, 61), do: -1
  defp solve(num1, num2, steps) do
    Enum.reduce_while(0..60, {:cont, -1}, fn i, _acc ->
      delta = :math.pow(2, i) + num2
      if num1 - delta == 0 do
        {:halt, steps + 1}
      else
        if abs(num1 - delta) < abs(num1) do
          solve(num1 - delta, num2, steps + 1)
        else
          {:cont, -1}
        end
      end
    end)
  end
end"
elixir,runtime_error,"Line 17: ** (UndefinedFunctionError) function Enum.append/2 is undefined or private
    (elixir 1.15.7) Enum.append([0, 2], [4])
    solution.ex:17: Solution.find_max_gap/2
    (elixir 1.15.7) lib/enum.ex:1701: anonymous fn/3 in Enum.map/2
    (stdlib 5.1.1) maps.erl:416: :maps.fold_1/4
    (elixir 1.15.7) lib/enum.ex:2522: Enum.map/2
    solution.ex:8: Solution.minimum_seconds/1
    solution.ex:37: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Medium\minimum-seconds-to-equalize-a-circular-array\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_seconds(nums :: [integer]) :: integer
  def minimum_seconds(nums) do
    len = length(nums)
    max_gap = nums
              |> Enum.with_index()
              |> Enum.group_by(fn {num, _} -> num end, fn {_, index} -> index end)
              |> Enum.map(fn {_num, indexes} -> find_max_gap(indexes, len) end)
              |> Enum.max()

    if max_gap == 0, do: 0, else: div(len - max_gap + 1, 2)
  end

  defp find_max_gap(indexes, len) do
    indexes
    |> Enum.sort()
    |> Enum.append([hd(indexes) + len])
    |> Enum.reduce({0, hd(indexes)}, fn x, {max_gap, prev} -> {max(max_gap, x - prev), x} end)
    |> elem(0)
  end
end"
elixir,runtime_error,"Line 11: ** (ArgumentError) ranges (first..last) expect both sides to be integers, got: 3..0..-1//-1
    (elixir 1.15.7) lib/range.ex:193: Range.new/2
    solution.ex:11: Solution.minimum_sum/1
    solution.ex:42: Driver.consume_test_cases/2
    solution.ex:30: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\minimum-sum-of-mountain-triplets-ii\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_sum(nums :: [integer]) :: integer
  def minimum_sum(nums) do
    left_min = Enum.map(nums, & &1)
    right_min = Enum.map(nums, & &1)

    for i <- 1..(length(nums) - 1) do
      left_min = List.replace_at(left_min, i, min(Enum.at(left_min, i - 1), Enum.at(nums, i)))
    end

    for i <- (length(nums) - 2)..0..-1 do
      right_min = List.replace_at(right_min, i, min(Enum.at(right_min, i + 1), Enum.at(nums, i)))
    end

    min_sum = Enum.reduce(1..(length(nums) - 2), :infinity, fn j, acc ->
      if Enum.at(left_min, j - 1) < Enum.at(nums, j) and Enum.at(right_min, j + 1) < Enum.at(nums, j) do
        sum = Enum.at(left_min, j - 1) + Enum.at(nums, j) + Enum.at(right_min, j + 1)
        min(acc, sum)
      else
        acc
      end
    end)

    if min_sum == :infinity, do: -1, else: min_sum
  end
end"
elixir,runtime_error,"Line 10: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:10: anonymous fn/4 in Solution.minimum_sum/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:9: Solution.minimum_sum/1
    solution.ex:44: Driver.consume_test_cases/2
    solution.ex:32: Driver.start/0
    nofile:1: (file)",../questions/Medium\minimum-sum-of-mountain-triplets-ii\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_sum(nums :: [integer]) :: integer
  def minimum_sum(nums) do
    len = length(nums)
    left_min = Enum.map(1..len, fn _ -> :infinity end)
    right_min = Enum.map(1..len, fn _ -> :infinity end)

    # Calculate left min values
    for i <- 1..(len-2) do
      left_min = List.replace_at(left_min, i, Enum.min(List.last(Enum.slice(left_min, 0, i)), nums[i-1]))
    end

    # Calculate right min values
    for i <- (len-2)..-1..1 do
      right_min = List.replace_at(right_min, i, Enum.min(Enum.at(right_min, i+1), nums[i+1]))
    end

    min_sum = :infinity
    for j <- 1..(len-2) do
      if nums[j] > Enum.at(left_min, j) && nums[j] > Enum.at(right_min, j) do
        sum = nums[j] + Enum.at(left_min, j) + Enum.at(right_min, j)
        min_sum = Enum.min(min_sum, sum)
      end
    end

    if min_sum == :infinity, do: -1, else: min_sum
  end
end"
elixir,runtime_error,"Line 8: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:8: anonymous fn/4 in Solution.minimum_sum/1
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:7: Solution.minimum_sum/1
    solution.ex:43: Driver.consume_test_cases/2
    solution.ex:31: Driver.start/0
    nofile:1: (file)",../questions/Medium\minimum-sum-of-mountain-triplets-ii\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec minimum_sum(nums :: [integer]) :: integer
  def minimum_sum(nums) do
    min_left = Enum.map(nums, fn _ -> :infinity end)
    min_right = Enum.map(nums, fn _ -> :infinity end)

    for i <- 1..(length(nums) - 2) do
      min_left = List.replace_at(min_left, i, Enum.min(List.last(Enum.slice(min_left, 0, i)), nums[i - 1]))
    end

    for i <- (length(nums) - 2)..-1..1 do
      min_right = List.replace_at(min_right, i, Enum.min(Enum.at(min_right, i + 1), nums[i + 1]))
    end

    min_sum = Enum.with_index(nums)
    |> Enum.reduce(:infinity, fn {num, i}, acc ->
      if i > 0 and i < length(nums) - 1 and num > Enum.at(min_left, i) and num > Enum.at(min_right, i) do
        sum = num + Enum.at(min_left, i) + Enum.at(min_right, i)
        Enum.min(acc, sum)
      else
        acc
      end
    end)

    if min_sum == :infinity, do: -1, else: min_sum
  end
end"
elixir,runtime_error,"Line 10: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:10: anonymous fn/4 in Solution.sum_distance/3
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:7: Solution.sum_distance/3
    solution.ex:35: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)",../questions/Medium\movement-of-robots\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec sum_distance(nums :: [integer], s :: String.t, d :: integer) :: integer
  def sum_distance(nums, s, d) do
    mod = 1_000_000_007

    pairs = for i <- 0..length(nums)-1, j <- i+1..length(nums)-1, do: {i, j}
    distances = Enum.map(pairs, fn {i, j} ->
      di = if String.at(s, i) == ""L"", do: -d, else: d
      dj = if String.at(s, j) == ""L"", do: -d, else: d
      abs((nums[i] + di) - (nums[j] + dj))
    end)

    Enum.sum(distances) |> rem(mod)
  end
end"
elixir,runtime_error,"Line 13: ** (ArgumentError) ranges (first..last) expect both sides to be integers, got: 2..1.7320508075688772
    (elixir 1.15.7) lib/range.ex:193: Range.new/2
    solution.ex:13: Solution.prime?/1
    (elixir 1.15.7) lib/enum.ex:1121: anonymous fn/3 in Enum.filter/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:2514: Enum.filter/2
    solution.ex:5: Solution.find_prime_pairs/1
    solution.ex:31: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Medium\prime-pairs-with-target-sum\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec find_prime_pairs(n :: integer) :: [[integer]]
  def find_prime_pairs(n) do
    1..n
    |> Enum.filter(&prime?(&1))
    |> Enum.filter(fn x -> prime?(n - x) and x <= n - x end)
    |> Enum.map(&[&1, n - &1])
  end

  defp prime?(1), do: false
  defp prime?(2), do: true
  defp prime?(n) do
    Enum.none?(2..:math.sqrt(n), &rem(n, &1) == 0)
  end
end"
elixir,runtime_error,"Line 5: ** (UndefinedFunctionError) function Enum.none?/2 is undefined or private
    (elixir 1.15.7) Enum.none?(2..1//-1, #Function<3.119932342/1 in Solution.prime?/1>)
    (elixir 1.15.7) lib/enum.ex:1121: anonymous fn/3 in Enum.filter/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:2514: Enum.filter/2
    solution.ex:5: Solution.find_prime_pairs/1
    solution.ex:31: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)",../questions/Medium\prime-pairs-with-target-sum\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec find_prime_pairs(n :: integer) :: [[integer]]
  def find_prime_pairs(n) do
    1..n
    |> Enum.filter(&prime?(&1))
    |> Enum.filter(fn x -> prime?(n - x) and x <= n - x end)
    |> Enum.map(&[&1, n - &1])
  end

  defp prime?(1), do: false
  defp prime?(2), do: true
  defp prime?(n) do
    Enum.none?(2..floor(:math.sqrt(n)), &rem(n, &1) == 0)
  end
end"
elixir,runtime_error,"Line 5: ** (UndefinedFunctionError) function Enum.none?/2 is undefined or private
    (elixir 1.15.7) Enum.none?(2..1//-1, #Function<3.80885423/1 in Solution.prime?/1>)
    (elixir 1.15.7) lib/enum.ex:1121: anonymous fn/3 in Enum.filter/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce_range/5
    (elixir 1.15.7) lib/enum.ex:2514: Enum.filter/2
    solution.ex:5: Solution.find_prime_pairs/1
    solution.ex:31: Driver.consume_test_cases/2
    solution.ex:19: Driver.start/0
    nofile:1: (file)",../questions/Medium\prime-pairs-with-target-sum\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec find_prime_pairs(n :: integer) :: [[integer]]
  def find_prime_pairs(n) do
    1..n
    |> Enum.filter(&prime?(&1))
    |> Enum.filter(fn x -> x <= n - x and prime?(n - x) end)
    |> Enum.map(&[&1, n - &1])
  end

  defp prime?(1), do: false
  defp prime?(2), do: true
  defp prime?(n) do
    Enum.none?(2..div(n, 2), &rem(n, &1) == 0)
  end
end"
elixir,runtime_error,"Line 4: ** (ArgumentError) argument error
    (stdlib 5.1.1) :maps.from_list([1, 6, 7, 8])
    (elixir 1.15.7) lib/enum.ex:1521: Enum.into_map/1
    solution.ex:4: Solution.relocate_marbles/3
    solution.ex:42: Driver.consume_test_cases/2
    solution.ex:26: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\relocate-marbles\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec relocate_marbles(nums :: [integer], move_from :: [integer], move_to :: [integer]) :: [integer]
  def relocate_marbles(nums, move_from, move_to) do
    final_positions = Enum.reduce(Enum.zip(move_from, move_to), Enum.into(nums, %{}), fn {from, to}, acc ->
      if Map.has_key?(acc, from) do
        acc
        |> Map.update!(from, fn count -> count - 1 end)
        |> Map.update(to, 1, &(&1 + 1))
      else
        acc
      end
    end)
    |> Enum.filter(fn {_pos, count} -> count > 0 end)
    |> Enum.map(fn {pos, _count} -> pos end)
    |> Enum.sort()

    case Enum.empty?(final_positions) do
      true -> nums |> Enum.uniq() |> Enum.sort()
      false -> final_positions
    end
  end
end"
elixir,runtime_error,"Line 19: ** (FunctionClauseError) no function clause matching in String.to_charlist/1
    The following arguments were given to String.to_charlist/1:
        # 1
        ~c""?""
    Attempted function clauses (showing 1 out of 1):
        def to_charlist(+string+) when -is_binary(string)-
    (elixir 1.15.7) lib/string.ex:2577: String.to_charlist/1
    solution.ex:19: Solution.almost_equal/2
    solution.ex:7: anonymous fn/2 in Solution.remove_almost_equal_characters/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:6: Solution.remove_almost_equal_characters/1
    solution.ex:47: Driver.consume_test_cases/2
    solution.ex:35: Driver.start/0
    nofile:1: (file)",../questions/Medium\remove-adjacent-almost-equal-characters\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec remove_almost_equal_characters(word :: String.t) :: integer
  def remove_almost_equal_characters(word) do
    word
    |> String.graphemes()
    |> Enum.reduce({0, '?'}, fn x, {acc, prev} ->
      if almost_equal(x, prev) do
        {acc + 1, alternate_char(x)}
      else
        {acc, x}
      end
    end)
    |> elem(0)
  end

  defp almost_equal(a, b) when a == b, do: true
  defp almost_equal(a, b) do
    [code_a] = String.to_charlist(a)
    [code_b] = String.to_charlist(b)
    abs(code_a - code_b) == 1
  end

  defp alternate_char(char) do
    [code] = String.to_charlist(char)
    case code do
      122 -> ""a"" # 'z' -> 'a'
      97 -> ""b""  # 'a' -> 'b'
      _ -> <<code + 2 :: utf8>> # Move two steps to avoid adjacent almost-equal
    end
  end
end"
elixir,runtime_error,"Line 8: ** (UndefinedFunctionError) function String.chr/1 is undefined or private
    (elixir 1.15.7) String.chr(99)
    solution.ex:8: anonymous fn/2 in Solution.remove_almost_equal_characters/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:6: Solution.remove_almost_equal_characters/1
    solution.ex:35: Driver.consume_test_cases/2
    solution.ex:23: Driver.start/0
    nofile:1: (file)",../questions/Medium\remove-adjacent-almost-equal-characters\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec remove_almost_equal_characters(word :: String.t) :: integer
  def remove_almost_equal_characters(word) do
    word
    |> String.graphemes()
    |> Enum.reduce({0, nil}, fn
      x, {acc, nil} -> {acc, x}
      x, {acc, prev} when prev == x or abs(prev - x) == 1 -> {acc + 1, alter_char(x)}
      _, acc -> acc
    end)
    |> elem(0)
  end

  defp alter_char(char) do
    [code] = String.to_charlist(char)
    new_code = if code == 122, do: 97, else: code + 2
    String.chr(new_code)
  end
end"
elixir,runtime_error,"Line 14: ** (UndefinedFunctionError) function Enum.flatten/1 is undefined or private
    (elixir 1.15.7) Enum.flatten([[[[[[[], ""1""], ""0""], ""0""], ""0""], ""1""], ""1""])
    solution.ex:14: anonymous fn/3 in Solution.shortest_beautiful_substring/2
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:6: Solution.shortest_beautiful_substring/2
    solution.ex:54: Driver.consume_test_cases/2
    solution.ex:40: Driver.start/0
    nofile:1: (file)",../questions/Medium\shortest-and-lexicographically-smallest-beautiful-string\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec shortest_beautiful_substring(s :: String.t, k :: integer) :: String.t
  def shortest_beautiful_substring(s, k) do
    s
    |> String.graphemes()
    |> Enum.reduce({[], [], 0, nil}, fn
      ""1"", {acc, temp, count, min} when count == k ->
        {acc, temp, count, min}
      ""1"", {acc, temp, count, min} ->
        new_temp = [temp | [""1""]]
        new_count = count + 1
        cond do
          new_count == k ->
            len = length(Enum.flatten(new_temp))
            new_min = case min do
              nil -> len
              _ -> min(min, len)
            end
            {Enum.flatten(new_temp) ++ acc, [], 0, new_min}
          true ->
            {acc, new_temp, new_count, min}
        end
      ""0"", {acc, temp, count, min} ->
        new_temp = if count > 0, do: [temp | [""0""]], else: temp
        {acc, new_temp, count, min}
    end)
    |> (fn {acc, _, _, min} -> 
          acc 
          |> Enum.chunk_every(min, min, :discard)
          |> Enum.map(&Enum.join/1)
          |> Enum.sort()
          |> hd()
          |> (fn x -> if x == nil, do: """", else: x end).()
       end).()
  end
end"
elixir,runtime_error,"Line 5: ** (UndefinedFunctionError) function Enum.permutations/1 is undefined or private
    (elixir 1.15.7) Enum.permutations([""abc"", ""bca"", ""aaa""])
    solution.ex:5: Solution.minimum_string/3
    solution.ex:55: Driver.consume_test_cases/2
    solution.ex:39: Driver.start/0
    nofile:1: (file)
    (stdlib 5.1.1) erl_eval.erl:750: :erl_eval.do_apply/7",../questions/Medium\shortest-string-that-contains-three-strings\responses\Elixir\response_elixir_0_failed.json,"defmodule Solution do
  @spec minimum_string(a :: String.t, b :: String.t, c :: String.t) :: String.t
  def minimum_string(a, b, c) do
    [a, b, c]
    |> Enum.permutations()
    |> Enum.map(&merge_strings/1)
    |> Enum.min_by(&(&1 |> Tuple.to_list() |> Enum.reduce(0, fn x, acc -> acc + byte_size(x) end)), &(&1))
  end

  defp merge_strings([first | rest]) do
    Enum.reduce(rest, first, fn x, acc ->
      merge_two_strings(acc, x)
    end)
  end

  defp merge_two_strings(s1, s2) when byte_size(s1) >= byte_size(s2) do
    if String.contains?(s1, s2), do: s1, else: merge_helper(s1, s2)
  end
  defp merge_two_strings(s1, s2), do: merge_two_strings(s2, s1)

  defp merge_helper(s1, s2) do
    (0..byte_size(s1)-1)
    |> Enum.map(fn i -> String.slice(s1, i, byte_size(s2)) end)
    |> Enum.with_index()
    |> Enum.reduce_while({s1 <> s2, byte_size(s1) + byte_size(s2)}, fn {sub, i}, {acc, len} ->
      if sub == String.slice(s2, 0, byte_size(sub)) do
        new_str = String.slice(s1, 0, i) <> s2
        if byte_size(new_str) < len, do: {:halt, {new_str, byte_size(new_str)}}, else: {:cont, {acc, len}}
      else
        {:cont, {acc, len}}
      end
    end)
    |> elem(0)
  end
end"
elixir,runtime_error,"Line 9: ** (FunctionClauseError) no function clause matching in Solution.merge_three/1
    The following arguments were given to Solution.merge_three/1:
        # 1
        ""abc""
    solution.ex:9: Solution.merge_three/1
    (elixir 1.15.7) lib/enum.ex:1693: Enum.""-map/2-lists^map/1-1-""/2
    solution.ex:5: anonymous fn/4 in Solution.minimum_string/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum.""-reduce/3-lists^foldl/2-0-""/3
    solution.ex:4: Solution.minimum_string/3
    solution.ex:41: Driver.consume_test_cases/2
    solution.ex:25: Driver.start/0
    nofile:1: (file)",../questions/Medium\shortest-string-that-contains-three-strings\responses\Elixir\response_elixir_1_failed.json,"defmodule Solution do
  @spec minimum_string(a :: String.t, b :: String.t, c :: String.t) :: String.t
  def minimum_string(a, b, c) do
    for x <- [a, b, c], y <- [a, b, c], z <- [a, b, c], x != y and y != z and x != z, do: [x, y, z]
    |> Enum.map(&merge_three/1)
    |> Enum.min()
  end

  defp merge_three([a, b, c]), do: merge(merge(a, b), c)

  defp merge(s1, s2) do
    if String.contains?(s1, s2), do: s1, else: merge_helper(s1, s2)
  end

  defp merge_helper(s1, s2) do
    0..String.length(s1)
    |> Enum.map(fn i -> String.slice(s1, 0, i) <> s2 end)
    |> Enum.find(fn s -> String.contains?(s, s1) and String.contains?(s, s2) end)
    |> Enum.min_by(&String.length/1)
  end
end"
elixir,runtime_error,"Line 7: ** (ArgumentError) the Access module does not support accessing lists by index, got: 0
Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    solution.ex:7: anonymous fn/6 in Solution.max_score/2
    (elixir 1.15.7) lib/enum.ex:4379: Enum.reduce/3
    solution.ex:6: anonymous fn/4 in Solution.max_score/2
    (stdlib 5.1.1) maps.erl:416: :maps.fold_1/4
    solution.ex:5: Solution.max_score/2
    solution.ex:33: Driver.consume_test_cases/2
    nofile:1: (file)",../questions/Medium\visit-array-positions-to-maximize-score\responses\Elixir\response_elixir_2_failed.json,"defmodule Solution do
  @spec max_score(nums :: [integer], x :: integer) :: integer
  def max_score(nums, x) do
    dp = :maps.from_list(Enum.with_index(nums))
    |> Enum.reduce(%{0 => hd(nums)}, fn {value, idx}, acc ->
      max = Enum.reduce(0..idx-1, -1, fn prev_idx, max_so_far ->
        score_if_moved = acc[prev_idx] + value - if rem(nums[prev_idx], 2) !== rem(value, 2), do: x, else: 0
        max(max_so_far, score_if_moved)
      end)
      if max > -1, do: Map.put(acc, idx, max), else: acc
    end)
    |> Map.values()
    |> Enum.max()
  end
end"
